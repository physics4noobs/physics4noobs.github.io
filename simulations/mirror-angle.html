<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mirrors and Images | Physics for Noobs</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;500;600;700&family=Jost:wght@300;400;500;600;700&family=Delius&family=Nova+Square&family=Yatra+One&family=Quintessential&family=Cabin+Sketch:wght@400;700&family=Orbitron:wght@400;500;600;700;800;900&family=Inter:wght@300;400;500;600;700&family=Andika:wght@400;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/achievements.css">
  <link rel="manifest" href="../manifest.json">
  <meta name="theme-color" content="#050510">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="../images/icon-192.svg">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ”¬</text></svg>">
  <script src="../js/theme.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
  <script defer src="../js/firebase-config.js"></script>
  <script defer src="../js/auth.js?v=61"></script>
  <script defer src="../js/ranking.js"></script>
  <script defer src="../js/sim-tracker.js"></script>
  <script defer src="../js/achievements-config.js"></script>
  <script defer src="../js/achievements.js"></script>
</head>
<body data-auth-redirect="../simulations.html">
  <!-- Splash Screen -->
  <div class="splash-screen" id="splash"><div class="splash-rocket"><div class="sp-nose"></div><div class="sp-body"></div><div class="sp-window"></div><div class="sp-fin-l"></div><div class="sp-fin-r"></div><div class="sp-flame"></div><div class="sp-glow"></div></div><div class="splash-logo"><span class="brand-initial">P</span>hysics <span class="brand-accent">for Noobs</span></div><div class="splash-tagline">Free Therapy For Physics Trauma</div></div>
<div class="bg-grid"></div>
  <nav class="navbar scrolled">
    <div class="nav-container">
      <a href="../index.html" class="nav-logo" id="nav-logo">
        <div class="logo-icon"><div class="logo-pendulum"><div class="pendulum-pivot"></div><div class="pendulum-arm"><div class="pendulum-string"></div><div class="pendulum-bob"></div></div></div></div>
        <div class="logo-text"><span class="brand-name"><span class="brand-initial">P</span>hysics <span class="brand-accent">for Noobs</span></span><span class="brand-tag">FREE THERAPY FOR PHYSICS TRAUMA</span></div>
      </a>
      <div class="nav-links">
        <div class="nav-item">
          <a href="../index.html" class="nav-link">Home</a>
        </div>
        <div class="nav-item">
          <a href="../about.html" class="nav-link">About Me</a>
        </div>
        <div class="nav-item"><a href="#" class="nav-link">Chapters</a><div class="dropdown"><a href="../chapters.html"><div class="dd-icon">&#128214;</div> Theory</a><a href="../slides.html"><div class="dd-icon">&#127916;</div> Slides</a></div></div>        <div class="nav-item">
          <a href="../simulations.html" class="nav-link active">Simulations</a>
        </div>
        <div class="nav-item">
          <a href="../tests.html" class="nav-link">Tests</a>
        </div>
        <div class="nav-item">
          <a href="../flashcards.html" class="nav-link">Flashcards</a>
        </div>
        <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme"></button>
        <button class="auth-btn" id="auth-login-btn"><svg class="google-icon" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92a5.06 5.06 0 0 1-2.2 3.32v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.1z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>Sign in</button>
        <a href="progress.html" class="mobile-auth-action" id="mobile-progress-btn" style="display:none;">Progress</a>
        <button class="mobile-auth-action mobile-signout-btn" id="mobile-signout-btn" style="display:none;">Sign Out</button>

        <div class="user-menu nav-item" id="auth-user-menu" style="display:none;"><img class="user-avatar" id="auth-user-avatar" src="" alt="User"><span class="user-rank-badge rank-bronze" id="auth-rank-badge"><span class="rank-icon" id="auth-rank-icon"></span><span id="auth-rank-label"></span></span><div class="dropdown"><div class="dropdown-rank" id="dropdown-rank-display"><span class="rank-tier" id="dropdown-rank-tier"></span><div class="rank-progress-bar"><div class="rank-progress-fill" id="dropdown-rank-fill"></div></div></div><a href="../progress.html"><div class="dd-icon">&#128200;</div> My Progress</a><div class="dropdown-divider"></div><a href="#" id="auth-logout-btn"><div class="dd-icon">&#128682;</div> Sign Out</a></div></div>
      </div>
      <button class="nav-toggle" aria-label="Menu"><span></span><span></span><span></span></button>
    </div>
  </nav>
  <script>
    (function(){
      var s=document.getElementById('splash');
      if(sessionStorage.getItem('ae-splash')){s.style.display='none';}
      else{
        sessionStorage.setItem('ae-splash','1');setTimeout(function(){s.classList.add('fade-out');},2200);setTimeout(function(){s.style.display='none';},2700);
      }
    })();
  </script>

  <style>
    .bg-grid { display: none !important; }

    .sim-wrapper {
      max-width: 1400px;
      margin: 0 auto;
      padding: 80px 24px 40px;
    }

    .sim-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }

    .sim-header h1 {
      font-family: var(--font-display);
      font-size: clamp(1.4rem, 2vw, 1.8rem);
      font-weight: 700;
      color: var(--text-primary);
      letter-spacing: 0.5px;
    }

    .sim-btn {
      padding: 8px 20px;
      font-size: 0.85rem;
      font-weight: 600;
      font-family: var(--font-body);
      color: var(--text-secondary);
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: var(--transition-fast);
    }

    .sim-btn:hover {
      color: var(--text-primary);
      border-color: rgba(124, 58, 237, 0.3);
      background: rgba(124, 58, 237, 0.08);
    }

    .sim-btn.primary {
      background: rgba(124, 58, 237, 0.15);
      color: var(--text-primary);
      border-color: rgba(124, 58, 237, 0.3);
    }

    .sim-btn.primary:hover {
      background: rgba(124, 58, 237, 0.25);
    }

    .sim-main-row {
      display: flex;
      gap: 1px;
      background: var(--border-subtle);
      border-radius: var(--radius-md) var(--radius-md) 0 0;
      overflow: hidden;
    }

    .canvas-wrap {
      flex: 1;
      overflow: hidden;
      background: var(--bg-card);
    }

    .canvas-wrap canvas {
      display: block;
      width: 100%;
    }

    /* Controls */
    .controls-bar {
      display: flex;
      align-items: center;
      gap: clamp(16px, 3.5vw, 40px);
      padding: 18px 24px;
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      border-top: none;
      border-radius: 0 0 var(--radius-md) var(--radius-md);
      flex-wrap: wrap;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .control-group label {
      font-family: var(--font-body);
      font-size: clamp(0.85rem, 1vw, 1.05rem);
      color: var(--text-muted);
      white-space: nowrap;
    }

    .control-group input[type="range"] {
      width: 140px;
      accent-color: var(--color-primary);
    }

    .angle-display {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--color-primary);
      min-width: 36px;
      text-align: right;
    }

    .mode-btn {
      min-width: 100px;
      font-size: 0.82rem !important;
      transition: var(--transition-fast);
    }
    .mode-btn.symmetric {
      background: rgba(0, 255, 170, 0.12);
      border-color: rgba(0, 255, 170, 0.3);
      color: #00ffaa;
    }
    .mode-btn.asymmetric {
      background: rgba(255, 90, 146, 0.12);
      border-color: rgba(255, 90, 146, 0.3);
      color: #ff5a92;
    }
    [data-theme="light"] .mode-btn.symmetric {
      background: rgba(22, 160, 133, 0.1);
      border-color: rgba(22, 160, 133, 0.35);
      color: #0e6655;
    }
    [data-theme="light"] .mode-btn.asymmetric {
      background: rgba(169, 50, 38, 0.08);
      border-color: rgba(169, 50, 38, 0.3);
      color: #922b21;
    }
    /* Side Data Panel */
    .side-data {
      width: 260px;
      min-width: 220px;
      background: var(--bg-card);
      padding: 16px;
      display: flex;
      flex-direction: column;
    }

    .side-data h3 {
      font-family: var(--font-display);
      font-size: 0.88rem;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 14px;
      letter-spacing: 0.5px;
    }

    .data-grid {
      display: flex;
      flex-direction: column;
    }

    .data-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid var(--border-subtle);
    }

    .data-row:last-child {
      border-bottom: none;
    }

    .data-label {
      font-family: var(--font-body);
      font-size: 0.82rem;
      color: var(--text-muted);
    }

    .data-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85rem;
      color: var(--text-primary);
      font-weight: 600;
      text-align: right;
    }

    .data-value.highlight {
      font-size: 1.1rem;
      color: #00d4ff;
    }

    [data-theme="light"] .data-value.highlight {
      color: #0078c8;
    }

    .data-value.sym { color: #00ffaa; }
    .data-value.asym { color: #ff5a92; }
    [data-theme="light"] .data-value.sym { color: #16a085; }
    [data-theme="light"] .data-value.asym { color: #c0392b; }

    /* Equations */
    .equations-section {
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-md);
      padding: 20px 24px;
      margin-top: 16px;
    }

    .equations-section h3 {
      font-family: var(--font-display);
      font-size: clamp(0.8rem, 1vw, 1rem);
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 14px;
    }

    .equations-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 12px 32px;
    }

    .equation-item {
      font-family: var(--font-body);
      font-size: clamp(1rem, 1.2vw, 1.2rem);
      color: var(--text-primary);
      padding: 8px 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      white-space: nowrap;
    }

    .equation-item .eq-label {
      color: var(--text-muted);
      font-size: clamp(0.8rem, 0.9vw, 0.9rem);
      display: block;
      margin-bottom: 2px;
    }

    /* Q&A */
    .qa-section {
      margin-top: 32px;
    }

    .qa-section h2 {
      font-family: var(--font-display);
      font-size: clamp(0.9rem, 1.1vw, 1.1rem);
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 16px;
    }

    .qa-item {
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-md);
      margin-bottom: 8px;
      overflow: hidden;
      transition: var(--transition-fast);
    }

    .qa-item:hover {
      border-color: rgba(124, 58, 237, 0.2);
    }

    .qa-q {
      padding: 16px 24px;
      font-family: var(--font-body);
      font-size: clamp(0.95rem, 1.1vw, 1.15rem);
      color: var(--text-primary);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: var(--transition-fast);
    }

    .qa-q:hover {
      background: var(--bg-glass-hover);
    }

    .qa-q::after {
      content: '+';
      font-size: 1.4rem;
      color: var(--color-primary);
      transition: transform 0.2s;
      font-weight: 300;
    }

    .qa-item.open .qa-q::after {
      content: '\2212';
    }

    .qa-a {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .qa-item.open .qa-a {
      max-height: 500px;
    }

    .qa-a-inner {
      padding: 0 24px 18px;
      font-family: var(--font-body);
      font-size: clamp(0.92rem, 1vw, 1.08rem);
      color: var(--text-secondary);
      line-height: 1.75;
    }

    /* Fullscreen */
    #simArea {
      background: var(--bg-primary);
      position: relative;
    }

    #simArea:fullscreen,
    #simArea:-webkit-full-screen {
      background: var(--bg-primary);
      padding: 16px 24px;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }

    #simArea:fullscreen .sim-main-row,
    #simArea:-webkit-full-screen .sim-main-row {
      flex: 1;
      min-height: 0;
    }

    #simArea:fullscreen .canvas-wrap,
    #simArea:-webkit-full-screen .canvas-wrap {
      flex: 1;
      min-height: 0;
    }

    #simArea:fullscreen .canvas-wrap canvas,
    #simArea:-webkit-full-screen .canvas-wrap canvas {
      height: 100% !important;
    }

    #simArea:fullscreen .side-data,
    #simArea:-webkit-full-screen .side-data {
      width: 200px;
      min-width: 180px;
    }

    #simArea:fullscreen .controls-bar,
    #simArea:-webkit-full-screen .controls-bar {
      border-radius: 0;
    }

    @media (max-width: 900px) {
      .sim-main-row { flex-direction: column; }
      .side-data { width: 100%; min-width: unset; }
    }
    @media (max-width: 768px) {
      .sim-wrapper { padding: 70px 12px 24px; }
      .sim-header { flex-direction: column; gap: 12px; align-items: flex-start; }
      .controls-bar { gap: 12px; padding: 12px; }
    }

    /* === Tutorial Overlay === */
    .sim-tutorial {
      position: absolute;
      inset: 0;
      z-index: 50;
      background: rgba(255,255,255,0.08);
      backdrop-filter: blur(0.5px);
      -webkit-backdrop-filter: blur(0.5px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 0.4s ease;
      cursor: pointer;
      border-radius: var(--radius-md);
    }

    .tut-hint {
      position: absolute;
      display: flex;
      align-items: center;
      gap: 8px;
      color: #fff;
      font-size: 0.88rem;
      pointer-events: none;
    }

    .tut-arrows-svg {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }

    .tut-label {
      font-family: var(--font-body);
      background: rgba(255,255,255,0.92);
      color: #1a1a2e;
      padding: 6px 14px;
      border-radius: 20px;
      font-weight: 600;
      font-size: 0.82rem;
      white-space: nowrap;
      box-shadow: 0 2px 8px rgba(0,0,0,0.18);
    }

    .tut-dismiss {
      position: absolute;
      bottom: 38%;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 32px;
      font-family: var(--font-body);
      font-size: 0.95rem;
      font-weight: 700;
      color: #1a1a2e;
      background: #fff;
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      pointer-events: auto;
      box-shadow: 0 4px 16px rgba(124,58,237,0.3);
      transition: background 0.2s, transform 0.2s;
    }

    .tut-dismiss:hover {
      background: #e8e0f8;
      transform: translateX(-50%) scale(1.04);
    }

    @media (max-width: 900px) {
      .sim-tutorial { display: none !important; }
      #helpBtn { display: none; }
    }
  </style>

  <div class="sim-wrapper">
    <div id="simArea">
    <div class="sim-header">
      <h1>Mirrors and Images</h1>
      <div style="display:flex;gap:8px;">
        <button class="sim-btn" id="resetBtn">Reset</button>
        <button class="sim-btn" id="fullscreenBtn">Full Screen</button>
        <button class="sim-btn" id="helpBtn">? Help</button>
      </div>
    </div>

    <div class="sim-main-row">
      <div class="canvas-wrap">
        <canvas id="simCanvas"></canvas>
      </div>
      <div class="side-data">
        <h3>Data Table</h3>
        <div class="data-grid">
          <div class="data-row">
            <span class="data-label">Mirror Angle (&theta;)</span>
            <span class="data-value" id="dtAngle">90&deg;</span>
          </div>
          <div class="data-row">
            <span class="data-label">n = 360/&theta;</span>
            <span class="data-value" id="dtN">4</span>
          </div>
          <div class="data-row">
            <span class="data-label">n type</span>
            <span class="data-value" id="dtType">Even</span>
          </div>
          <div class="data-row">
            <span class="data-label">Placement</span>
            <span class="data-value" id="dtPlacement">Symmetric</span>
          </div>
          <div class="data-row">
            <span class="data-label">Formula</span>
            <span class="data-value" id="dtFormula">n &minus; 1</span>
          </div>
          <div class="data-row">
            <span class="data-label">Images</span>
            <span class="data-value highlight" id="dtCount">3</span>
          </div>
          <div class="data-row">
            <span class="data-label">Object at &alpha;</span>
            <span class="data-value" id="dtAlpha">45.0&deg;</span>
          </div>
        </div>
      </div>
    </div>

    <div class="controls-bar">
      <div class="control-group">
        <label>Angle:</label>
        <input type="range" id="angleSlider" min="0" max="14" value="10" step="1">
        <span class="angle-display" id="angleLabel">90&deg;</span>
      </div>
      <button class="sim-btn mode-btn symmetric" id="modeBtn">Symmetric</button>
      <span style="width:1px;height:24px;background:var(--border-subtle);"></span>
      <button class="sim-btn" id="resetBtn2">&#8635; Reset</button>
      <span style="font-size: clamp(0.72rem, 0.85vw, 0.82rem); color: var(--text-muted); margin-left: auto;">Drag the object &bull; Adjust mirror angle</span>
    </div>

    <!-- Tutorial Overlay -->
    <div class="sim-tutorial" id="simTutorial" style="display:none;">
      <svg class="tut-arrows-svg" id="tutArrowsSvg"></svg>
      <div class="tut-hint" id="tutHint1" style="top:22%;left:50%;transform:translateX(-50%);">
        <div class="tut-label">Two mirrors meet at a hinge &mdash; adjust the angle with the slider</div>
      </div>
      <div class="tut-hint" id="tutHint2" style="top:55%;left:45%;transform:translateX(-50%);">
        <div class="tut-label">Drag the object between mirrors to see reflections</div>
      </div>
      <div class="tut-hint" id="tutHint3" style="bottom:8%;left:30%;transform:translateX(-50%);">
        <div class="tut-label">Toggle symmetric/asymmetric placement</div>
      </div>
      <button class="tut-dismiss">Got it, let's start!</button>
    </div>

    </div><!-- end #simArea -->

    <div class="equations-section">
      <h3>Key Formulas</h3>
      <div class="equations-grid">
        <div class="equation-item">
          <span class="eq-label">Number Parameter</span>
          n = 360&deg; / &theta;
        </div>
        <div class="equation-item">
          <span class="eq-label">n even</span>
          Images = n &minus; 1
        </div>
        <div class="equation-item">
          <span class="eq-label">n odd, symmetric</span>
          Images = n &minus; 1
        </div>
        <div class="equation-item">
          <span class="eq-label">n odd, asymmetric</span>
          Images = n
        </div>
      </div>
    </div>

    <div class="qa-section">
      <h2>Test Your Understanding</h2>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">How does the number of images change with mirror angle?</div>
        <div class="qa-a"><div class="qa-a-inner">
          As the angle &theta; decreases, <strong>n = 360/&theta;</strong> increases, producing more images. For example, at &theta; = 60&deg;, n = 6, giving <strong>5 images</strong>. At &theta; = 45&deg;, n = 8, giving <strong>7 images</strong>. The smaller the angle, the more times the light bounces between the mirrors before the reflections go &ldquo;behind&rdquo; a mirror.
        </div></div>
      </div>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">What is the difference between symmetric and asymmetric placement?</div>
        <div class="qa-a"><div class="qa-a-inner">
          <strong>Symmetric</strong> means the object sits on the angle bisector (equidistant from both mirrors). When n is odd, symmetric placement gives <strong>n &minus; 1 images</strong> because the last image from each mirror coincides. <strong>Asymmetric</strong> placement (object off the bisector) gives <strong>n images</strong> when n is odd, since the images from each mirror no longer overlap.
        </div></div>
      </div>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">Why do we get infinite images when mirrors are parallel?</div>
        <div class="qa-a"><div class="qa-a-inner">
          When &theta; &rarr; 0&deg; (parallel mirrors), n = 360/0 &rarr; &infin;. Each image acts as an <strong>object for the other mirror</strong>, creating an infinite series of images receding into the distance. In practice the images get progressively dimmer because each reflection absorbs some light, so you see a long but fading corridor of reflections.
        </div></div>
      </div>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">Can you explain why some images are dimmer than others?</div>
        <div class="qa-a"><div class="qa-a-inner">
          Each reflection loses some intensity &mdash; real mirrors absorb a fraction of the light at every bounce. <strong>First-order images</strong> (direct reflections) are the brightest. <strong>Higher-order images</strong> (reflections of reflections of reflections&hellip;) are progressively dimmer. This is why, even with perfectly aligned parallel mirrors, the images eventually fade to invisibility.
        </div></div>
      </div>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">What happens when 360/&theta; is not a whole number?</div>
        <div class="qa-a"><div class="qa-a-inner">
          When 360/&theta; is not an integer, the number of images is approximately the <strong>integer part</strong> (floor) of 360/&theta;. Some reflected images would fall &ldquo;behind&rdquo; one of the mirrors and are not visible. The standard formula applies cleanly only when &theta; divides 360 exactly &mdash; otherwise you get a partial image at the boundary.
        </div></div>
      </div>
    </div>
  </div>

  <script>
    // === THEME COLORS ===
    var tc = {};
    function updateThemeColors() {
      var isLight = document.documentElement.getAttribute('data-theme') === 'light';
      tc = {
        bg: isLight ? '#f5f5f3' : '#0d0d26',
        bgCenter: isLight ? '#f9f9f7' : '#0f0f28',
        mirror: isLight ? 'rgba(30, 30, 55, 0.9)' : 'rgba(210, 215, 230, 0.85)',
        mirrorBright: isLight ? 'rgba(60, 60, 120, 0.5)' : 'rgba(240, 240, 255, 0.45)',
        mirrorGlow: isLight ? 'rgba(40, 40, 100, 0.2)' : 'rgba(200, 200, 255, 0.12)',
        object: isLight ? '#c0392b' : '#ff6b9d',
        objectGlow: isLight ? 'rgba(192, 57, 43, 0.35)' : 'rgba(255, 107, 157, 0.35)',
        flame: isLight ? '#d35400' : '#ffb347',
        flameInner: isLight ? '#e67e22' : '#ffe066',
        image: isLight ? '#0059a3' : '#5ce0ff',
        imageGlow: isLight ? 'rgba(0, 89, 163, 0.25)' : 'rgba(92, 224, 255, 0.2)',
        imageFlame: isLight ? '#2e86c1' : '#8ae0ff',
        arc: isLight ? 'rgba(80, 30, 180, 0.7)' : 'rgba(180, 140, 255, 0.75)',
        bisector: isLight ? 'rgba(0, 130, 80, 0.5)' : 'rgba(0, 255, 170, 0.35)',
        bisectorBright: isLight ? 'rgba(0, 160, 100, 0.8)' : 'rgba(0, 255, 170, 0.8)',
        grid: isLight ? 'rgba(0,60,120,0.08)' : 'rgba(100,140,200,0.06)',
        text: isLight ? '#1a1a2e' : '#e8e8f0',
        textMuted: isLight ? '#555' : '#9090a8',
        vertex: isLight ? 'rgba(80, 30, 180, 0.8)' : 'rgba(180, 140, 255, 0.85)',
        hintBg: isLight ? 'rgba(240,242,248,0.95)' : 'rgba(16,16,38,0.92)',
        symColor: isLight ? '#0e6655' : '#3dffc0',
        asymColor: isLight ? '#a93226' : '#ff6b9d',
        circle: isLight ? '#000000' : '#ffffff'
      };
    }
    updateThemeColors();
    new MutationObserver(function() { updateThemeColors(); })
      .observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });

    // === CANVAS SETUP ===
    var canvas = document.getElementById('simCanvas');
    var ctx = canvas.getContext('2d');
    var canvasW, canvasH;
    var dpr = window.devicePixelRatio || 1;

    function resizeCanvas() {
      var wrap = canvas.parentElement;
      var w = wrap.clientWidth;
      var h;
      // In fullscreen, fill available height; otherwise cap at 620
      var isFS = document.fullscreenElement || document.webkitFullscreenElement;
      if (isFS) {
        h = wrap.clientHeight || Math.max(400, w * 0.65);
      } else {
        h = Math.max(400, Math.min(w * 0.65, 620));
      }
      canvasW = w;
      canvasH = h;
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    // === STATE ===
    var mirrorAngleDeg = 90;
    var targetAngleDeg = 90;      // [2] animated transitions target
    var objAlphaDeg = 45;
    var objDist = 0.75;
    var isSymmetric = true;
    var dragging = false;
    var mirrorLen;
    var glowPhase = 0;            // [4] shimmer animation
    var nearBisector = false;      // [9] snap guide state
    var zoomScale = 1;             // [8] pinch zoom
    var panX = 0, panY = 0;
    var pinching = false;
    var pinchStartDist = 0;
    var pinchStartScale = 1;
    var lastTapTime = 0;

    // Achievement tracking
    var _achSymmetryExplored = false;
    var _achKaleidoscope = false;
    var _achInfiniteReflections = false;
    var _achSeenSymmetric = false;
    var _achSeenAsymmetric = false;

    // ================================================================
    //  PHYSICS â€” Two Plane Mirrors at Angle theta
    // ================================================================
    function mod2pi(a) {
      var TWO_PI = 2 * Math.PI;
      var r = a % TWO_PI;
      if (r < 0) r += TWO_PI;
      return r;
    }

    function isInsideWedge(phi, theta) {
      var eps = 0.003;
      return phi > eps && phi < theta - eps;
    }

    function isOnMirror(phi, theta) {
      var eps = 0.003;
      return phi < eps || Math.abs(phi - theta) < eps || Math.abs(phi - 2 * Math.PI) < eps;
    }

    // A source at angle phi is in front of Mirror 1 (along angle 0)
    // if it's on the reflective side (upper half-plane, toward wedge)
    function canReflectInM1(phi) {
      return Math.sin(phi) > -0.001;
    }

    // A source at angle phi is in front of Mirror 2 (along angle theta)
    // if it's on the reflective side (toward wedge / Mirror 1 side)
    function canReflectInM2(phi, theta) {
      return Math.sin(phi - theta) < 0.001;
    }

    function getImageAngles() {
      var theta = mirrorAngleDeg * Math.PI / 180;
      var alpha = objAlphaDeg * Math.PI / 180;
      if (theta < 0.01) return [];
      var allImages = [];
      var maxK = Math.ceil(360 / mirrorAngleDeg) + 2;

      // Chain A: alternates Mirror 1 â†’ Mirror 2 â†’ Mirror 1 â†’ ...
      var srcA = alpha;
      for (var k = 1; k <= maxK; k++) {
        // Odd step: reflect source in Mirror 1
        if (!canReflectInM1(srcA)) break;
        var a_odd = mod2pi(-(2 * (k - 1) * theta + alpha));
        if (!isInsideWedge(a_odd, theta) && !isOnMirror(a_odd, theta))
          allImages.push({ angle: a_odd, order: 2 * k - 1, chain: 'A' });

        // Even step: reflect odd image in Mirror 2
        if (!canReflectInM2(a_odd, theta)) break;
        var a_even = mod2pi(2 * k * theta + alpha);
        if (!isInsideWedge(a_even, theta) && !isOnMirror(a_even, theta))
          allImages.push({ angle: a_even, order: 2 * k, chain: 'A' });

        srcA = a_even;
      }

      // Chain B: alternates Mirror 2 â†’ Mirror 1 â†’ Mirror 2 â†’ ...
      var srcB = alpha;
      for (var k = 1; k <= maxK; k++) {
        // Odd step: reflect source in Mirror 2
        if (!canReflectInM2(srcB, theta)) break;
        var b_odd = mod2pi(2 * k * theta - alpha);
        if (!isInsideWedge(b_odd, theta) && !isOnMirror(b_odd, theta))
          allImages.push({ angle: b_odd, order: 2 * k - 1, chain: 'B' });

        // Even step: reflect odd image in Mirror 1
        if (!canReflectInM1(b_odd)) break;
        var b_even = mod2pi(alpha - 2 * k * theta);
        if (!isInsideWedge(b_even, theta) && !isOnMirror(b_even, theta))
          allImages.push({ angle: b_even, order: 2 * k, chain: 'B' });

        srcB = b_even;
      }

      var unique = [];
      for (var i = 0; i < allImages.length; i++) {
        var isDup = false;
        for (var j = 0; j < unique.length; j++) {
          var diff = Math.abs(allImages[i].angle - unique[j].angle);
          if (diff < 0.01 || Math.abs(diff - 2 * Math.PI) < 0.01) {
            if (allImages[i].order < unique[j].order) unique[j] = allImages[i];
            isDup = true; break;
          }
        }
        if (!isDup) unique.push(allImages[i]);
      }
      unique.sort(function(a, b) { return a.order - b.order; });
      return unique;
    }

    function getImageCount() {
      var theta = mirrorAngleDeg;
      if (theta <= 0) return { n: Infinity, count: Infinity, isInt: false };
      var n = 360 / theta;
      var isInt = Math.abs(n - Math.round(n)) < 0.01;
      var nInt = Math.round(n);
      var count;
      if (!isInt) { count = Math.floor(n); }
      else if (nInt % 2 === 0) { count = nInt - 1; }
      else { count = isSymmetric ? nInt - 1 : nInt; }
      return { n: n, nInt: isInt ? nInt : n, count: count, isInt: isInt, isEven: isInt && nInt % 2 === 0 };
    }

    // [5] Build reflection chain label for an image
    function getChainLabel(img) {
      var parts = [];
      var first = img.chain === 'A' ? '\u2081' : '\u2082'; // subscript 1 or 2
      var second = img.chain === 'A' ? '\u2082' : '\u2081';
      for (var i = 0; i < img.order; i++) {
        parts.push('M' + (i % 2 === 0 ? first : second));
      }
      return parts.join('');
    }

    // === DATA TABLE UPDATE ===
    var dtAngle = document.getElementById('dtAngle');
    var dtN = document.getElementById('dtN');
    var dtType = document.getElementById('dtType');
    var dtPlacement = document.getElementById('dtPlacement');
    var dtFormula = document.getElementById('dtFormula');
    var dtCount = document.getElementById('dtCount');
    var dtAlpha = document.getElementById('dtAlpha');

    function updateDataTable(info, imageCount) {
      dtAngle.textContent = Math.round(mirrorAngleDeg) + '\u00B0';

      var nVal = 360 / mirrorAngleDeg;
      dtN.textContent = info.isInt ? String(Math.round(nVal)) : nVal.toFixed(2);

      if (!info.isInt) {
        dtType.textContent = 'Non-integer';
      } else if (info.isEven) {
        dtType.textContent = 'Even';
      } else {
        dtType.textContent = 'Odd';
      }

      dtPlacement.textContent = isSymmetric ? 'Symmetric' : 'Asymmetric';
      dtPlacement.className = 'data-value ' + (isSymmetric ? 'sym' : 'asym');

      if (!info.isInt) {
        dtFormula.textContent = '\u230An\u230B';
      } else if (info.isEven) {
        dtFormula.textContent = 'n \u2212 1';
      } else if (isSymmetric) {
        dtFormula.textContent = 'n \u2212 1';
      } else {
        dtFormula.textContent = 'n';
      }

      dtCount.textContent = imageCount > 50 ? '50+' : String(imageCount);
      dtAlpha.textContent = objAlphaDeg.toFixed(1) + '\u00B0';
    }

    // === DRAWING ===
    function draw() {
      if (!canvasW) return;
      ctx.save();
      ctx.clearRect(0, 0, canvasW, canvasH);

      // Background (always drawn without zoom transform)
      var grad = ctx.createRadialGradient(canvasW * 0.5, canvasH * 0.5, 0, canvasW * 0.5, canvasH * 0.5, canvasW * 0.6);
      grad.addColorStop(0, tc.bgCenter);
      grad.addColorStop(1, tc.bg);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvasW, canvasH);

      // Grid (without zoom)
      ctx.strokeStyle = tc.grid;
      ctx.lineWidth = 0.5;
      var gridSize = 40;
      for (var gx = gridSize; gx < canvasW; gx += gridSize) {
        ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, canvasH); ctx.stroke();
      }
      for (var gy = gridSize; gy < canvasH; gy += gridSize) {
        ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(canvasW, gy); ctx.stroke();
      }

      // [8] Apply zoom transform for all simulation content
      var cx = canvasW * 0.5, cy = canvasH * 0.5;
      ctx.translate(cx + panX, cy + panY);
      ctx.scale(zoomScale, zoomScale);
      ctx.translate(-cx, -cy);

      var vx = canvasW * 0.5;
      var vy = canvasH * 0.5;
      var thetaRad = mirrorAngleDeg * Math.PI / 180;
      mirrorLen = Math.min(canvasW * 0.45, canvasH * 0.45);

      // [1] Full circle outline â€” shows all images lie on this circle
      var objR = objDist * mirrorLen;
      ctx.save();
      ctx.strokeStyle = tc.circle;
      ctx.globalAlpha = 0.25;
      ctx.lineWidth = 1.5;
      ctx.setLineDash([6, 8]);
      ctx.beginPath();
      ctx.arc(vx, vy, objR, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      // Label the circle
      ctx.globalAlpha = 0.4;
      ctx.fillStyle = tc.circle;
      ctx.font = '500 0.72rem "JetBrains Mono", monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      // Place label at bottom of circle, avoiding mirror wedge
      var circLabelAngle = Math.PI * 0.5 + thetaRad * 0.5; // below, offset from wedge
      ctx.fillText('image circle', vx + Math.cos(circLabelAngle) * (objR + 16), vy + Math.sin(circLabelAngle) * (objR + 16));
      ctx.restore();

      // Angle arc
      ctx.strokeStyle = tc.arc;
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.arc(vx, vy, 45, -thetaRad, 0);
      ctx.stroke();

      // Angle label
      ctx.fillStyle = tc.arc;
      ctx.font = '600 ' + (canvasW < 500 ? '0.8rem' : '0.95rem') + ' "JetBrains Mono", monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      var labelAngle = -thetaRad / 2;
      ctx.fillText(mirrorAngleDeg + '\u00B0', vx + Math.cos(labelAngle) * 62, vy + Math.sin(labelAngle) * 62);

      // [4] Draw mirrors with shimmer
      drawMirror(vx, vy, 0, mirrorLen, 1);
      drawMirror(vx, vy, -thetaRad, mirrorLen, -1);

      // Bisector line when n is odd
      var info = getImageCount();
      var bisCanvasAngle = -thetaRad / 2;
      if (info.isInt && !info.isEven) {
        ctx.save();
        // [9] Snap-to-bisector guide â€” brighter when near bisector
        var bisAlpha = nearBisector ? (0.5 + 0.3 * Math.sin(glowPhase * 3)) : 1;
        ctx.strokeStyle = nearBisector ? tc.bisectorBright : tc.bisector;
        ctx.lineWidth = nearBisector ? 2 : 1;
        ctx.setLineDash(nearBisector ? [3, 3] : [6, 6]);
        ctx.beginPath();
        ctx.moveTo(vx, vy);
        ctx.lineTo(vx + Math.cos(bisCanvasAngle) * mirrorLen * 0.85, vy + Math.sin(bisCanvasAngle) * mirrorLen * 0.85);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();

        ctx.fillStyle = nearBisector ? tc.bisectorBright : tc.bisector;
        ctx.font = '500 0.78rem "Andika", sans-serif';
        ctx.textAlign = 'center';
        var blx = vx + Math.cos(bisCanvasAngle) * (mirrorLen * 0.92);
        var bly = vy + Math.sin(bisCanvasAngle) * (mirrorLen * 0.92);
        ctx.fillText('bisector', blx, bly);
      }

      // Vertex
      ctx.beginPath();
      ctx.arc(vx, vy, 6, 0, Math.PI * 2);
      ctx.fillStyle = tc.vertex;
      ctx.fill();

      // Object position
      var alphaRad = objAlphaDeg * Math.PI / 180;
      var objCanvasAngle = -alphaRad;
      var ox = vx + Math.cos(objCanvasAngle) * objR;
      var oy = vy + Math.sin(objCanvasAngle) * objR;

      // Compute images
      var images = getImageAngles();

      // Draw images
      for (var i = 0; i < images.length; i++) {
        var img = images[i];
        var canvasAngle = -img.angle;
        var ix = vx + Math.cos(canvasAngle) * objR;
        var iy = vy + Math.sin(canvasAngle) * objR;
        var fade = Math.max(0.2, 1 - (img.order - 1) * 0.12);
        drawCandle(ix, iy, tc.image, tc.imageFlame, fade, true); // [3] laterally inverted

        // [5] Image labels with reflection chain
        if (images.length <= 12) {
          ctx.save();
          ctx.globalAlpha = fade * 0.8;
          ctx.fillStyle = tc.image;
          ctx.font = '600 0.68rem "JetBrains Mono", monospace';
          ctx.textAlign = 'center';
          ctx.fillText(getChainLabel(img), ix, iy + 24);
          ctx.globalAlpha = 1;
          ctx.restore();
        } else if (images.length <= 20) {
          ctx.save();
          ctx.globalAlpha = fade * 0.7;
          ctx.fillStyle = tc.image;
          ctx.font = '600 0.68rem "JetBrains Mono", monospace';
          ctx.textAlign = 'center';
          ctx.fillText('I' + (i + 1), ix, iy + 22);
          ctx.globalAlpha = 1;
          ctx.restore();
        }
      }

      // Draw object (on top) â€” [3] candle shape
      drawCandle(ox, oy, tc.object, tc.flame, 1, false);

      // Object label
      ctx.fillStyle = tc.object;
      ctx.font = '700 0.88rem "Andika", sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Object', ox, oy - 42);

      // [9] Snap tooltip
      if (nearBisector && !isSymmetric && info.isInt && !info.isEven) {
        var tipX = ox, tipY = oy - 46;
        ctx.save();
        ctx.globalAlpha = 0.7 + 0.3 * Math.sin(glowPhase * 3);
        ctx.fillStyle = tc.hintBg;
        var tw = 90, th = 18;
        ctx.beginPath();
        ctx.roundRect(tipX - tw / 2, tipY - th / 2, tw, th, 6);
        ctx.fill();
        ctx.fillStyle = tc.symColor;
        ctx.font = '600 0.72rem "Andika", sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Near bisector', tipX, tipY);
        ctx.globalAlpha = 1;
        ctx.restore();
      }

      // Restore from zoom transform before drawing HUD
      ctx.restore();

      // Update the HTML data table
      updateDataTable(info, images.length);
    }

    // [4] Mirror with gradient shimmer
    function drawMirror(vx, vy, canvasAngle, len, hashSide) {
      var ex = vx + Math.cos(canvasAngle) * len;
      var ey = vy + Math.sin(canvasAngle) * len;
      var perpAngle = canvasAngle + Math.PI / 2;
      var px = Math.cos(perpAngle);
      var py = Math.sin(perpAngle);

      ctx.save();

      // Dotted extension behind the vertex (opposite direction)
      var extLen = len;
      var bx = vx - Math.cos(canvasAngle) * extLen;
      var by = vy - Math.sin(canvasAngle) * extLen;
      ctx.save();
      ctx.strokeStyle = tc.mirror;
      ctx.lineWidth = 1.5;
      ctx.globalAlpha = 0.3;
      ctx.setLineDash([4, 6]);
      ctx.beginPath();
      ctx.moveTo(vx, vy);
      ctx.lineTo(bx, by);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();

      // Shimmer gradient strip (perpendicular to mirror)
      for (var d = 0; d < len; d += 2) {
        var mx = vx + Math.cos(canvasAngle) * d;
        var my = vy + Math.sin(canvasAngle) * d;
        var shimmer = 0.3 + 0.7 * Math.pow(Math.sin(d / len * Math.PI), 0.5);
        var pulse = 0.08 * Math.sin(glowPhase * 2 + d * 0.05);
        var alpha = (shimmer + pulse) * 0.6;

        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.strokeStyle = tc.mirrorBright;
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(mx - px * 3, my - py * 3);
        ctx.lineTo(mx + px * 3, my + py * 3);
        ctx.stroke();
        ctx.restore();
      }

      // Core mirror line
      ctx.strokeStyle = tc.mirror;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(vx, vy);
      ctx.lineTo(ex, ey);
      ctx.stroke();

      // Hash marks
      var hashLen = 8;
      var hashGap = 14;
      var hashPerp = canvasAngle + hashSide * Math.PI / 2;
      ctx.strokeStyle = tc.mirror;
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.45;
      for (var d = hashGap; d < len - 5; d += hashGap) {
        var hx = vx + Math.cos(canvasAngle) * d;
        var hy = vy + Math.sin(canvasAngle) * d;
        ctx.beginPath();
        ctx.moveTo(hx, hy);
        ctx.lineTo(hx + Math.cos(hashPerp) * hashLen, hy + Math.sin(hashPerp) * hashLen);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // [3] Candle object â€” body + flame + base, with lateral inversion for images
    function drawCandle(x, y, bodyColor, flameColor, alpha, isImage) {
      ctx.save();
      ctx.globalAlpha = alpha;

      if (!isImage) {
        ctx.shadowColor = tc.objectGlow;
        ctx.shadowBlur = 14;
      } else {
        ctx.shadowColor = tc.imageGlow;
        ctx.shadowBlur = 10;
      }

      // Lateral inversion for images
      if (isImage) {
        ctx.translate(x, y);
        ctx.scale(-1, 1);
        ctx.translate(-x, -y);
      }

      var bw = 6, bh = 16; // body width/height

      // Base platform
      ctx.fillStyle = bodyColor;
      ctx.fillRect(x - bw - 2, y, (bw + 2) * 2, 2);

      // Candle body (rounded rect)
      ctx.beginPath();
      ctx.roundRect(x - bw / 2, y - bh, bw, bh, 1.5);
      ctx.fillStyle = bodyColor;
      ctx.fill();

      // Wick
      ctx.strokeStyle = bodyColor;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x, y - bh);
      ctx.lineTo(x, y - bh - 4);
      ctx.stroke();

      // Flame â€” teardrop
      ctx.shadowBlur = 0;
      var flameH = 10, flameW = 4;
      var fy = y - bh - 4;
      // Outer flame
      ctx.beginPath();
      ctx.moveTo(x, fy - flameH);
      ctx.bezierCurveTo(x - flameW, fy - flameH * 0.4, x - flameW * 0.8, fy, x, fy);
      ctx.bezierCurveTo(x + flameW * 0.8, fy, x + flameW, fy - flameH * 0.4, x, fy - flameH);
      ctx.fillStyle = flameColor;
      ctx.fill();
      // Inner flame (brighter)
      ctx.beginPath();
      var ifw = flameW * 0.5, ifh = flameH * 0.6;
      ctx.moveTo(x, fy - ifh);
      ctx.bezierCurveTo(x - ifw, fy - ifh * 0.3, x - ifw * 0.8, fy - 1, x, fy - 1);
      ctx.bezierCurveTo(x + ifw * 0.8, fy - 1, x + ifw, fy - ifh * 0.3, x, fy - ifh);
      ctx.fillStyle = tc.flameInner;
      ctx.globalAlpha = alpha * 0.8;
      ctx.fill();

      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // === INTERACTION ===
    function getMousePos(e) {
      var rect = canvas.getBoundingClientRect();
      var clientX = e.touches ? e.touches[0].clientX : e.clientX;
      var clientY = e.touches ? e.touches[0].clientY : e.clientY;
      // Account for zoom transform
      var rawX = clientX - rect.left;
      var rawY = clientY - rect.top;
      var cx = canvasW * 0.5, cy = canvasH * 0.5;
      return {
        x: (rawX - cx - panX) / zoomScale + cx,
        y: (rawY - cy - panY) / zoomScale + cy
      };
    }

    function getRawMousePos(e) {
      var rect = canvas.getBoundingClientRect();
      var clientX = e.touches ? e.touches[0].clientX : e.clientX;
      var clientY = e.touches ? e.touches[0].clientY : e.clientY;
      return { x: clientX - rect.left, y: clientY - rect.top };
    }

    function getObjectXY() {
      var vx = canvasW * 0.5;
      var vy = canvasH * 0.5;
      var alphaRad = objAlphaDeg * Math.PI / 180;
      var canvasAngle = -alphaRad;
      var r = objDist * mirrorLen;
      return { x: vx + Math.cos(canvasAngle) * r, y: vy + Math.sin(canvasAngle) * r };
    }

    function startDrag(e) {
      // [8] Check for pinch zoom (2 fingers)
      if (e.touches && e.touches.length === 2) {
        pinching = true;
        dragging = false;
        var dx = e.touches[0].clientX - e.touches[1].clientX;
        var dy = e.touches[0].clientY - e.touches[1].clientY;
        pinchStartDist = Math.sqrt(dx * dx + dy * dy);
        pinchStartScale = zoomScale;
        e.preventDefault();
        return;
      }

      // [8] Double-tap to reset zoom
      if (e.touches && e.touches.length === 1) {
        var now = Date.now();
        if (now - lastTapTime < 300 && zoomScale > 1.01) {
          zoomScale = 1; panX = 0; panY = 0;
          lastTapTime = 0;
          e.preventDefault();
          return;
        }
        lastTapTime = now;
      }

      var pos = getMousePos(e);
      var obj = getObjectXY();
      var dx = pos.x - obj.x;
      var dy = pos.y - obj.y;
      if (dx * dx + dy * dy < 900) {
        dragging = true;
        e.preventDefault();
      }
    }

    function onDrag(e) {
      // [8] Pinch zoom handling
      if (pinching && e.touches && e.touches.length === 2) {
        e.preventDefault();
        var dx = e.touches[0].clientX - e.touches[1].clientX;
        var dy = e.touches[0].clientY - e.touches[1].clientY;
        var dist = Math.sqrt(dx * dx + dy * dy);
        zoomScale = Math.max(1, Math.min(3, pinchStartScale * (dist / pinchStartDist)));
        return;
      }

      var pos = getMousePos(e);

      if (!dragging) {
        var obj = getObjectXY();
        var dx = pos.x - obj.x;
        var dy = pos.y - obj.y;
        canvas.style.cursor = (dx * dx + dy * dy < 900) ? 'grab' : 'default';
        return;
      }
      e.preventDefault();
      canvas.style.cursor = 'grabbing';

      var vx = canvasW * 0.5;
      var vy = canvasH * 0.5;
      var thetaRad = mirrorAngleDeg * Math.PI / 180;

      var dx = pos.x - vx;
      var dy = pos.y - vy;
      var canvasAngle = Math.atan2(dy, dx);
      var alpha = -canvasAngle;

      var marginDeg = Math.min(3, mirrorAngleDeg * 0.1);
      var marginRad = marginDeg * Math.PI / 180;

      if (isSymmetric) {
        alpha = thetaRad / 2;
      } else {
        if (alpha < marginRad) alpha = marginRad;
        if (alpha > thetaRad - marginRad) alpha = thetaRad - marginRad;

        // [9] Snap-to-bisector detection
        var bisAngle = thetaRad / 2;
        var distToBis = Math.abs(alpha - bisAngle) * 180 / Math.PI;
        nearBisector = distToBis < 3;
        if (distToBis < 1) {
          alpha = bisAngle; // actual snap
        }
      }

      objAlphaDeg = alpha * 180 / Math.PI;

      var dist = Math.sqrt(dx * dx + dy * dy);
      objDist = Math.max(0.15, Math.min(0.85, dist / mirrorLen));
    }

    function endDrag(e) {
      if (pinching) {
        pinching = false;
        return;
      }
      if (dragging) {
        dragging = false;
        nearBisector = false;
        canvas.style.cursor = 'default';
      }
    }

    canvas.addEventListener('mousedown', startDrag);
    canvas.addEventListener('mousemove', onDrag);
    canvas.addEventListener('mouseup', endDrag);
    canvas.addEventListener('mouseleave', endDrag);
    canvas.addEventListener('touchstart', startDrag, { passive: false });
    canvas.addEventListener('touchmove', onDrag, { passive: false });
    canvas.addEventListener('touchend', endDrag);

    // === CONTROLS ===
    var VALID_ANGLES = [10, 12, 15, 18, 20, 24, 30, 36, 40, 45, 60, 72, 90, 120, 180];
    var angleSlider = document.getElementById('angleSlider');
    var angleLabel = document.getElementById('angleLabel');
    var modeBtn = document.getElementById('modeBtn');

    angleSlider.addEventListener('input', function() {
      targetAngleDeg = VALID_ANGLES[parseInt(this.value)]; // [2] animate to target
      angleLabel.innerHTML = targetAngleDeg + '&deg;';
      if (targetAngleDeg === 60) _achKaleidoscope = true;
      if (targetAngleDeg === 10) _achInfiniteReflections = true;
    });

    modeBtn.addEventListener('click', function() {
      isSymmetric = !isSymmetric;
      if (isSymmetric) _achSeenSymmetric = true;
      else _achSeenAsymmetric = true;

      if (_achSeenSymmetric && _achSeenAsymmetric) {
        var n = 360 / mirrorAngleDeg;
        var isInt = Math.abs(n - Math.round(n)) < 0.01;
        if (isInt && Math.round(n) % 2 === 1) _achSymmetryExplored = true;
      }

      if (isSymmetric) {
        this.textContent = 'Symmetric';
        this.className = 'sim-btn mode-btn symmetric';
        objAlphaDeg = mirrorAngleDeg / 2;
      } else {
        this.textContent = 'Asymmetric';
        this.className = 'sim-btn mode-btn asymmetric';
        objAlphaDeg = mirrorAngleDeg / 3;
        if (objAlphaDeg < 3) objAlphaDeg = 3;
      }
    });

    // Reset
    function resetSim() {
      targetAngleDeg = 90;
      mirrorAngleDeg = 90;
      objAlphaDeg = 45;
      objDist = 0.75;
      isSymmetric = true;
      zoomScale = 1; panX = 0; panY = 0;
      angleSlider.value = 12;
      angleLabel.innerHTML = '90&deg;';
      modeBtn.textContent = 'Symmetric';
      modeBtn.className = 'sim-btn mode-btn symmetric';
    }

    document.getElementById('resetBtn').addEventListener('click', resetSim);
    document.getElementById('resetBtn2').addEventListener('click', resetSim);

    // Fullscreen
    document.getElementById('fullscreenBtn').addEventListener('click', function() {
      var area = document.getElementById('simArea');
      if (area.requestFullscreen) area.requestFullscreen();
      else if (area.webkitRequestFullscreen) area.webkitRequestFullscreen();
    });
    document.addEventListener('fullscreenchange', function() { setTimeout(resizeCanvas, 100); setTimeout(resizeCanvas, 300); });
    document.addEventListener('webkitfullscreenchange', function() { setTimeout(resizeCanvas, 100); setTimeout(resizeCanvas, 300); });

    // Tutorial
    var helpBtn = document.getElementById('helpBtn');
    var tutorial = document.getElementById('simTutorial');
    var tutShown = sessionStorage.getItem('ae-mirror-tut');
    if (!tutShown && window.innerWidth > 900) tutorial.style.display = '';
    helpBtn.addEventListener('click', function() {
      tutorial.style.display = tutorial.style.display === 'none' ? '' : 'none';
    });
    tutorial.querySelector('.tut-dismiss').addEventListener('click', function() {
      tutorial.style.display = 'none';
      sessionStorage.setItem('ae-mirror-tut', '1');
    });

    // [2] Main animation loop â€” handles smooth angle transitions + shimmer
    function animationLoop() {
      glowPhase += 0.02;
      if (glowPhase > Math.PI * 2) glowPhase -= Math.PI * 2;

      // Animate toward target angle
      var diff = targetAngleDeg - mirrorAngleDeg;
      if (Math.abs(diff) > 0.3) {
        mirrorAngleDeg += diff * 0.15;
        // Re-clamp object
        if (isSymmetric) {
          objAlphaDeg = mirrorAngleDeg / 2;
        } else {
          var margin = Math.min(3, mirrorAngleDeg * 0.1);
          if (objAlphaDeg < margin) objAlphaDeg = margin;
          if (objAlphaDeg > mirrorAngleDeg - margin) objAlphaDeg = mirrorAngleDeg - margin;
        }
      } else if (Math.abs(diff) > 0.01) {
        mirrorAngleDeg = targetAngleDeg;
        if (isSymmetric) objAlphaDeg = mirrorAngleDeg / 2;
      }

      draw();
      requestAnimationFrame(animationLoop);
    }

    // Init
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    requestAnimationFrame(animationLoop);

    // Service worker
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('../sw.js');
    }
  </script>
  <script src="../js/main.js"></script>
  <script src="../js/auth-gate.js"></script>
</body>
</html>
