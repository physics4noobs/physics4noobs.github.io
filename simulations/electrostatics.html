<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Electric Field Lines | Physics for Noobs</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;500;600;700&family=Delius&family=Nova+Square&family=Cabin+Sketch:wght@400;700&family=Orbitron:wght@400;500;600;700;800;900&family=Inter:wght@300;400;500;600;700&family=Andika:wght@400;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/achievements.css">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ”¬</text></svg>">
  <script src="../js/theme.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
  <script defer src="../js/firebase-config.js"></script>
  <script defer src="../js/auth.js"></script>
  <script defer src="../js/ranking.js"></script>
  <script defer src="../js/sim-tracker.js"></script>
  <script defer src="../js/achievements-config.js"></script>
  <script defer src="../js/achievements.js"></script>
</head>
<body>
  <!-- Splash Screen -->
  <div class="splash-screen" id="splash"><div class="splash-rocket"><div class="sp-nose"></div><div class="sp-body"></div><div class="sp-window"></div><div class="sp-fin-l"></div><div class="sp-fin-r"></div><div class="sp-flame"></div><div class="sp-glow"></div></div><div class="splash-logo">Physics <span class="brand-accent">for Noobs</span></div><div class="splash-tagline">Learn. Play. Master.</div></div>
<div class="bg-grid"></div>
  <nav class="navbar scrolled">
    <div class="nav-container">
      <a href="../index.html" class="nav-logo" id="nav-logo">
        <div class="logo-icon"><div class="logo-rocket">
  <div class="rocket-nose"></div>
  <div class="rocket-body"></div>
  <div class="rocket-window"></div>
  <div class="rocket-mark">4N</div>
            <div class="rocket-fin-l"></div>
  <div class="rocket-fin-r"></div>
  <div class="rocket-flame"></div>
  <div class="rocket-star"></div>
            <div class="rocket-star"></div>
            <div class="rocket-star"></div>
            <div class="rocket-glow"></div>
<div class="rocket-exhaust"></div>
            <div class="rocket-exhaust"></div>
            <div class="rocket-exhaust"></div>
          </div></div>
        <div class="logo-text"><span class="brand-name">Physics <span class="brand-accent">for Noobs</span></span><span class="brand-tag">LEARN. PLAY. MASTER.</span></div>
      </a>
      <div class="nav-links">
        <div class="nav-item">
          <a href="../index.html" class="nav-link">Home</a>
        </div>
        <div class="nav-item">
          <a href="../about.html" class="nav-link">About Me</a>
        </div>
        <div class="nav-item"><a href="../chapters.html" class="nav-link">Chapters</a></div>        <div class="nav-item">
          <a href="../simulations.html" class="nav-link active">Simulations</a>
        </div>
        <div class="nav-item">
          <a href="../tests.html" class="nav-link">Tests</a>
        </div>
        <div class="nav-item">
          <a href="../flashcards.html" class="nav-link">Flashcards</a>
        </div>
        <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme"></button>
        <button class="auth-btn" id="auth-login-btn"><svg class="google-icon" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92a5.06 5.06 0 0 1-2.2 3.32v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.1z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>Sign in</button>
        <div class="user-menu nav-item" id="auth-user-menu" style="display:none;"><img class="user-avatar" id="auth-user-avatar" src="" alt="User"><span class="user-rank-badge rank-bronze" id="auth-rank-badge"><span class="rank-icon" id="auth-rank-icon"></span><span id="auth-rank-label"></span></span><div class="dropdown"><div class="dropdown-rank" id="dropdown-rank-display"><span class="rank-tier" id="dropdown-rank-tier"></span><div class="rank-progress-bar"><div class="rank-progress-fill" id="dropdown-rank-fill"></div></div></div><a href="../progress.html"><div class="dd-icon">&#128200;</div> My Progress</a><div class="dropdown-divider"></div><a href="#" id="auth-logout-btn"><div class="dd-icon">&#128682;</div> Sign Out</a></div></div>
      </div>
      <button class="nav-toggle" aria-label="Menu"><span></span><span></span><span></span></button>
    </div>
  </nav>
  <script>
    (function(){
      var s=document.getElementById('splash');
      if(sessionStorage.getItem('ae-splash')){s.style.display='none';}
      else{
        sessionStorage.setItem('ae-splash','1');setTimeout(function(){s.classList.add('fade-out');},2200);setTimeout(function(){s.style.display='none';},2700);
      }
    })();
  </script>

  <style>
    .bg-grid, #particles-canvas { display: none !important; }

    .sim-wrapper {
      max-width: 1400px;
      margin: 0 auto;
      padding: 80px 24px 40px;
    }

    .sim-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }

    .sim-header h1 {
      font-family: var(--font-display);
      font-size: clamp(1.4rem, 2vw, 1.8rem);
      font-weight: 700;
      color: var(--text-primary);
      letter-spacing: 0.5px;
    }

    .sim-btn {
      padding: 8px 20px;
      font-size: 0.85rem;
      font-weight: 600;
      font-family: var(--font-body);
      color: var(--text-secondary);
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: var(--transition-fast);
    }

    .sim-btn:hover {
      color: var(--text-primary);
      border-color: rgba(124, 58, 237, 0.3);
      background: rgba(124, 58, 237, 0.08);
    }

    .sim-btn.primary {
      background: rgba(124, 58, 237, 0.15);
      color: var(--text-primary);
      border-color: rgba(124, 58, 237, 0.3);
    }

    .sim-btn.primary:hover {
      background: rgba(124, 58, 237, 0.25);
    }

    .sim-main-row {
      display: flex;
      gap: 1px;
      background: var(--border-subtle);
      border-radius: var(--radius-md) var(--radius-md) 0 0;
      overflow: hidden;
    }

    .canvas-wrap {
      flex: 1;
      overflow: hidden;
      background: var(--bg-secondary);
    }

    .canvas-wrap canvas {
      display: block;
      width: 100%;
    }

    .side-data {
      width: 220px;
      min-width: 200px;
      background: var(--bg-card);
      padding: 16px;
      display: flex;
      flex-direction: column;
    }

    .side-data h3 {
      font-family: var(--font-display);
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 12px;
    }

    .data-grid {
      display: flex;
      flex-direction: column;
    }

    .data-row {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      border-bottom: 1px solid var(--border-subtle);
    }
    .data-row:last-child { border-bottom: none; }

    .data-label {
      font-family: var(--font-body);
      font-size: clamp(0.82rem, 0.95vw, 0.95rem);
      color: var(--text-muted);
    }

    .data-value {
      font-family: var(--font-body);
      font-size: clamp(0.85rem, 1vw, 1rem);
      color: var(--text-primary);
      font-weight: 600;
    }

    /* Controls */
    .controls-bar {
      display: flex;
      align-items: center;
      gap: clamp(16px, 3.5vw, 40px);
      padding: 18px 24px;
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      border-top: none;
      border-radius: 0 0 var(--radius-md) var(--radius-md);
      flex-wrap: wrap;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .control-group label {
      font-family: var(--font-body);
      font-size: clamp(0.85rem, 1vw, 1.05rem);
      color: var(--text-muted);
      white-space: nowrap;
    }

    .charge-btn {
      min-width: 48px;
      font-size: 1rem !important;
      transition: var(--transition-fast);
      opacity: 0.55;
    }
    .charge-btn.active {
      opacity: 1;
      box-shadow: 0 0 10px rgba(124,58,237,0.25);
      transform: scale(1.06);
    }

    /* Equations */
    .equations-section {
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-md);
      padding: 20px 24px;
      margin-top: 16px;
    }

    .equations-section h3 {
      font-family: var(--font-display);
      font-size: clamp(0.8rem, 1vw, 1rem);
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 14px;
    }

    .equations-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 12px 32px;
    }

    .equation-item {
      font-family: var(--font-body);
      font-size: clamp(1rem, 1.2vw, 1.2rem);
      color: var(--text-primary);
      padding: 8px 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      white-space: nowrap;
    }

    .equation-item .eq-label {
      color: var(--text-muted);
      font-size: clamp(0.8rem, 0.9vw, 0.9rem);
      display: block;
      margin-bottom: 2px;
    }

    /* Q&A */
    .qa-section {
      margin-top: 32px;
    }

    .qa-section h2 {
      font-family: var(--font-display);
      font-size: clamp(0.9rem, 1.1vw, 1.1rem);
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 16px;
    }

    .qa-item {
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-md);
      margin-bottom: 8px;
      overflow: hidden;
      transition: var(--transition-fast);
    }

    .qa-item:hover {
      border-color: rgba(124, 58, 237, 0.2);
    }

    .qa-q {
      padding: 16px 24px;
      font-family: var(--font-body);
      font-size: clamp(0.95rem, 1.1vw, 1.15rem);
      color: var(--text-primary);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: var(--transition-fast);
    }

    .qa-q:hover {
      background: var(--bg-glass-hover);
    }

    .qa-q::after {
      content: '+';
      font-size: 1.4rem;
      color: var(--color-primary);
      transition: transform 0.2s;
      font-weight: 300;
    }

    .qa-item.open .qa-q::after {
      content: '\2212';
    }

    .qa-a {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .qa-item.open .qa-a {
      max-height: 500px;
    }

    .qa-a-inner {
      padding: 0 24px 18px;
      font-family: var(--font-body);
      font-size: clamp(0.92rem, 1vw, 1.08rem);
      color: var(--text-secondary);
      line-height: 1.75;
    }

    /* Fullscreen */
    #simArea {
      background: var(--bg-primary);
      position: relative;
    }

    #simArea:fullscreen,
    #simArea:-webkit-full-screen {
      background: var(--bg-primary);
      padding: 16px 24px;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }

    #simArea:fullscreen .sim-main-row,
    #simArea:-webkit-full-screen .sim-main-row {
      flex: 1;
      min-height: 0;
    }

    #simArea:fullscreen .canvas-wrap,
    #simArea:-webkit-full-screen .canvas-wrap {
      flex: 1;
      min-height: 0;
    }

    #simArea:fullscreen .controls-bar,
    #simArea:-webkit-full-screen .controls-bar {
      border-radius: 0;
    }

    @media (max-width: 900px) {
      .sim-main-row { flex-direction: column; }
      .side-data { width: 100%; min-width: unset; }
    }
    @media (max-width: 768px) {
      .sim-wrapper { padding: 70px 12px 24px; }
      .sim-header { flex-direction: column; gap: 12px; align-items: flex-start; }
      .controls-bar { gap: 12px; padding: 12px; }
    }

    /* === Tutorial Overlay === */
    .sim-tutorial {
      position: absolute;
      inset: 0;
      z-index: 50;
      background: rgba(255,255,255,0.08);
      backdrop-filter: blur(0.5px);
      -webkit-backdrop-filter: blur(0.5px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 0.4s ease;
      cursor: pointer;
      border-radius: var(--radius-md);
    }

    .tut-hint {
      position: absolute;
      display: flex;
      align-items: center;
      gap: 8px;
      color: #fff;
      font-size: 0.88rem;
      pointer-events: none;
    }

    .tut-arrows-svg {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }

    .tut-label {
      font-family: var(--font-body);
      background: rgba(255,255,255,0.92);
      color: #1a1a2e;
      padding: 6px 14px;
      border-radius: 20px;
      font-weight: 600;
      font-size: 0.82rem;
      white-space: nowrap;
      box-shadow: 0 2px 8px rgba(0,0,0,0.18);
    }

    .tut-dismiss {
      position: absolute;
      bottom: 38%;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 32px;
      font-family: var(--font-body);
      font-size: 0.95rem;
      font-weight: 700;
      color: #1a1a2e;
      background: #fff;
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      pointer-events: auto;
      box-shadow: 0 4px 16px rgba(124,58,237,0.3);
      transition: background 0.2s, transform 0.2s;
    }

    .tut-dismiss:hover {
      background: #e8e0f8;
      transform: translateX(-50%) scale(1.04);
    }

    @media (max-width: 900px) {
      .sim-tutorial { display: none !important; }
      #helpBtn { display: none; }
    }
  </style>

  <div class="sim-wrapper">
    <div id="simArea">
    <div class="sim-header">
      <h1>Electric Field Lines</h1>
      <div style="display:flex;gap:8px;">
        <button class="sim-btn" id="resetBtn">Reset</button>
        <button class="sim-btn" id="fullscreenBtn">Full Screen</button>
        <button class="sim-btn" id="helpBtn">? Help</button>
      </div>
    </div>

    <div class="sim-main-row">
      <div class="canvas-wrap">
        <canvas id="simCanvas"></canvas>
      </div>
      <div class="side-data">
        <h3>Data</h3>
        <div class="data-grid">
          <div class="data-row"><span class="data-label">Positive</span><span class="data-value" id="posCount">&mdash;</span></div>
          <div class="data-row"><span class="data-label">Negative</span><span class="data-value" id="negCount">&mdash;</span></div>
          <div class="data-row"><span class="data-label">Total</span><span class="data-value" id="totalCount">&mdash;</span></div>
          <div class="data-row"><span class="data-label">Net Charge</span><span class="data-value" id="netCharge">&mdash;</span></div>
        </div>
      </div>
    </div>

    <div class="controls-bar">
      <button class="sim-btn charge-btn active" id="placePosBtn" style="background:rgba(255,45,117,0.18);border-color:rgba(255,45,117,0.4);color:#ff5a92;font-weight:700;">+Q</button>
      <button class="sim-btn charge-btn" id="placeNegBtn" style="background:rgba(0,212,255,0.10);border-color:rgba(0,212,255,0.3);color:#00d4ff;font-weight:700;">&minus;Q</button>
      <button class="sim-btn charge-btn" id="eraserBtn" style="background:rgba(255,170,50,0.12);border-color:rgba(255,170,50,0.3);color:#ffaa32;font-weight:700;">&#9003; Eraser</button>
      <span style="width:1px;height:24px;background:var(--border-subtle);"></span>
      <button class="sim-btn" id="clearBtn">&#8635; Clear All</button>
      <span style="font-size: clamp(0.72rem, 0.85vw, 0.82rem); color: var(--text-muted); margin-left: auto;">Click buttons to add charges &bull; Drag to move</span>
    </div>

    <!-- Tutorial Overlay -->
    <div class="sim-tutorial" id="simTutorial" style="display:none;">
      <svg class="tut-arrows-svg" id="tutArrowsSvg"></svg>

      <div class="tut-hint" id="tutHintPlace">
        <div class="tut-label">Click +Q or &minus;Q to add charges</div>
      </div>
      <div class="tut-hint" id="tutHintDrag">
        <div class="tut-label">Drag charges to reposition them</div>
      </div>
      <div class="tut-hint" id="tutHintClear">
        <div class="tut-label">Clear all charges</div>
      </div>
      <div class="tut-hint" id="tutHintData">
        <div class="tut-label">Live charge data</div>
      </div>

      <button class="tut-dismiss">Got it, let's start!</button>
    </div>

    </div><!-- end #simArea -->

    <div class="equations-section">
      <h3>Key Equations</h3>
      <div class="equations-grid">
        <div class="equation-item">
          <span class="eq-label">Coulomb's Law</span>
          F = kq&#8321;q&#8322;/r&sup2;
        </div>
        <div class="equation-item">
          <span class="eq-label">Electric Field</span>
          E = kq/r&sup2;
        </div>
        <div class="equation-item">
          <span class="eq-label">Coulomb's Constant</span>
          k = 8.99 &times; 10&#8313; N&middot;m&sup2;/C&sup2;
        </div>
        <div class="equation-item">
          <span class="eq-label">Superposition</span>
          E&#8345;&#8337;&#8348; = &Sigma; E&#7522;
        </div>
      </div>
    </div>

    <div class="qa-section">
      <h2>Test Your Understanding</h2>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">What do electric field lines represent?</div>
        <div class="qa-a"><div class="qa-a-inner">
          Electric field lines are imaginary lines drawn to represent the <strong>direction and strength</strong> of the electric field at various points in space. The tangent to a field line at any point gives the direction of the electric field at that point. The density of lines (how close they are together) indicates the field strength &mdash; closer lines mean a stronger field.
        </div></div>
      </div>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">Why do field lines never cross each other?</div>
        <div class="qa-a"><div class="qa-a-inner">
          Field lines never cross because the electric field has a <strong>unique direction</strong> at every point in space. If two lines crossed, it would imply two different field directions at the same point, which is physically impossible. The net field is always a single vector obtained by superposition of all contributing fields.
        </div></div>
      </div>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">How does the field pattern differ between a dipole and two like charges?</div>
        <div class="qa-a"><div class="qa-a-inner">
          For a <strong>dipole</strong> (one positive and one negative charge), field lines start from the positive charge and terminate on the negative charge, forming continuous curves that connect them. For <strong>two like charges</strong> (e.g. both positive), field lines emanate outward from both charges and repel each other &mdash; there is a <strong>null point</strong> between them where the field is zero, and no field lines connect the two charges.
        </div></div>
      </div>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">What happens to the field strength as you move away from a point charge?</div>
        <div class="qa-a"><div class="qa-a-inner">
          The electric field follows an <strong>inverse-square law</strong>: E = kq/r&sup2;. This means the field strength decreases with the square of the distance from the charge. At twice the distance, the field is four times weaker. This is reflected in the field line pattern &mdash; lines spread apart as they move away from the charge, indicating a weaker field.
        </div></div>
      </div>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">How is superposition applied to electric fields?</div>
        <div class="qa-a"><div class="qa-a-inner">
          The <strong>principle of superposition</strong> states that the net electric field at any point is the <strong>vector sum</strong> of the individual fields produced by each charge. Each charge creates its own field independently, and you add the E-field vectors (both magnitude and direction) from all charges to get the resultant field. This is why multiple charges create complex, curved field line patterns.
        </div></div>
      </div>
    </div>
  </div>

  <script>
    // === THEME COLORS ===
    var tc = {};
    function updateThemeColors() {
      var isLight = document.documentElement.getAttribute('data-theme') === 'light';
      tc = {
        bg: isLight ? '#e8eaf0' : '#080818',
        bgCenter: isLight ? '#f0f2f8' : '#0a0a24',
        grid: isLight ? 'rgba(0,120,200,0.06)' : 'rgba(0,212,255,0.04)',
        fieldLine: isLight ? 'rgba(0,150,200,0.45)' : 'rgba(0,212,255,0.4)',
        arrow: isLight ? 'rgba(0,150,200,0.65)' : 'rgba(0,212,255,0.6)',
        statsOverlayBg: isLight ? 'rgba(240,242,248,0.85)' : 'rgba(10,10,30,0.85)',
        statsOverlayBorder: isLight ? 'rgba(0,120,200,0.15)' : 'rgba(0,212,255,0.2)',
        statsText: isLight ? '#0078c8' : '#00d4ff',
        text: isLight ? '#333' : '#fff'
      };
    }
    updateThemeColors();
    new MutationObserver(function() { updateThemeColors(); invalidateField(); draw(); })
      .observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });

    // === CANVAS SETUP ===
    var canvas = document.getElementById('simCanvas');
    var ctx = canvas.getContext('2d');
    var canvasW, canvasH;

    function resizeCanvas() {
      var wrap = canvas.parentElement;
      var isFS = !!document.fullscreenElement;
      var w = wrap.clientWidth;
      var h = isFS ? wrap.clientHeight : Math.max(350, window.innerHeight - 300);
      var dpr = window.devicePixelRatio || 1;

      canvas.width = w * dpr;
      canvas.height = h * dpr;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      canvasW = w;
      canvasH = h;

      draw();
    }

    window.addEventListener('resize', resizeCanvas);

    // === SIMULATION STATE ===
    var k = 500; // Scaled Coulomb constant for visual purposes
    var charges = [];
    var LINES_PER_CHARGE = 16;
    var STEP_SIZE = 3;
    var MAX_STEPS = 800;

    // === CHARGE PLACEMENT â€” click buttons to add charges ===
    var placePosBtn = document.getElementById('placePosBtn');
    var placeNegBtn = document.getElementById('placeNegBtn');

    var MAX_CHARGES = 5;

    function addChargeToCanvas(q) {
      if (charges.length >= MAX_CHARGES) return;
      // Place with good spacing â€” avoid overlapping existing charges
      var MIN_DIST = 150;
      var cx = canvasW / 2, cy = canvasH / 2;
      var x, y, attempts = 0;
      do {
        var spread = 200 + charges.length * 60;
        x = cx + (Math.random() - 0.5) * spread;
        y = cy + (Math.random() - 0.5) * spread;
        var tooClose = false;
        for (var i = 0; i < charges.length; i++) {
          if (Math.hypot(x - charges[i].x, y - charges[i].y) < MIN_DIST) {
            tooClose = true; break;
          }
        }
        attempts++;
      } while (tooClose && attempts < 50);
      charges.push({ x: x, y: y, q: q });
      updateChargeButtons();
      draw();
    }

    function updateChargeButtons() {
      var atLimit = charges.length >= MAX_CHARGES;
      placePosBtn.disabled = atLimit;
      placeNegBtn.disabled = atLimit;
      placePosBtn.style.opacity = atLimit ? '0.35' : '';
      placeNegBtn.style.opacity = atLimit ? '0.35' : '';
    }

    var eraserMode = false;
    var eraserBtn = document.getElementById('eraserBtn');

    placePosBtn.addEventListener('click', function() {
      eraserMode = false;
      eraserBtn.classList.remove('active');
      addChargeToCanvas(1);
    });
    placeNegBtn.addEventListener('click', function() {
      eraserMode = false;
      eraserBtn.classList.remove('active');
      addChargeToCanvas(-1);
    });
    eraserBtn.addEventListener('click', function() {
      eraserMode = !eraserMode;
      eraserBtn.classList.toggle('active', eraserMode);
      canvas.style.cursor = eraserMode ? 'pointer' : 'default';
    });

    // === DRAG & PLACE ===
    var draggingCharge = null;
    var dragStarted = false;
    var GRAB_RADIUS = 18;

    function findChargeAt(mx, my) {
      for (var i = charges.length - 1; i >= 0; i--) {
        var c = charges[i];
        if (Math.hypot(mx - c.x, my - c.y) < GRAB_RADIUS) return i;
      }
      return -1;
    }

    canvas.addEventListener('mousedown', function(e) {
      var rect = canvas.getBoundingClientRect();
      var mx = e.clientX - rect.left;
      var my = e.clientY - rect.top;
      var idx = findChargeAt(mx, my);
      if (idx >= 0) {
        if (eraserMode) {
          charges.splice(idx, 1);
          updateChargeButtons();
          draw();
          return;
        }
        draggingCharge = idx;
        dragStarted = false;
        canvas.style.cursor = 'grabbing';
        e.preventDefault();
      }
    });

    canvas.addEventListener('mousemove', function(e) {
      var rect = canvas.getBoundingClientRect();
      var mx = e.clientX - rect.left;
      var my = e.clientY - rect.top;
      if (draggingCharge !== null) {
        dragStarted = true;
        charges[draggingCharge].x = mx;
        charges[draggingCharge].y = my;
        invalidateField(); // glow loop will pick it up next frame
      } else if (!eraserMode) {
        canvas.style.cursor = findChargeAt(mx, my) >= 0 ? 'grab' : 'default';
      }
    });

    canvas.addEventListener('mouseup', function(e) {
      if (draggingCharge !== null) {
        draggingCharge = null;
        canvas.style.cursor = 'default';
        return;
      }
    });

    canvas.addEventListener('contextmenu', function(e) { e.preventDefault(); });

    // Touch drag support
    var touchDragIdx = null;

    canvas.addEventListener('touchstart', function(e) {
      var touch = e.touches[0];
      var rect = canvas.getBoundingClientRect();
      var mx = touch.clientX - rect.left;
      var my = touch.clientY - rect.top;
      var idx = findChargeAt(mx, my);
      if (idx >= 0) {
        if (eraserMode) {
          charges.splice(idx, 1);
          updateChargeButtons();
          draw();
          e.preventDefault();
          return;
        }
        touchDragIdx = idx;
        e.preventDefault();
      }
    }, { passive: false });

    canvas.addEventListener('touchmove', function(e) {
      if (touchDragIdx !== null) {
        e.preventDefault();
        var touch = e.touches[0];
        var rect = canvas.getBoundingClientRect();
        charges[touchDragIdx].x = touch.clientX - rect.left;
        charges[touchDragIdx].y = touch.clientY - rect.top;
        invalidateField(); // glow loop will pick it up next frame
      }
    }, { passive: false });

    canvas.addEventListener('touchend', function() {
      touchDragIdx = null;
    });

    function clearAll() {
      charges = [];
      updateChargeButtons();
      draw();
    }

    // === PHYSICS ===
    function getField(x, y) {
      var Ex = 0, Ey = 0;
      for (var i = 0; i < charges.length; i++) {
        var c = charges[i];
        var dx = x - c.x;
        var dy = y - c.y;
        var r2 = dx * dx + dy * dy;
        var r = Math.sqrt(r2);
        if (r < 8) return null;
        var E = k * c.q / r2;
        Ex += E * dx / r;
        Ey += E * dy / r;
      }
      return { x: Ex, y: Ey };
    }

    function traceFieldLine(startX, startY, direction) {
      var points = [{ x: startX, y: startY }];
      var x = startX, y = startY;

      for (var i = 0; i < MAX_STEPS; i++) {
        var field = getField(x, y);
        if (!field) break;

        var mag = Math.sqrt(field.x * field.x + field.y * field.y);
        if (mag < 0.001) break;

        var dx = direction * STEP_SIZE * field.x / mag;
        var dy = direction * STEP_SIZE * field.y / mag;
        x += dx;
        y += dy;

        if (x < -20 || x > canvasW + 20 || y < -20 || y > canvasH + 20) break;

        var hitCharge = false;
        for (var j = 0; j < charges.length; j++) {
          var c = charges[j];
          var dist = Math.sqrt((x - c.x) * (x - c.x) + (y - c.y) * (y - c.y));
          if (dist < 12 && c.q * direction < 0) {
            points.push({ x: x, y: y });
            hitCharge = true;
            break;
          }
        }
        if (hitCharge) break;

        points.push({ x: x, y: y });
      }
      return points;
    }

    // === OFFSCREEN CACHE FOR FIELD LINES ===
    var fieldCache = document.createElement('canvas');
    var fieldCtx = fieldCache.getContext('2d');
    var fieldDirty = true; // recompute field lines when true

    function invalidateField() { fieldDirty = true; }

    // === GLOW ANIMATION ===
    var glowPhase = 0;
    var glowRunning = false;
    function glowLoop() {
      if (!glowRunning) return;
      glowPhase += 0.02;
      if (glowPhase > Math.PI * 2) glowPhase -= Math.PI * 2;
      drawFrame();
      requestAnimationFrame(glowLoop);
    }

    function startGlow() {
      if (!glowRunning) { glowRunning = true; requestAnimationFrame(glowLoop); }
    }
    function stopGlow() { glowRunning = false; }

    // === DRAWING ===
    function drawBackground() {
      var grad = ctx.createRadialGradient(canvasW / 2, canvasH / 2, 0, canvasW / 2, canvasH / 2, canvasW * 0.7);
      grad.addColorStop(0, tc.bgCenter);
      grad.addColorStop(1, tc.bg);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvasW, canvasH);

      // Graph paper grid
      var isLight = document.documentElement.getAttribute('data-theme') === 'light';
      var gridColor = isLight ? 'rgba(0,0,0,0.05)' : 'rgba(255,255,255,0.035)';
      ctx.strokeStyle = gridColor;
      ctx.lineWidth = 1;
      for (var x = 40; x < canvasW; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvasH);
        ctx.stroke();
      }
      for (var y = 40; y < canvasH; y += 40) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvasW, y);
        ctx.stroke();
      }
    }

    function updateDataPanel() {
      var pos = 0, neg = 0;
      for (var i = 0; i < charges.length; i++) {
        if (charges[i].q > 0) pos++;
        else neg++;
      }
      document.getElementById('posCount').textContent = pos;
      document.getElementById('negCount').textContent = neg;
      document.getElementById('totalCount').textContent = pos + neg;
      var net = pos - neg;
      var sign = net > 0 ? '+' : (net < 0 ? '\u2212' : '');
      document.getElementById('netCharge').textContent = net === 0 ? '0' : sign + Math.abs(net) + 'Q';
    }

    // Helper: draw a smooth curve through points using quadratic bezier
    function drawSmoothLine(target, points) {
      if (points.length < 2) return;
      target.beginPath();
      target.moveTo(points[0].x, points[0].y);
      if (points.length === 2) {
        target.lineTo(points[1].x, points[1].y);
      } else {
        for (var j = 1; j < points.length - 1; j++) {
          var cpx = (points[j].x + points[j + 1].x) / 2;
          var cpy = (points[j].y + points[j + 1].y) / 2;
          target.quadraticCurveTo(points[j].x, points[j].y, cpx, cpy);
        }
        var last = points[points.length - 1];
        target.lineTo(last.x, last.y);
      }
      target.strokeStyle = tc.fieldLine;
      target.lineWidth = 1.5;
      target.stroke();
    }

    function drawArrowOn(target, x, y, dx, dy, size) {
      var angle = Math.atan2(dy, dx);
      target.save();
      target.translate(x, y);
      target.rotate(angle);
      target.beginPath();
      target.moveTo(size, 0);
      target.lineTo(-size * 0.6, -size * 0.5);
      target.lineTo(-size * 0.6, size * 0.5);
      target.closePath();
      target.fillStyle = tc.arrow;
      target.fill();
      target.restore();
    }

    // Recompute field lines onto offscreen canvas
    function rebuildFieldCache() {
      var dpr = window.devicePixelRatio || 1;
      fieldCache.width = canvasW * dpr;
      fieldCache.height = canvasH * dpr;
      fieldCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
      fieldCtx.clearRect(0, 0, canvasW, canvasH);

      var positiveCharges = [];
      var negativeCharges = [];
      for (var i = 0; i < charges.length; i++) {
        if (charges[i].q > 0) positiveCharges.push(charges[i]);
        else negativeCharges.push(charges[i]);
      }

      // Field lines from positive charges
      for (var ci = 0; ci < positiveCharges.length; ci++) {
        var c = positiveCharges[ci];
        for (var li = 0; li < LINES_PER_CHARGE; li++) {
          var angle = (2 * Math.PI * li) / LINES_PER_CHARGE + Math.PI / LINES_PER_CHARGE;
          var startX = c.x + 14 * Math.cos(angle);
          var startY = c.y + 14 * Math.sin(angle);
          var points = traceFieldLine(startX, startY, 1);
          if (points.length > 1) {
            drawSmoothLine(fieldCtx, points);
            var arrowInterval = Math.floor(points.length / 3);
            for (var a = arrowInterval; a < points.length - 1; a += arrowInterval) {
              drawArrowOn(fieldCtx, points[a].x, points[a].y, points[a+1].x - points[a].x, points[a+1].y - points[a].y, 5);
            }
          }
        }
      }

      // Field lines from negative charges (backward trace)
      for (var ci = 0; ci < negativeCharges.length; ci++) {
        var c = negativeCharges[ci];
        for (var li = 0; li < LINES_PER_CHARGE; li++) {
          var angle = (2 * Math.PI * li) / LINES_PER_CHARGE + Math.PI / LINES_PER_CHARGE;
          var startX = c.x + 14 * Math.cos(angle);
          var startY = c.y + 14 * Math.sin(angle);
          var points = traceFieldLine(startX, startY, -1);
          if (points.length < 2) continue;
          var lastPt = points[points.length - 1];
          var hitsPositive = false;
          for (var pi = 0; pi < positiveCharges.length; pi++) {
            if (Math.hypot(lastPt.x - positiveCharges[pi].x, lastPt.y - positiveCharges[pi].y) < 20) {
              hitsPositive = true; break;
            }
          }
          if (hitsPositive) continue;
          drawSmoothLine(fieldCtx, points);
          var arrowInterval = Math.floor(points.length / 3);
          for (var a = arrowInterval; a < points.length - 1; a += arrowInterval) {
            drawArrowOn(fieldCtx, points[a].x, points[a].y, points[a].x - points[a+1].x, points[a].y - points[a+1].y, 5);
          }
        }
      }

      fieldDirty = false;
    }

    // Called when charges change (add/remove/move/clear)
    function draw() {
      invalidateField();
      drawFrame();
      if (charges.length > 0) { startGlow(); } else { stopGlow(); }
    }

    // Fast composite frame â€” called every animation tick
    function drawFrame() {
      drawBackground();
      updateDataPanel();

      // Rebuild field cache only when charges changed
      if (fieldDirty) rebuildFieldCache();

      // Stamp cached field lines
      if (charges.length > 0) {
        ctx.drawImage(fieldCache, 0, 0, canvasW, canvasH);
      }

      // Draw charges with pulsing glow (cheap â€” just circles)
      var pulse = 0.5 + 0.5 * Math.sin(glowPhase);
      var positiveCharges = [];
      var negativeCharges = [];
      for (var i = 0; i < charges.length; i++) {
        if (charges[i].q > 0) positiveCharges.push(charges[i]);
        else negativeCharges.push(charges[i]);
      }

      for (var i = 0; i < charges.length; i++) {
        var c = charges[i];
        var glowRadius = 28 + 10 * pulse;
        var glowAlpha = 0.2 + 0.15 * pulse;

        var glowGrad = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, glowRadius);
        if (c.q > 0) {
          glowGrad.addColorStop(0, 'rgba(255,45,117,' + glowAlpha + ')');
          glowGrad.addColorStop(0.6, 'rgba(255,45,117,' + (glowAlpha * 0.4) + ')');
          glowGrad.addColorStop(1, 'rgba(255,45,117,0)');
        } else {
          glowGrad.addColorStop(0, 'rgba(0,212,255,' + glowAlpha + ')');
          glowGrad.addColorStop(0.6, 'rgba(0,212,255,' + (glowAlpha * 0.4) + ')');
          glowGrad.addColorStop(1, 'rgba(0,212,255,0)');
        }
        ctx.beginPath();
        ctx.arc(c.x, c.y, glowRadius, 0, Math.PI * 2);
        ctx.fillStyle = glowGrad;
        ctx.fill();

        ctx.beginPath();
        ctx.arc(c.x, c.y, 12, 0, Math.PI * 2);
        var grad = ctx.createRadialGradient(c.x - 3, c.y - 3, 0, c.x, c.y, 12);
        if (c.q > 0) {
          grad.addColorStop(0, '#ff5a92');
          grad.addColorStop(1, '#ff2d75');
        } else {
          grad.addColorStop(0, '#33e0ff');
          grad.addColorStop(1, '#00d4ff');
        }
        ctx.fillStyle = grad;
        ctx.shadowColor = c.q > 0 ? '#ff2d75' : '#00d4ff';
        ctx.shadowBlur = 12 + 6 * pulse;
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px "JetBrains Mono", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(c.q > 0 ? '+' : '\u2212', c.x, c.y);
      }

      // Dipole label
      if (positiveCharges.length === 1 && negativeCharges.length === 1) {
        var pc = positiveCharges[0], nc = negativeCharges[0];
        var midX = (pc.x + nc.x) / 2;
        var midY = (pc.y + nc.y) / 2;
        var isLight = document.documentElement.getAttribute('data-theme') === 'light';

        ctx.save();
        var labelText = 'Dipole';
        ctx.font = 'bold 13px "Inter", sans-serif';
        var tw = ctx.measureText(labelText).width;
        var pillW = tw + 20;
        var pillH = 26;
        var pillX = midX - pillW / 2;
        var pillY = midY - 28 - pillH;

        ctx.fillStyle = isLight ? 'rgba(255,255,255,0.88)' : 'rgba(10,10,30,0.88)';
        ctx.beginPath();
        ctx.roundRect(pillX, pillY, pillW, pillH, 13);
        ctx.fill();
        ctx.strokeStyle = 'rgba(124,58,237,0.35)';
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.fillStyle = isLight ? '#7c3aed' : '#a78bfa';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(labelText, midX, pillY + pillH / 2);
        ctx.restore();
      }
    }

    // === CONTROLS ===
    document.getElementById('clearBtn').addEventListener('click', clearAll);

    document.getElementById('resetBtn').addEventListener('click', function() {
      clearAll();
    });

    // Fullscreen
    document.getElementById('fullscreenBtn').addEventListener('click', function() {
      var el = document.getElementById('simArea');
      if (!document.fullscreenElement) {
        (el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen).call(el);
      } else {
        (document.exitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen).call(document);
      }
    });

    document.addEventListener('fullscreenchange', function() {
      setTimeout(resizeCanvas, 100);
      setTimeout(resizeCanvas, 300);
    });

    // === TUTORIAL OVERLAY ===
    function drawCurvedArrow(svg, x1, y1, x2, y2) {
      var ns = 'http://www.w3.org/2000/svg';
      var dx = x2 - x1;
      var dy = y2 - y1;
      var cx1 = x1 + dx * 0.2;
      var cy1 = y1 + dy * 0.6;
      var cx2 = x1 + dx * 0.8;
      var cy2 = y1 + dy * 0.4;

      var path = document.createElementNS(ns, 'path');
      path.setAttribute('d',
        'M' + x1 + ',' + y1 +
        ' C' + cx1 + ',' + cy1 +
        ' ' + cx2 + ',' + cy2 +
        ' ' + x2 + ',' + y2
      );
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke', 'rgba(255,255,255,0.85)');
      path.setAttribute('stroke-width', '2');
      path.setAttribute('stroke-linecap', 'round');
      svg.appendChild(path);

      var angle = Math.atan2(y2 - cy2, x2 - cx2);
      var headLen = 10;
      var a1x = x2 - headLen * Math.cos(angle - 0.4);
      var a1y = y2 - headLen * Math.sin(angle - 0.4);
      var a2x = x2 - headLen * Math.cos(angle + 0.4);
      var a2y = y2 - headLen * Math.sin(angle + 0.4);
      var arrow = document.createElementNS(ns, 'polygon');
      arrow.setAttribute('points',
        x2 + ',' + y2 + ' ' +
        a1x + ',' + a1y + ' ' +
        a2x + ',' + a2y
      );
      arrow.setAttribute('fill', 'rgba(255,255,255,0.85)');
      svg.appendChild(arrow);
    }

    function positionTutorialHints() {
      var area = document.getElementById('simArea');
      var areaRect = area.getBoundingClientRect();
      var svg = document.getElementById('tutArrowsSvg');
      svg.innerHTML = '';

      var targets = [
        { hint: 'tutHintPlace',  el: document.getElementById('placePosBtn'), type: 'bottom' },
        { hint: 'tutHintDrag',   el: document.getElementById('simCanvas'),   type: 'canvas' },
        { hint: 'tutHintClear',  el: document.getElementById('clearBtn'),    type: 'bottom' },
        { hint: 'tutHintData',   el: document.querySelector('.side-data'),    type: 'side'   }
      ];

      var placed = [];

      for (var i = 0; i < targets.length; i++) {
        var t = targets[i];
        var hintEl = document.getElementById(t.hint);
        if (!t.el) continue;
        var elRect = t.el.getBoundingClientRect();
        var cx = elRect.left + elRect.width / 2 - areaRect.left;
        var cy = elRect.top - areaRect.top;

        if (t.type === 'canvas') {
          var midX = elRect.left + elRect.width / 2 - areaRect.left;
          var midY = elRect.top + elRect.height * 0.35 - areaRect.top;
          hintEl.style.left = midX + 'px';
          hintEl.style.top = midY + 'px';
          hintEl.style.transform = 'translateX(-50%)';
          hintEl.style.right = '';
          continue;
        }

        if (t.type === 'side') {
          var midY = elRect.top + elRect.height / 2 - areaRect.top;
          hintEl.style.top = midY + 'px';
          hintEl.style.right = (areaRect.right - elRect.left + 8) + 'px';
          hintEl.style.left = '';
          hintEl.style.transform = '';

          var hRect = hintEl.getBoundingClientRect();
          var arrowStartX = hRect.right - areaRect.left + 4;
          var arrowStartY = hRect.top + hRect.height / 2 - areaRect.top;
          var arrowEndX = elRect.left - areaRect.left - 2;
          var arrowEndY = midY;
          drawCurvedArrow(svg, arrowStartX, arrowStartY, arrowEndX, arrowEndY);
          continue;
        }

        hintEl.style.left = cx + 'px';
        hintEl.style.transform = 'translateX(-50%)';
        hintEl.style.top = '0px';

        var hintRect = hintEl.getBoundingClientRect();
        var hintW = hintRect.width;
        var hintH = hintRect.height;

        var desiredTop = cy - 50;
        var hintLeft = cx - hintW / 2;
        var hintRight = hintLeft + hintW;

        var finalTop = desiredTop;
        for (var j = 0; j < placed.length; j++) {
          var p = placed[j];
          if (hintRight > p.left && hintLeft < p.right) {
            if (finalTop + hintH > p.top && finalTop < p.bottom) {
              finalTop = p.top - hintH - 8;
            }
          }
        }

        hintEl.style.top = finalTop + 'px';
        placed.push({
          left: hintLeft,
          right: hintRight,
          top: finalTop,
          bottom: finalTop + hintH
        });

        var arrowStartX = cx;
        var arrowStartY = finalTop + hintH + 2;
        var arrowEndX = cx;
        var arrowEndY = cy + 2;
        drawCurvedArrow(svg, arrowStartX, arrowStartY, arrowEndX, arrowEndY);
      }
    }

    function showTutorial() {
      var el = document.getElementById('simTutorial');
      el.style.display = '';
      el.offsetHeight;
      el.style.opacity = '1';
      positionTutorialHints();
    }

    window.addEventListener('resize', function() {
      if (document.getElementById('simTutorial').style.display !== 'none') {
        positionTutorialHints();
      }
    });

    function dismissTutorial() {
      var el = document.getElementById('simTutorial');
      el.style.opacity = '0';
      setTimeout(function() { el.style.display = 'none'; }, 400);
      localStorage.setItem('tut-electrostatics', '1');
    }

    // Auto-show on first visit
    if (!localStorage.getItem('tut-electrostatics')) {
      showTutorial();
    }

    // Dismiss on click anywhere on overlay
    document.getElementById('simTutorial').addEventListener('click', dismissTutorial);

    // Help button re-shows overlay
    document.getElementById('helpBtn').addEventListener('click', showTutorial);

    // === INIT ===
    resizeCanvas();
  </script>
  <script src="../js/main.js"></script>
</body>
</html>
