<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gauss's Law | Axomiya Engineer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;500;600;700&family=Delius&family=Nova+Square&family=Orbitron:wght@400;500;600;700;800;900&family=Inter:wght@300;400;500;600;700&family=Andika:wght@400;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/achievements.css">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ”¬</text></svg>">
  <script src="../js/theme.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
  <script defer src="../js/firebase-config.js"></script>
  <script defer src="../js/auth.js"></script>
  <script defer src="../js/sim-tracker.js"></script>
  <script defer src="../js/achievements-config.js"></script>
  <script defer src="../js/achievements.js"></script>
</head>
<body>
  <!-- Splash Screen -->
  <div class="splash-screen" id="splash"><div class="splash-pendulum"><div class="sp-mount"></div><div class="sp-pivot"></div><div class="sp-arm"><div class="sp-rod"></div><div class="sp-bob"><div class="sp-glow"></div></div></div></div><div class="splash-logo">Axomiya Engineer</div><div class="splash-tagline">Lets Make Physics Fun</div></div>
<div class="bg-grid"></div>
  <nav class="navbar scrolled">
    <div class="nav-container">
      <a href="../index.html" class="nav-logo" id="nav-logo">
        <div class="logo-icon"><div class="logo-pendulum"><div class="pendulum-mount"></div><div class="pendulum-pivot"></div><div class="pendulum-arm"><div class="pendulum-rod"></div><div class="pendulum-bob"><div class="bob-glow"></div></div></div></div></div>
        <div class="logo-text"><span class="brand-name">Axomiya Engineer</span><span class="brand-tag">LETS MAKE PHYSICS FUN</span></div>
      </a>
      <div class="nav-links">
        <div class="nav-item"><a href="../index.html" class="nav-link">Home</a></div>
        <div class="nav-item"><a href="../about.html" class="nav-link">About Me</a></div>
        <div class="nav-item"><a href="../chapters.html" class="nav-link">Chapters</a></div>
        <div class="nav-item"><a href="../simulations.html" class="nav-link active">Simulations</a></div>
        <div class="nav-item"><a href="../tests.html" class="nav-link">Tests</a></div>
        <div class="nav-item"><a href="../flashcards.html" class="nav-link">Flashcards</a></div>
        <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme"></button>
        <button class="auth-btn" id="auth-login-btn"><svg class="google-icon" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92a5.06 5.06 0 0 1-2.2 3.32v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.1z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>Sign in</button>
        <div class="user-menu nav-item" id="auth-user-menu" style="display:none;"><img class="user-avatar" id="auth-user-avatar" src="" alt="User"><span class="user-name" id="auth-user-name"></span><div class="dropdown"><a href="../progress.html"><div class="dd-icon">&#128200;</div> My Progress</a><div class="dropdown-divider"></div><a href="#" id="auth-logout-btn"><div class="dd-icon">&#128682;</div> Sign Out</a></div></div>
        <a href="../index.html#contact" class="nav-cta">Contact Me</a>
      </div>
      <button class="nav-toggle" aria-label="Menu"><span></span><span></span><span></span></button>
    </div>
  </nav>
  <script>
    (function(){
      var s=document.getElementById('splash');
      if(sessionStorage.getItem('ae-splash')){s.style.display='none';}
      else{
        sessionStorage.setItem('ae-splash','1');setTimeout(function(){s.classList.add('fade-out');},2200);setTimeout(function(){s.style.display='none';},2700);
      }
    })();
  </script>

  <style>
    .bg-grid, #particles-canvas { display: none !important; }

    .sim-wrapper {
      max-width: 1400px;
      margin: 0 auto;
      padding: 80px 24px 40px;
    }

    .sim-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }

    .sim-header h1 {
      font-family: var(--font-display);
      font-size: clamp(1.4rem, 2vw, 1.8rem);
      font-weight: 700;
      color: var(--text-primary);
      letter-spacing: 0.5px;
    }

    .sim-btn {
      padding: 8px 20px;
      font-size: 0.85rem;
      font-weight: 600;
      font-family: var(--font-body);
      color: var(--text-secondary);
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: var(--transition-fast);
    }

    .sim-btn:hover {
      color: var(--text-primary);
      border-color: rgba(124, 58, 237, 0.3);
      background: rgba(124, 58, 237, 0.08);
    }

    .sim-btn.primary {
      background: rgba(124, 58, 237, 0.15);
      color: var(--text-primary);
      border-color: rgba(124, 58, 237, 0.3);
    }

    .sim-btn.primary:hover {
      background: rgba(124, 58, 237, 0.25);
    }

    .sim-btn.active {
      background: rgba(124, 58, 237, 0.18);
      color: var(--text-primary);
      border-color: rgba(124, 58, 237, 0.4);
      box-shadow: 0 0 10px rgba(124,58,237,0.25);
      transform: scale(1.06);
    }

    .sim-main-row {
      display: flex;
      gap: 1px;
      background: var(--border-subtle);
      border-radius: var(--radius-md) var(--radius-md) 0 0;
      overflow: hidden;
    }

    .canvas-wrap {
      flex: 1;
      overflow: hidden;
      background: var(--bg-secondary);
    }

    .canvas-wrap canvas {
      display: block;
      width: 100%;
    }

    /* Side Data Panel */
    .side-data {
      width: 320px;
      min-width: 280px;
      background: var(--bg-card);
      padding: 14px;
      display: flex;
      flex-direction: column;
    }

    .side-data h3 {
      font-family: var(--font-display);
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }

    .data-grid {
      display: flex;
      flex-direction: column;
    }

    .data-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 0;
      border-bottom: 1px solid var(--border-subtle);
    }

    .data-row:last-child {
      border-bottom: none;
    }

    .data-label {
      font-family: var(--font-body);
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .data-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      color: var(--text-primary);
      font-weight: 600;
      text-align: right;
    }

    .data-value.flux-val { color: #ffcc00; }

    .data-formula {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.72rem;
      color: var(--text-secondary);
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      padding: 6px 8px;
      margin-top: 8px;
      line-height: 1.5;
      word-break: break-all;
    }

    .data-formula .hl {
      color: #ffcc00;
      font-weight: 700;
    }

    .plot-label {
      font-family: var(--font-display);
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text-muted);
      margin-top: 10px;
      margin-bottom: 4px;
    }

    .plot-wrap {
      flex: 1;
      min-height: 120px;
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      overflow: hidden;
      background: var(--bg-secondary);
      display: flex;
    }

    .plot-wrap canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Controls */
    .controls-bar {
      display: flex;
      align-items: center;
      gap: clamp(10px, 2.5vw, 24px);
      padding: 18px 24px;
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      border-top: none;
      border-radius: 0 0 var(--radius-md) var(--radius-md);
      flex-wrap: wrap;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .control-group label {
      font-family: var(--font-body);
      font-size: clamp(0.8rem, 0.95vw, 0.95rem);
      color: var(--text-muted);
      white-space: nowrap;
    }

    .control-sep {
      width: 1px;
      height: 24px;
      background: var(--border-subtle);
    }

    .slider-val {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.82rem;
      font-weight: 600;
      color: var(--text-primary);
      min-width: 48px;
    }

    .num-input {
      width: 58px;
      padding: 4px 6px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.82rem;
      font-weight: 600;
      color: var(--text-primary);
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      text-align: center;
      outline: none;
      transition: var(--transition-fast);
    }

    .num-input:focus {
      border-color: rgba(124, 58, 237, 0.5);
      box-shadow: 0 0 0 2px rgba(124, 58, 237, 0.15);
    }

    .sign-btn {
      min-width: 32px;
      height: 30px;
      padding: 4px 8px;
      font-size: 0.85rem;
      font-weight: 700;
      font-family: 'JetBrains Mono', monospace;
      border-radius: var(--radius-sm);
      border: 1px solid;
      cursor: pointer;
      transition: var(--transition-fast);
    }

    .sign-btn.pos {
      background: rgba(255,45,117,0.18);
      border-color: rgba(255,45,117,0.4);
      color: #ff5a92;
    }

    .sign-btn.neg {
      background: rgba(0,212,255,0.10);
      border-color: rgba(0,212,255,0.3);
      color: #00d4ff;
    }

    .sign-btn:hover {
      transform: scale(1.08);
    }

    /* Equations */
    .equations-section {
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-md);
      padding: 20px 24px;
      margin-top: 16px;
    }

    .equations-section h3 {
      font-family: var(--font-display);
      font-size: clamp(0.8rem, 1vw, 1rem);
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 14px;
    }

    .equations-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 12px 32px;
    }

    .equation-item {
      font-family: var(--font-body);
      font-size: clamp(1rem, 1.2vw, 1.2rem);
      color: var(--text-primary);
      padding: 8px 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      white-space: nowrap;
    }

    .equation-item .eq-label {
      color: var(--text-muted);
      font-size: clamp(0.8rem, 0.9vw, 0.9rem);
      display: block;
      margin-bottom: 2px;
    }

    /* Q&A */
    .qa-section {
      margin-top: 32px;
    }

    .qa-section h2 {
      font-family: var(--font-display);
      font-size: clamp(0.9rem, 1.1vw, 1.1rem);
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 16px;
    }

    .qa-item {
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-md);
      margin-bottom: 8px;
      overflow: hidden;
      transition: var(--transition-fast);
    }

    .qa-item:hover {
      border-color: rgba(124, 58, 237, 0.2);
    }

    .qa-q {
      padding: 16px 24px;
      font-family: var(--font-body);
      font-size: clamp(0.95rem, 1.1vw, 1.15rem);
      color: var(--text-primary);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: var(--transition-fast);
    }

    .qa-q:hover {
      background: var(--bg-glass-hover);
    }

    .qa-q::after {
      content: '+';
      font-size: 1.4rem;
      color: var(--color-primary);
      transition: transform 0.2s;
      font-weight: 300;
    }

    .qa-item.open .qa-q::after {
      content: '\2212';
    }

    .qa-a {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .qa-item.open .qa-a {
      max-height: 500px;
    }

    .qa-a-inner {
      padding: 0 24px 18px;
      font-family: var(--font-body);
      font-size: clamp(0.92rem, 1vw, 1.08rem);
      color: var(--text-secondary);
      line-height: 1.75;
    }

    /* Fullscreen */
    #simArea {
      background: var(--bg-primary);
      position: relative;
    }

    #simArea:fullscreen,
    #simArea:-webkit-full-screen {
      background: var(--bg-primary);
      padding: 16px 24px;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }

    #simArea:fullscreen .sim-main-row,
    #simArea:-webkit-full-screen .sim-main-row {
      flex: 1;
      min-height: 0;
    }

    #simArea:fullscreen .canvas-wrap,
    #simArea:-webkit-full-screen .canvas-wrap {
      flex: 1;
      min-height: 0;
    }

    #simArea:fullscreen .controls-bar,
    #simArea:-webkit-full-screen .controls-bar {
      border-radius: 0;
    }

    @media (max-width: 900px) {
      .sim-main-row { flex-direction: column; }
      .side-data { width: 100%; min-width: unset; }
    }

    @media (max-width: 768px) {
      .sim-wrapper { padding: 70px 12px 24px; }
      .sim-header { flex-direction: column; gap: 12px; align-items: flex-start; }
      .controls-bar { gap: 8px; padding: 12px; }
    }

    /* === Tutorial Overlay === */
    .sim-tutorial {
      position: absolute;
      inset: 0;
      z-index: 50;
      background: rgba(255,255,255,0.08);
      backdrop-filter: blur(0.5px);
      -webkit-backdrop-filter: blur(0.5px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 0.4s ease;
      cursor: pointer;
      border-radius: var(--radius-md);
    }

    .tut-hint {
      position: absolute;
      display: flex;
      align-items: center;
      gap: 8px;
      color: #fff;
      font-size: 0.88rem;
      pointer-events: none;
    }

    .tut-arrows-svg {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }

    .tut-label {
      font-family: var(--font-body);
      background: rgba(255,255,255,0.92);
      color: #1a1a2e;
      padding: 6px 14px;
      border-radius: 20px;
      font-weight: 600;
      font-size: 0.82rem;
      white-space: nowrap;
      box-shadow: 0 2px 8px rgba(0,0,0,0.18);
    }

    .tut-dismiss {
      position: absolute;
      bottom: 38%;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 32px;
      font-family: var(--font-body);
      font-size: 0.95rem;
      font-weight: 700;
      color: #1a1a2e;
      background: #fff;
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      pointer-events: auto;
      box-shadow: 0 4px 16px rgba(124,58,237,0.3);
      transition: background 0.2s, transform 0.2s;
    }

    .tut-dismiss:hover {
      background: #e8e0f8;
      transform: translateX(-50%) scale(1.04);
    }

    @media (max-width: 900px) {
      .sim-tutorial { display: none !important; }
      #helpBtn { display: none; }
    }

    .mode-btn-group {
      display: flex;
      gap: 4px;
    }

    .explain-text {
      font-family: var(--font-body);
      font-size: 0.75rem;
      color: var(--text-secondary);
      line-height: 1.5;
      margin-top: 8px;
      padding: 8px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
    }
  </style>

  <div class="sim-wrapper">
    <div id="simArea">
    <div class="sim-header">
      <h1>Gauss's Law</h1>
      <div style="display:flex;gap:8px;">
        <div class="mode-btn-group">
          <button class="sim-btn active" id="modeCenterBtn">Center</button>
          <button class="sim-btn" id="modeCornerBtn">Corner</button>
          <button class="sim-btn" id="modeEdgeBtn">Edge</button>
        </div>
        <button class="sim-btn" id="resetBtn">Reset</button>
        <button class="sim-btn" id="fullscreenBtn">Full Screen</button>
        <button class="sim-btn" id="helpBtn">? Help</button>
      </div>
    </div>

    <div class="sim-main-row">
      <div class="canvas-wrap">
        <canvas id="simCanvas"></canvas>
      </div>
      <div class="side-data">
        <h3>Data</h3>
        <div class="data-grid">
          <div class="data-row">
            <span class="data-label">&Phi;<sub>total</sub></span>
            <span class="data-value flux-val" id="dataFluxTotal">&mdash;</span>
          </div>
          <div class="data-row">
            <span class="data-label">&Phi;<sub>face</sub></span>
            <span class="data-value" id="dataFluxFace">&mdash;</span>
          </div>
          <div class="data-row">
            <span class="data-label">Q</span>
            <span class="data-value" id="dataCharge">&mdash;</span>
          </div>
          <div class="data-row">
            <span class="data-label">Mode</span>
            <span class="data-value" id="dataMode">&mdash;</span>
          </div>
        </div>
        <div class="data-formula" id="dataSubstitution">&mdash;</div>
        <div class="explain-text" id="explainText"></div>
        <div class="plot-label">&Phi; vs Q</div>
        <div class="plot-wrap">
          <canvas id="plotCanvas"></canvas>
        </div>
      </div>
    </div>

    <div class="controls-bar">
      <div class="control-group" id="chargeCtrl">
        <button class="sign-btn pos" id="signBtn">+</button>
        <label>Q:</label>
        <input type="range" id="chargeSlider" min="1" max="10" step="1" value="5">
        <input type="number" class="num-input" id="chargeInput" min="1" max="10" step="1" value="5">
        <span class="slider-val">&micro;C</span>
      </div>
      <div class="control-sep"></div>
      <div class="control-group">
        <label>
          <input type="checkbox" id="ghostCheck"> Show Ghost Cubes
        </label>
      </div>
      <div class="control-sep"></div>
      <button class="sim-btn" id="resetArrangement">&#8635; Reset</button>
    </div>

    <!-- Tutorial Overlay -->
    <div class="sim-tutorial" id="simTutorial" style="display:none;">
      <svg class="tut-arrows-svg" id="tutArrowsSvg"></svg>
      <div class="tut-hint" id="tutHintMode">
        <div class="tut-label">Switch between Center, Corner, and Edge modes</div>
      </div>
      <div class="tut-hint" id="tutHintCanvas">
        <div class="tut-label">Drag to rotate the 3D cube</div>
      </div>
      <div class="tut-hint" id="tutHintData">
        <div class="tut-label">Watch how flux changes with charge position</div>
      </div>
      <button class="tut-dismiss">Got it, let's start!</button>
    </div>

    </div><!-- end #simArea -->

    <div class="equations-section">
      <h3>Key Equations</h3>
      <div class="equations-grid">
        <div class="equation-item">
          <span class="eq-label">Gauss's Law</span>
          &Phi; = Q<sub>enc</sub> / &epsilon;&#8320;
        </div>
        <div class="equation-item">
          <span class="eq-label">Center of Cube</span>
          &Phi;<sub>face</sub> = Q / 6&epsilon;&#8320;
        </div>
        <div class="equation-item">
          <span class="eq-label">Corner of Cube</span>
          &Phi;<sub>total</sub> = Q / 8&epsilon;&#8320;
        </div>
        <div class="equation-item">
          <span class="eq-label">Edge of Cube</span>
          &Phi;<sub>total</sub> = Q / 4&epsilon;&#8320;
        </div>
        <div class="equation-item">
          <span class="eq-label">Coulomb Constant</span>
          k = 1/4&pi;&epsilon;&#8320; = 9 &times; 10&sup9; N&middot;m&sup2;/C&sup2;
        </div>
      </div>
    </div>

    <div class="qa-section">
      <h2>Test Your Understanding</h2>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">What is Gauss's Law?</div>
        <div class="qa-a"><div class="qa-a-inner">
          Gauss's Law states that the total electric flux through any closed surface equals the net enclosed charge divided by &epsilon;&#8320;: &Phi; = Q<sub>enc</sub>/&epsilon;&#8320;. It is one of Maxwell's four equations and is especially powerful for calculating electric fields of symmetric charge distributions. The flux depends only on the enclosed charge, not on the shape or size of the surface.
        </div></div>
      </div>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">Why is the flux through each face equal when the charge is at the center?</div>
        <div class="qa-a"><div class="qa-a-inner">
          When the charge is at the exact center of the cube, every face is equidistant from the charge and subtends the same solid angle. By symmetry, the total flux Q/&epsilon;&#8320; divides equally among 6 faces, giving Q/6&epsilon;&#8320; per face. This beautiful symmetry argument requires no integration.
        </div></div>
      </div>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">Why do you need 8 cubes when the charge is at a corner?</div>
        <div class="qa-a"><div class="qa-a-inner">
          A corner of a cube is shared by exactly 8 cubes that can tile together to completely surround the charge. By Gauss's Law, the total flux through all 8 cubes combined is Q/&epsilon;&#8320;. Since each cube is identical by symmetry, each receives Q/8&epsilon;&#8320; of the total flux. Only 3 faces of the original cube are "exposed" to the charge at the corner.
        </div></div>
      </div>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">How does Gauss's Law relate to Coulomb's Law?</div>
        <div class="qa-a"><div class="qa-a-inner">
          They are equivalent! Applying Gauss's Law to a spherical Gaussian surface of radius r around a point charge Q gives &Phi; = E&middot;4&pi;r&sup2; = Q/&epsilon;&#8320;, which yields E = Q/(4&pi;&epsilon;&#8320;r&sup2;) = kQ/r&sup2; &mdash; exactly Coulomb's Law. Gauss's Law is the integral form while Coulomb's Law gives the field at a point.
        </div></div>
      </div>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">Does the shape of the Gaussian surface matter?</div>
        <div class="qa-a"><div class="qa-a-inner">
          The total flux through any closed surface depends only on the enclosed charge (&Phi; = Q<sub>enc</sub>/&epsilon;&#8320;), regardless of shape. However, to easily calculate E from flux, you want a surface where E is constant and perpendicular &mdash; that is why we choose spheres for point charges, cylinders for line charges, and boxes for sheet charges. The cube is used here for pedagogical clarity.
        </div></div>
      </div>
    </div>
  </div>

  <script>
    // === THEME COLORS ===
    var tc = {};
    function updateThemeColors() {
      var isLight = document.documentElement.getAttribute('data-theme') === 'light';
      tc = {
        bg: isLight ? '#e8eaf0' : '#080818',
        bgCenter: isLight ? '#f0f2f8' : '#0a0a24',
        grid: isLight ? 'rgba(0,120,200,0.06)' : 'rgba(0,212,255,0.04)',
        text: isLight ? '#333' : '#fff',
        labelBg: isLight ? 'rgba(255,255,255,0.88)' : 'rgba(10,10,30,0.88)',
        labelBorder: isLight ? 'rgba(124,58,237,0.35)' : 'rgba(124,58,237,0.35)',
        labelText: isLight ? '#7c3aed' : '#a78bfa'
      };
    }
    updateThemeColors();
    new MutationObserver(function() { updateThemeColors(); drawFrame(); })
      .observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });

    // === CANVAS SETUP ===
    var canvas = document.getElementById('simCanvas');
    var ctx = canvas.getContext('2d');
    var canvasW, canvasH;

    function resizeCanvas() {
      var wrap = canvas.parentElement;
      var isFS = !!document.fullscreenElement;
      var w = wrap.clientWidth;
      var h = isFS ? wrap.clientHeight : Math.max(350, window.innerHeight - 300);
      var dpr = window.devicePixelRatio || 1;

      canvas.width = w * dpr;
      canvas.height = h * dpr;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      canvasW = w;
      canvasH = h;
    }

    window.addEventListener('resize', function() {
      resizeCanvas();
      resizePlotCanvas();
    });

    // === STATE VARIABLES ===
    var CHARGE_MAG = 5;
    var CHARGE_SIGN = 1;
    var MODE = 'center';
    var CUBE_SIZE = 120;
    var NUM_FIELD_LINES = 32;
    var EPSILON_0 = 8.854e-12;

    var rotX = -0.45;
    var rotY = 0.65;
    var dragging = false;
    var lastMouseX = 0, lastMouseY = 0;
    var rotVelX = 0, rotVelY = 0;

    var showGhosts = false;
    var ghostProgress = 0;
    var ghostAnimating = false;
    var chargeAnimT = 1;
    var chargeFrom = [0, 0, 0];
    var chargeTo = [0, 0, 0];

    var glowPhase = 0;
    var flowPhase = 0;

    var _achGaussCenter = false;
    var _achGaussCorner = false;
    var _achGaussEdge = false;
    var modeTimers = { center: 0, corner: 0, edge: 0 };

    // === HELPERS ===
    function roundedRect(ctx, x, y, w, h, r) {
      if (r > w / 2) r = w / 2;
      if (r > h / 2) r = h / 2;
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.arcTo(x + w, y, x + w, y + r, r);
      ctx.lineTo(x + w, y + h - r);
      ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
      ctx.lineTo(x + r, y + h);
      ctx.arcTo(x, y + h, x, y + h - r, r);
      ctx.lineTo(x, y + r);
      ctx.arcTo(x, y, x + r, y, r);
      ctx.closePath();
    }

    function formatSci(val) {
      if (val === 0) return '0';
      var sign = val < 0 ? '-' : '';
      var abs = Math.abs(val);
      var exp = Math.floor(Math.log10(abs));
      var mantissa = abs / Math.pow(10, exp);
      return sign + mantissa.toFixed(2) + '\u00D710' + superscript(exp);
    }

    function superscript(n) {
      var sup = {'0':'\u2070','1':'\u00B9','2':'\u00B2','3':'\u00B3','4':'\u2074',
                 '5':'\u2075','6':'\u2076','7':'\u2077','8':'\u2078','9':'\u2079','-':'\u207B'};
      var s = String(n), result = '';
      for (var i = 0; i < s.length; i++) result += sup[s[i]] || s[i];
      return result;
    }

    function easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    // === 3D ENGINE ===
    function rotatePoint(p, rx, ry) {
      var cosX = Math.cos(rx), sinX = Math.sin(rx);
      var y1 = p[1] * cosX - p[2] * sinX;
      var z1 = p[1] * sinX + p[2] * cosX;
      var cosY = Math.cos(ry), sinY = Math.sin(ry);
      var x2 = p[0] * cosY + z1 * sinY;
      var z2 = -p[0] * sinY + z1 * cosY;
      return [x2, y1, z2];
    }

    var FOV = 500;

    function project(p) {
      var scale = FOV / (FOV + p[2]);
      return {
        x: canvasW / 2 + p[0] * scale,
        y: canvasH / 2 + p[1] * scale,
        scale: scale,
        z: p[2]
      };
    }

    function getCubeVertices(s) {
      return [
        [-s, -s, -s], [s, -s, -s], [s, s, -s], [-s, s, -s],
        [-s, -s,  s], [s, -s,  s], [s, s,  s], [-s, s,  s]
      ];
    }

    var FACES = [
      { verts: [0,1,2,3], color: 'rgba(124,58,237,0.12)', label: 'Back' },
      { verts: [4,5,6,7], color: 'rgba(124,58,237,0.12)', label: 'Front' },
      { verts: [0,1,5,4], color: 'rgba(0,200,150,0.12)',  label: 'Top' },
      { verts: [2,3,7,6], color: 'rgba(0,200,150,0.12)',  label: 'Bottom' },
      { verts: [0,3,7,4], color: 'rgba(50,130,255,0.12)', label: 'Left' },
      { verts: [1,2,6,5], color: 'rgba(50,130,255,0.12)', label: 'Right' }
    ];

    // === CHARGE POSITION ===
    function getChargePos3D(mode) {
      var s = CUBE_SIZE;
      if (mode === 'center') return [0, 0, 0];
      if (mode === 'corner') return [s, s, s];
      if (mode === 'edge')   return [s, 0, s];
      return [0, 0, 0];
    }

    function getCurrentChargePos3D() {
      var t = easeInOutCubic(Math.min(1, chargeAnimT));
      return [
        chargeFrom[0] + (chargeTo[0] - chargeFrom[0]) * t,
        chargeFrom[1] + (chargeTo[1] - chargeFrom[1]) * t,
        chargeFrom[2] + (chargeTo[2] - chargeFrom[2]) * t
      ];
    }

    // === GHOST CUBE OFFSETS ===
    function getGhostOffsets(mode) {
      var d = CUBE_SIZE * 2;
      if (mode === 'corner') {
        return [
          [d,0,0], [0,d,0], [0,0,d],
          [d,d,0], [d,0,d], [0,d,d],
          [d,d,d]
        ];
      }
      if (mode === 'edge') {
        return [
          [d,0,0], [0,0,d], [d,0,d]
        ];
      }
      return [];
    }

    // === FLUX CALCULATIONS ===
    function getTotalFlux() {
      var Q = CHARGE_MAG * 1e-6 * CHARGE_SIGN;
      if (MODE === 'center') return Q / EPSILON_0;
      if (MODE === 'corner') return Q / (8 * EPSILON_0);
      if (MODE === 'edge')   return Q / (4 * EPSILON_0);
      return 0;
    }

    function getFluxPerFace() {
      var Q = CHARGE_MAG * 1e-6 * CHARGE_SIGN;
      if (MODE === 'center') return Q / (6 * EPSILON_0);
      if (MODE === 'corner') return Q / (24 * EPSILON_0);
      if (MODE === 'edge')   return '(varies)';
      return 0;
    }

    function getExplanation(mode) {
      if (mode === 'center') return 'The charge is at the center of the cube. By symmetry, the total flux \u03A6 = Q/\u03B5\u2080 divides equally among all 6 faces, giving Q/6\u03B5\u2080 per face.';
      if (mode === 'corner') return 'The charge sits at one corner, shared by 8 identical cubes. By Gauss\'s Law, total flux through all 8 cubes = Q/\u03B5\u2080. Each cube gets Q/8\u03B5\u2080. Only 3 faces of this cube are exposed to the charge.';
      if (mode === 'edge')   return 'The charge is at the midpoint of one edge, shared by 4 identical cubes. Total flux through all 4 cubes = Q/\u03B5\u2080. Each cube gets Q/4\u03B5\u2080.';
      return '';
    }

    // === SIGN TOGGLE ===
    function updateSignBtn() {
      var btn = document.getElementById('signBtn');
      if (CHARGE_SIGN > 0) {
        btn.textContent = '+';
        btn.className = 'sign-btn pos';
      } else {
        btn.textContent = '\u2212';
        btn.className = 'sign-btn neg';
      }
    }

    document.getElementById('signBtn').addEventListener('click', function() {
      CHARGE_SIGN *= -1;
      updateSignBtn();
    });

    // === SLIDER + INPUT SYNC ===
    function syncCharge(val) {
      val = Math.max(1, Math.min(10, parseInt(val) || 1));
      CHARGE_MAG = val;
      document.getElementById('chargeSlider').value = val;
      document.getElementById('chargeInput').value = val;
    }
    document.getElementById('chargeSlider').addEventListener('input', function() { syncCharge(this.value); });
    document.getElementById('chargeInput').addEventListener('input', function() { syncCharge(this.value); });

    // === GHOST CHECKBOX ===
    document.getElementById('ghostCheck').addEventListener('change', function() {
      showGhosts = this.checked;
      if (showGhosts) {
        ghostProgress = 0;
        ghostAnimating = true;
      } else {
        ghostProgress = 0;
        ghostAnimating = false;
      }
    });

    // === MODE SWITCHING ===
    function setMode(newMode) {
      if (MODE === newMode) return;
      chargeFrom = getCurrentChargePos3D();
      chargeTo = getChargePos3D(newMode);
      chargeAnimT = 0;
      MODE = newMode;
      ghostProgress = 0;
      ghostAnimating = showGhosts;
      document.getElementById('modeCenterBtn').className = 'sim-btn' + (newMode === 'center' ? ' active' : '');
      document.getElementById('modeCornerBtn').className = 'sim-btn' + (newMode === 'corner' ? ' active' : '');
      document.getElementById('modeEdgeBtn').className = 'sim-btn' + (newMode === 'edge' ? ' active' : '');
    }

    document.getElementById('modeCenterBtn').addEventListener('click', function() { setMode('center'); });
    document.getElementById('modeCornerBtn').addEventListener('click', function() { setMode('corner'); });
    document.getElementById('modeEdgeBtn').addEventListener('click', function() { setMode('edge'); });

    // === RESET ===
    function resetAll() {
      CHARGE_MAG = 5;
      CHARGE_SIGN = 1;
      MODE = 'center';
      chargeFrom = [0, 0, 0];
      chargeTo = [0, 0, 0];
      chargeAnimT = 1;
      rotX = -0.45;
      rotY = 0.65;
      rotVelX = 0;
      rotVelY = 0;
      ghostProgress = 0;
      ghostAnimating = false;
      showGhosts = false;
      document.getElementById('chargeSlider').value = 5;
      document.getElementById('chargeInput').value = 5;
      document.getElementById('ghostCheck').checked = false;
      document.getElementById('modeCenterBtn').className = 'sim-btn active';
      document.getElementById('modeCornerBtn').className = 'sim-btn';
      document.getElementById('modeEdgeBtn').className = 'sim-btn';
      updateSignBtn();
      plotHistory = [];
    }

    document.getElementById('resetBtn').addEventListener('click', resetAll);
    document.getElementById('resetArrangement').addEventListener('click', resetAll);

    // === DRAWING ===
    function drawBackground() {
      var grad = ctx.createRadialGradient(canvasW / 2, canvasH / 2, 0, canvasW / 2, canvasH / 2, canvasW * 0.7);
      grad.addColorStop(0, tc.bgCenter);
      grad.addColorStop(1, tc.bg);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvasW, canvasH);

      var isLight = document.documentElement.getAttribute('data-theme') === 'light';
      var gridColor = isLight ? 'rgba(0,0,0,0.05)' : 'rgba(255,255,255,0.035)';
      ctx.strokeStyle = gridColor;
      ctx.lineWidth = 1;
      for (var x = 40; x < canvasW; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvasH);
        ctx.stroke();
      }
      for (var y = 40; y < canvasH; y += 40) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvasW, y);
        ctx.stroke();
      }
    }

    function drawCubeAt(offsetX, offsetY, offsetZ, alpha, wireOnly) {
      var s = CUBE_SIZE;
      var verts = getCubeVertices(s);

      // Apply offset to all vertices
      var rotatedVerts = [];
      for (var i = 0; i < verts.length; i++) {
        var v = [verts[i][0] + offsetX, verts[i][1] + offsetY, verts[i][2] + offsetZ];
        rotatedVerts.push(rotatePoint(v, rotX, rotY));
      }
      var projVerts = [];
      for (var i = 0; i < rotatedVerts.length; i++) {
        projVerts.push(project(rotatedVerts[i]));
      }

      // Painter's algorithm: sort faces by average z depth
      var faceOrder = [];
      for (var fi = 0; fi < FACES.length; fi++) {
        var face = FACES[fi];
        var avgZ = 0;
        for (var vi = 0; vi < face.verts.length; vi++) {
          avgZ += rotatedVerts[face.verts[vi]][2];
        }
        avgZ /= face.verts.length;
        faceOrder.push({ idx: fi, z: avgZ });
      }
      faceOrder.sort(function(a, b) { return a.z - b.z; });

      for (var oi = 0; oi < faceOrder.length; oi++) {
        var fi = faceOrder[oi].idx;
        var face = FACES[fi];
        var pts = [];
        for (var vi = 0; vi < face.verts.length; vi++) {
          pts.push(projVerts[face.verts[vi]]);
        }

        ctx.save();
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for (var pi = 1; pi < pts.length; pi++) {
          ctx.lineTo(pts[pi].x, pts[pi].y);
        }
        ctx.closePath();

        if (!wireOnly) {
          // Parse face color and apply alpha
          ctx.fillStyle = face.color.replace('0.12)', (0.12 * alpha) + ')');
          ctx.fill();
        }

        // Wireframe
        ctx.strokeStyle = wireOnly
          ? 'rgba(124,58,237,' + (0.2 * alpha) + ')'
          : 'rgba(124,58,237,' + (0.55 * alpha) + ')';
        ctx.lineWidth = wireOnly ? 0.7 : 1.2;
        ctx.stroke();

        // Face flux label (only for main cube, not ghosts)
        if (!wireOnly && alpha > 0.9) {
          var cx2d = 0, cy2d = 0;
          for (var pi = 0; pi < pts.length; pi++) { cx2d += pts[pi].x; cy2d += pts[pi].y; }
          cx2d /= pts.length;
          cy2d /= pts.length;

          var fluxFace = getFluxPerFace();
          var fluxLabel = '';
          if (typeof fluxFace === 'number') {
            fluxLabel = formatSci(fluxFace);
          } else {
            fluxLabel = '(varies)';
          }

          ctx.font = '9px "JetBrains Mono", monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = tc.labelText;
          ctx.fillText(fluxLabel, cx2d, cy2d);
        }

        ctx.restore();
      }

      return { projVerts: projVerts, rotatedVerts: rotatedVerts };
    }

    function drawGhostCubes() {
      if (!showGhosts && ghostProgress <= 0) return;
      var offsets = getGhostOffsets(MODE);
      if (offsets.length === 0) return;

      var prog = ghostProgress;
      for (var gi = 0; gi < offsets.length; gi++) {
        var delay = gi * 0.12;
        var localProg = Math.max(0, Math.min(1, (prog - delay) / 0.5));
        if (localProg <= 0) continue;
        var alpha = 0.06 + 0.14 * localProg;
        drawCubeAt(offsets[gi][0], offsets[gi][1], offsets[gi][2], alpha, true);
      }
    }

    function drawFieldLines() {
      var chargePos3D = getCurrentChargePos3D();
      var rotatedCharge = rotatePoint(chargePos3D, rotX, rotY);
      var projCharge = project(rotatedCharge);

      var isPos = CHARGE_SIGN > 0;
      var startR = 12;

      // Fibonacci sphere distribution for even coverage
      var phi_golden = Math.PI * (3 - Math.sqrt(5));
      for (var i = 0; i < NUM_FIELD_LINES; i++) {
        var yi = 1 - (i / (NUM_FIELD_LINES - 1)) * 2;
        var radius = Math.sqrt(1 - yi * yi);
        var theta_fib = phi_golden * i;
        var xi = Math.cos(theta_fib) * radius;
        var zi = Math.sin(theta_fib) * radius;

        // 3D start point near charge surface
        var lineStart3D = [
          chargePos3D[0] + xi * startR,
          chargePos3D[1] + yi * startR,
          chargePos3D[2] + zi * startR
        ];
        var lineEnd3D = [
          chargePos3D[0] + xi * (CUBE_SIZE * 2.5),
          chargePos3D[1] + yi * (CUBE_SIZE * 2.5),
          chargePos3D[2] + zi * (CUBE_SIZE * 2.5)
        ];

        var rotStart = rotatePoint(lineStart3D, rotX, rotY);
        var rotEnd = rotatePoint(lineEnd3D, rotX, rotY);
        var ps = project(rotStart);
        var pe = project(rotEnd);

        ctx.save();
        ctx.strokeStyle = 'rgba(150,150,200,0.15)';
        ctx.lineWidth = 0.8;
        ctx.setLineDash([6, 5]);
        ctx.lineDashOffset = isPos ? -flowPhase * 35 : flowPhase * 35;
        ctx.beginPath();
        ctx.moveTo(ps.x, ps.y);
        ctx.lineTo(pe.x, pe.y);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();

        // Arrowhead direction indicator
        var midX = (ps.x + pe.x) * 0.4;
        var midY = (ps.y + pe.y) * 0.4;
        var angle = Math.atan2(pe.y - ps.y, pe.x - ps.x);
        var arrowAngle = isPos ? angle : angle + Math.PI;
        var headLen = 5;
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(midX + Math.cos(arrowAngle) * headLen, midY + Math.sin(arrowAngle) * headLen);
        ctx.lineTo(midX + Math.cos(arrowAngle + 2.6) * headLen * 0.5, midY + Math.sin(arrowAngle + 2.6) * headLen * 0.5);
        ctx.lineTo(midX + Math.cos(arrowAngle - 2.6) * headLen * 0.5, midY + Math.sin(arrowAngle - 2.6) * headLen * 0.5);
        ctx.closePath();
        ctx.fillStyle = 'rgba(150,150,200,0.18)';
        ctx.fill();
        ctx.restore();
      }
    }

    function drawCharge() {
      var chargePos3D = getCurrentChargePos3D();
      var rotatedCharge = rotatePoint(chargePos3D, rotX, rotY);
      var projCharge = project(rotatedCharge);

      var pulse = 0.5 + 0.5 * Math.sin(glowPhase);
      var r = 14 + (CHARGE_MAG - 1) * 1.5;
      var glowRadius = (22 + (CHARGE_MAG - 1) * 3) + 8 * pulse;
      var glowAlpha = 0.2 + 0.15 * pulse;
      var isPos = CHARGE_SIGN > 0;

      // Glow
      var glowGrad = ctx.createRadialGradient(projCharge.x, projCharge.y, 0, projCharge.x, projCharge.y, glowRadius);
      if (isPos) {
        glowGrad.addColorStop(0, 'rgba(255,45,117,' + glowAlpha + ')');
        glowGrad.addColorStop(0.6, 'rgba(255,45,117,' + (glowAlpha * 0.4) + ')');
        glowGrad.addColorStop(1, 'rgba(255,45,117,0)');
      } else {
        glowGrad.addColorStop(0, 'rgba(0,212,255,' + glowAlpha + ')');
        glowGrad.addColorStop(0.6, 'rgba(0,212,255,' + (glowAlpha * 0.4) + ')');
        glowGrad.addColorStop(1, 'rgba(0,212,255,0)');
      }
      ctx.beginPath();
      ctx.arc(projCharge.x, projCharge.y, glowRadius, 0, Math.PI * 2);
      ctx.fillStyle = glowGrad;
      ctx.fill();

      // Body
      ctx.beginPath();
      ctx.arc(projCharge.x, projCharge.y, r, 0, Math.PI * 2);
      var bodyGrad = ctx.createRadialGradient(projCharge.x - 3, projCharge.y - 3, 0, projCharge.x, projCharge.y, r);
      if (isPos) {
        bodyGrad.addColorStop(0, '#ff5a92');
        bodyGrad.addColorStop(1, '#ff2d75');
      } else {
        bodyGrad.addColorStop(0, '#33e0ff');
        bodyGrad.addColorStop(1, '#00d4ff');
      }
      ctx.fillStyle = bodyGrad;
      ctx.shadowColor = isPos ? '#ff2d75' : '#00d4ff';
      ctx.shadowBlur = 12 + 6 * pulse;
      ctx.fill();
      ctx.shadowBlur = 0;

      // Label
      ctx.fillStyle = '#fff';
      ctx.font = 'bold ' + (11 + CHARGE_MAG) + 'px "JetBrains Mono", monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      var signChar = isPos ? '+' : '\u2212';
      ctx.fillText(signChar + CHARGE_MAG, projCharge.x, projCharge.y);

      ctx.font = 'bold 10px "Inter", sans-serif';
      ctx.fillStyle = tc.labelText;
      ctx.textBaseline = 'top';
      ctx.fillText(signChar + 'Q', projCharge.x, projCharge.y + r + 4);
    }

    function drawModeBadge() {
      var modeLabel = MODE.charAt(0).toUpperCase() + MODE.slice(1);
      var cubeInfo = '';
      if (MODE === 'corner') cubeInfo = ' (1 of 8 cubes)';
      else if (MODE === 'edge') cubeInfo = ' (1 of 4 cubes)';
      else cubeInfo = ' (1 cube)';
      var badgeText = modeLabel + cubeInfo;

      ctx.font = 'bold 11px "Inter", sans-serif';
      var tw = ctx.measureText(badgeText).width;
      var pw = tw + 20;
      var ph = 26;
      var bx = canvasW / 2 - pw / 2;
      var by = 14;

      ctx.save();
      roundedRect(ctx, bx, by, pw, ph, 13);
      ctx.fillStyle = tc.labelBg;
      ctx.fill();
      ctx.strokeStyle = 'rgba(124,58,237,0.35)';
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.fillStyle = tc.labelText;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(badgeText, canvasW / 2, by + ph / 2);
      ctx.restore();
    }

    function updateDataPanel() {
      var Q = CHARGE_MAG * 1e-6 * CHARGE_SIGN;
      var totalFlux = getTotalFlux();
      var faceFlux = getFluxPerFace();
      var signChar = CHARGE_SIGN > 0 ? '+' : '\u2212';

      document.getElementById('dataFluxTotal').textContent = formatSci(totalFlux) + ' N\u00B7m\u00B2/C';

      if (typeof faceFlux === 'number') {
        document.getElementById('dataFluxFace').textContent = formatSci(faceFlux) + ' N\u00B7m\u00B2/C';
      } else {
        document.getElementById('dataFluxFace').textContent = faceFlux;
      }

      document.getElementById('dataCharge').textContent = signChar + CHARGE_MAG + ' \u00B5C';
      document.getElementById('dataMode').textContent = MODE.charAt(0).toUpperCase() + MODE.slice(1);

      var sub = document.getElementById('dataSubstitution');
      var denomStr = MODE === 'center' ? '\u03B5\u2080' : (MODE === 'corner' ? '8\u03B5\u2080' : '4\u03B5\u2080');
      sub.innerHTML =
        '\u03A6 = Q / ' + denomStr +
        '<br>= ' + formatSci(Q) + ' / ' + denomStr +
        '<br><span class="hl">= ' + formatSci(totalFlux) + ' N\u00B7m\u00B2/C</span>';

      document.getElementById('explainText').textContent = getExplanation(MODE);
    }

    function drawFrame() {
      if (!canvasW || !canvasH) return;
      drawBackground();
      drawFieldLines();
      drawGhostCubes();
      drawCubeAt(0, 0, 0, 1, false);
      drawCharge();
      drawModeBadge();
      updateDataPanel();
    }

    // === PLOT CANVAS ===
    var plotCanvas = document.getElementById('plotCanvas');
    var pctx = plotCanvas.getContext('2d');
    var plotHistory = [];

    function resizePlotCanvas() {
      var wrap = plotCanvas.parentElement;
      var w = wrap.clientWidth;
      var h = wrap.clientHeight || 160;
      var dpr = window.devicePixelRatio || 1;
      plotCanvas.width = w * dpr;
      plotCanvas.height = h * dpr;
      plotCanvas.style.width = w + 'px';
      plotCanvas.style.height = h + 'px';
      pctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function recordPlotPoint() {
      plotHistory.push({ Q: CHARGE_MAG, flux: Math.abs(getTotalFlux()), mode: MODE });
      if (plotHistory.length > 120) plotHistory.splice(0, plotHistory.length - 120);
    }

    function drawPlot() {
      var wrap = plotCanvas.parentElement;
      var w = wrap.clientWidth;
      var h = wrap.clientHeight || 160;
      if (plotCanvas.width !== Math.round(w * (window.devicePixelRatio || 1))) resizePlotCanvas();

      var isLight = document.documentElement.getAttribute('data-theme') === 'light';
      var bgColor = isLight ? '#f0f2f8' : '#0c0c20';
      var gridColor = isLight ? 'rgba(0,0,0,0.06)' : 'rgba(255,255,255,0.06)';
      var axisColor = isLight ? 'rgba(0,0,0,0.25)' : 'rgba(255,255,255,0.2)';
      var textColor = isLight ? '#666' : '#888';
      var dotColor = '#ffcc00';

      pctx.fillStyle = bgColor;
      pctx.fillRect(0, 0, w, h);

      var pad = { left: 36, right: 12, top: 16, bottom: 24 };
      var pw = w - pad.left - pad.right;
      var ph = h - pad.top - pad.bottom;

      // Grid lines
      pctx.strokeStyle = gridColor;
      pctx.lineWidth = 1;
      for (var gi = 1; gi <= 4; gi++) {
        var gy = pad.top + ph * (1 - gi / 4);
        pctx.beginPath();
        pctx.moveTo(pad.left, gy);
        pctx.lineTo(pad.left + pw, gy);
        pctx.stroke();
      }

      // Axes
      pctx.strokeStyle = axisColor;
      pctx.lineWidth = 1.5;
      pctx.beginPath();
      pctx.moveTo(pad.left, pad.top);
      pctx.lineTo(pad.left, pad.top + ph);
      pctx.lineTo(pad.left + pw, pad.top + ph);
      pctx.stroke();

      // Axis labels
      pctx.fillStyle = textColor;
      pctx.font = '600 9px "Inter", sans-serif';
      pctx.textAlign = 'center';
      pctx.textBaseline = 'top';
      pctx.fillText('Q (\u00B5C)', pad.left + pw / 2, h - 10);
      pctx.save();
      pctx.translate(10, pad.top + ph / 2);
      pctx.rotate(-Math.PI / 2);
      pctx.fillText('\u03A6', 0, 0);
      pctx.restore();

      // Theoretical line (linear): flux = Q / (N * epsilon_0)
      var denom = MODE === 'center' ? EPSILON_0 : (MODE === 'corner' ? 8 * EPSILON_0 : 4 * EPSILON_0);
      var maxQ = 10e-6;
      var maxFluxLine = maxQ / denom;

      var lineColors = { center: 'rgba(124,58,237,0.5)', corner: 'rgba(0,200,150,0.5)', edge: 'rgba(50,130,255,0.5)' };
      pctx.beginPath();
      pctx.strokeStyle = lineColors[MODE] || 'rgba(124,58,237,0.5)';
      pctx.lineWidth = 1.5;
      for (var si = 0; si <= 10; si++) {
        var qv = si * 1e-6;
        var fv = qv / denom;
        var px = pad.left + (si / 10) * pw;
        var py = pad.top + ph * (1 - fv / maxFluxLine);
        if (si === 0) pctx.moveTo(px, py);
        else pctx.lineTo(px, py);
      }
      pctx.stroke();

      // Current dot
      var curQ = CHARGE_MAG;
      var curFlux = Math.abs(getTotalFlux());
      var curPx = pad.left + ((curQ - 1) / 9) * pw;
      var curPy = pad.top + ph * (1 - curFlux / maxFluxLine);
      curPy = Math.max(pad.top + 2, Math.min(pad.top + ph - 2, curPy));

      pctx.beginPath();
      pctx.arc(curPx, curPy, 4, 0, Math.PI * 2);
      pctx.fillStyle = dotColor;
      pctx.shadowColor = dotColor;
      pctx.shadowBlur = 6;
      pctx.fill();
      pctx.shadowBlur = 0;

      // Q-axis ticks
      pctx.fillStyle = textColor;
      pctx.font = '9px "JetBrains Mono", monospace';
      pctx.textAlign = 'center';
      pctx.textBaseline = 'top';
      for (var qi = 1; qi <= 10; qi += 3) {
        var tx = pad.left + ((qi - 1) / 9) * pw;
        pctx.fillText(qi, tx, pad.top + ph + 3);
      }

      // Flux-axis labels
      pctx.textAlign = 'right';
      pctx.textBaseline = 'middle';
      pctx.fillText('max', pad.left - 4, pad.top);
      pctx.fillText('0', pad.left - 4, pad.top + ph);
    }

    // === DRAG ROTATION ===
    canvas.addEventListener('mousedown', function(e) {
      dragging = true;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      rotVelX = 0;
      rotVelY = 0;
    });

    window.addEventListener('mousemove', function(e) {
      if (!dragging) return;
      var dx = e.clientX - lastMouseX;
      var dy = e.clientY - lastMouseY;
      rotY += dx * 0.005;
      rotX += dy * 0.005;
      rotVelY = dx * 0.005;
      rotVelX = dy * 0.005;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    });

    window.addEventListener('mouseup', function() {
      dragging = false;
    });

    canvas.addEventListener('touchstart', function(e) {
      if (e.touches.length === 1) {
        dragging = true;
        lastMouseX = e.touches[0].clientX;
        lastMouseY = e.touches[0].clientY;
        rotVelX = 0;
        rotVelY = 0;
      }
    }, { passive: true });

    canvas.addEventListener('touchmove', function(e) {
      if (!dragging || e.touches.length !== 1) return;
      var dx = e.touches[0].clientX - lastMouseX;
      var dy = e.touches[0].clientY - lastMouseY;
      rotY += dx * 0.005;
      rotX += dy * 0.005;
      rotVelY = dx * 0.005;
      rotVelX = dy * 0.005;
      lastMouseX = e.touches[0].clientX;
      lastMouseY = e.touches[0].clientY;
    }, { passive: true });

    canvas.addEventListener('touchend', function() {
      dragging = false;
    });

    // === ANIMATION LOOP ===
    var animRunning = false;

    function animLoop() {
      if (!animRunning) return;
      glowPhase += 0.02;
      flowPhase += 0.012;
      if (glowPhase > Math.PI * 2) glowPhase -= Math.PI * 2;

      // Rotation momentum damping
      if (!dragging) {
        rotX += rotVelX;
        rotY += rotVelY;
        rotVelX *= 0.96;
        rotVelY *= 0.96;
        if (Math.abs(rotVelX) < 0.0001) rotVelX = 0;
        if (Math.abs(rotVelY) < 0.0001) rotVelY = 0;
      }

      // Charge position lerp
      if (chargeAnimT < 1) {
        chargeAnimT = Math.min(1, chargeAnimT + 0.03);
      }

      // Ghost cube animation
      if (ghostAnimating && ghostProgress < 1) {
        ghostProgress = Math.min(1, ghostProgress + 0.015);
      }

      // Achievement timers
      modeTimers[MODE] += 1 / 60;
      if (modeTimers.center >= 2) _achGaussCenter = true;
      if (modeTimers.corner >= 2) _achGaussCorner = true;
      if (modeTimers.edge >= 2)   _achGaussEdge = true;

      drawFrame();

      if (Math.round(glowPhase * 50) % 5 === 0) {
        recordPlotPoint();
        drawPlot();
      }

      requestAnimationFrame(animLoop);
    }

    function startAnim() {
      if (!animRunning) {
        animRunning = true;
        requestAnimationFrame(animLoop);
      }
    }

    // === FULLSCREEN ===
    document.getElementById('fullscreenBtn').addEventListener('click', function() {
      var el = document.getElementById('simArea');
      if (!document.fullscreenElement) {
        (el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen).call(el);
      } else {
        (document.exitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen).call(document);
      }
    });

    document.addEventListener('fullscreenchange', function() {
      setTimeout(function() { resizeCanvas(); resizePlotCanvas(); }, 100);
      setTimeout(function() { resizeCanvas(); resizePlotCanvas(); }, 300);
    });

    // === TUTORIAL OVERLAY ===
    function drawCurvedArrow(svg, x1, y1, x2, y2) {
      var ns = 'http://www.w3.org/2000/svg';
      var dx = x2 - x1;
      var dy = y2 - y1;
      var cx1 = x1 + dx * 0.2;
      var cy1 = y1 + dy * 0.6;
      var cx2 = x1 + dx * 0.8;
      var cy2 = y1 + dy * 0.4;

      var path = document.createElementNS(ns, 'path');
      path.setAttribute('d',
        'M' + x1 + ',' + y1 +
        ' C' + cx1 + ',' + cy1 +
        ' ' + cx2 + ',' + cy2 +
        ' ' + x2 + ',' + y2
      );
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke', 'rgba(255,255,255,0.85)');
      path.setAttribute('stroke-width', '2');
      path.setAttribute('stroke-linecap', 'round');
      svg.appendChild(path);

      var angle = Math.atan2(y2 - cy2, x2 - cx2);
      var headLen = 10;
      var a1x = x2 - headLen * Math.cos(angle - 0.4);
      var a1y = y2 - headLen * Math.sin(angle - 0.4);
      var a2x = x2 - headLen * Math.cos(angle + 0.4);
      var a2y = y2 - headLen * Math.sin(angle + 0.4);
      var arrow = document.createElementNS(ns, 'polygon');
      arrow.setAttribute('points',
        x2 + ',' + y2 + ' ' +
        a1x + ',' + a1y + ' ' +
        a2x + ',' + a2y
      );
      arrow.setAttribute('fill', 'rgba(255,255,255,0.85)');
      svg.appendChild(arrow);
    }

    function positionTutorialHints() {
      var area = document.getElementById('simArea');
      var areaRect = area.getBoundingClientRect();
      var svg = document.getElementById('tutArrowsSvg');
      svg.innerHTML = '';

      var targets = [
        { hint: 'tutHintMode',   el: document.querySelector('.mode-btn-group'), type: 'bottom' },
        { hint: 'tutHintCanvas', el: document.getElementById('simCanvas'),       type: 'canvas' },
        { hint: 'tutHintData',   el: document.querySelector('.side-data'),        type: 'bottom' }
      ];

      var placed = [];

      for (var i = 0; i < targets.length; i++) {
        var t = targets[i];
        var hintEl = document.getElementById(t.hint);
        if (!t.el) continue;
        var elRect = t.el.getBoundingClientRect();
        var cx = elRect.left + elRect.width / 2 - areaRect.left;
        var cy = elRect.top - areaRect.top;

        if (t.type === 'canvas') {
          var midX = elRect.left + elRect.width / 2 - areaRect.left;
          var midY = elRect.top + elRect.height * 0.35 - areaRect.top;
          hintEl.style.left = midX + 'px';
          hintEl.style.top = midY + 'px';
          hintEl.style.transform = 'translateX(-50%)';
          hintEl.style.right = '';
          continue;
        }

        hintEl.style.left = cx + 'px';
        hintEl.style.transform = 'translateX(-50%)';
        hintEl.style.top = '0px';

        var hintRect = hintEl.getBoundingClientRect();
        var hintW = hintRect.width;
        var hintH = hintRect.height;

        var desiredTop = cy - 50;
        var hintLeft = cx - hintW / 2;
        var hintRight = hintLeft + hintW;

        var finalTop = desiredTop;
        for (var j = 0; j < placed.length; j++) {
          var p = placed[j];
          if (hintRight > p.left && hintLeft < p.right) {
            if (finalTop + hintH > p.top && finalTop < p.bottom) {
              finalTop = p.top - hintH - 8;
            }
          }
        }

        hintEl.style.top = finalTop + 'px';
        placed.push({
          left: hintLeft,
          right: hintRight,
          top: finalTop,
          bottom: finalTop + hintH
        });

        var arrowStartX = cx;
        var arrowStartY = finalTop + hintH + 2;
        var arrowEndX = cx;
        var arrowEndY = cy + 2;
        drawCurvedArrow(svg, arrowStartX, arrowStartY, arrowEndX, arrowEndY);
      }
    }

    function showTutorial() {
      var el = document.getElementById('simTutorial');
      el.style.display = '';
      el.offsetHeight;
      el.style.opacity = '1';
      positionTutorialHints();
    }

    window.addEventListener('resize', function() {
      if (document.getElementById('simTutorial').style.display !== 'none') {
        positionTutorialHints();
      }
    });

    function dismissTutorial() {
      var el = document.getElementById('simTutorial');
      el.style.opacity = '0';
      setTimeout(function() { el.style.display = 'none'; }, 400);
      localStorage.setItem('tut-gauss-law', '1');
    }

    if (!localStorage.getItem('tut-gauss-law')) {
      showTutorial();
    }

    document.getElementById('simTutorial').addEventListener('click', dismissTutorial);
    document.getElementById('helpBtn').addEventListener('click', showTutorial);

    // === INIT ===
    chargeFrom = getChargePos3D('center');
    chargeTo = getChargePos3D('center');
    resizeCanvas();
    resizePlotCanvas();
    startAnim();
  </script>
  <script src="../js/main.js"></script>
</body>
</html>
