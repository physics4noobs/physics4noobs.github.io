<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gauss's Law | Physics for Noobs</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;500;600;700&family=Jost:wght@300;400;500;600;700&family=Delius&family=Nova+Square&family=Yatra+One&family=Quintessential&family=Cabin+Sketch:wght@400;700&family=Orbitron:wght@400;500;600;700;800;900&family=Inter:wght@300;400;500;600;700&family=Andika:wght@400;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/achievements.css">
  <link rel="manifest" href="../manifest.json">
  <meta name="theme-color" content="#050510">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="../images/icon-192.svg">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ”¬</text></svg>">
  <script src="../js/theme.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
  <script defer src="../js/firebase-config.js"></script>
  <script defer src="../js/auth.js"></script>
  <script defer src="../js/ranking.js"></script>
  <script defer src="../js/sim-tracker.js"></script>
  <script defer src="../js/achievements-config.js"></script>
  <script defer src="../js/achievements.js"></script>
</head>
<body data-auth-redirect="../simulations.html">
  <!-- Splash Screen -->
  <div class="splash-screen" id="splash"><div class="splash-rocket"><div class="sp-nose"></div><div class="sp-body"></div><div class="sp-window"></div><div class="sp-fin-l"></div><div class="sp-fin-r"></div><div class="sp-flame"></div><div class="sp-glow"></div></div><div class="splash-logo"><span class="brand-initial">P</span>hysics <span class="brand-accent">for Noobs</span></div><div class="splash-tagline">Get It, For Real</div></div>
<div class="bg-grid"></div>
  <nav class="navbar scrolled">
    <div class="nav-container">
      <a href="../index.html" class="nav-logo" id="nav-logo">
        <div class="logo-icon"><div class="logo-pendulum"><div class="pendulum-pivot"></div><div class="pendulum-arm"><div class="pendulum-string"></div><div class="pendulum-bob"></div></div></div></div>
        <div class="logo-text"><span class="brand-name"><span class="brand-initial">P</span>hysics <span class="brand-accent">for Noobs</span></span><span class="brand-tag">GET IT, FOR REAL</span></div>
      </a>
      <div class="nav-links">
        <div class="nav-item"><a href="../index.html" class="nav-link">Home</a></div>
        <div class="nav-item"><a href="../about.html" class="nav-link">About Me</a></div>
        <div class="nav-item"><a href="../chapters.html" class="nav-link">Chapters</a></div>
        <div class="nav-item"><a href="../simulations.html" class="nav-link active">Simulations</a></div>
        <div class="nav-item"><a href="../tests.html" class="nav-link">Tests</a></div>
        <div class="nav-item"><a href="../flashcards.html" class="nav-link">Flashcards</a></div>
        <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme"></button>
        <button class="auth-btn" id="auth-login-btn"><svg class="google-icon" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92a5.06 5.06 0 0 1-2.2 3.32v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.1z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>Sign in</button>
        <a href="progress.html" class="mobile-auth-action" id="mobile-progress-btn" style="display:none;">Progress</a>
        <button class="mobile-auth-action mobile-signout-btn" id="mobile-signout-btn" style="display:none;">Sign Out</button>

        <div class="user-menu nav-item" id="auth-user-menu" style="display:none;"><img class="user-avatar" id="auth-user-avatar" src="" alt="User"><span class="user-rank-badge rank-bronze" id="auth-rank-badge"><span class="rank-icon" id="auth-rank-icon"></span><span id="auth-rank-label"></span></span><div class="dropdown"><div class="dropdown-rank" id="dropdown-rank-display"><span class="rank-tier" id="dropdown-rank-tier"></span><div class="rank-progress-bar"><div class="rank-progress-fill" id="dropdown-rank-fill"></div></div></div><a href="../progress.html"><div class="dd-icon">&#128200;</div> My Progress</a><div class="dropdown-divider"></div><a href="#" id="auth-logout-btn"><div class="dd-icon">&#128682;</div> Sign Out</a></div></div>
      </div>
      <button class="nav-toggle" aria-label="Menu"><span></span><span></span><span></span></button>
    </div>
  </nav>
  <script>
    (function(){
      var s=document.getElementById('splash');
      if(sessionStorage.getItem('ae-splash')){s.style.display='none';}
      else{
        sessionStorage.setItem('ae-splash','1');setTimeout(function(){s.classList.add('fade-out');},2200);setTimeout(function(){s.style.display='none';},2700);
      }
    })();
  </script>

  <style>
    .bg-grid { display: none !important; }

    .sim-wrapper {
      max-width: 1400px;
      margin: 0 auto;
      padding: 80px 24px 40px;
    }

    .sim-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }

    .sim-header h1 {
      font-family: var(--font-display);
      font-size: clamp(1.4rem, 2vw, 1.8rem);
      font-weight: 700;
      color: var(--text-primary);
      letter-spacing: 0.5px;
    }

    .sim-btn {
      padding: 8px 20px;
      font-size: 0.85rem;
      font-weight: 600;
      font-family: var(--font-body);
      color: var(--text-secondary);
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: var(--transition-fast);
    }

    .sim-btn:hover {
      color: var(--text-primary);
      border-color: rgba(124, 58, 237, 0.3);
      background: rgba(124, 58, 237, 0.08);
    }

    .sim-btn.primary {
      background: rgba(124, 58, 237, 0.15);
      color: var(--text-primary);
      border-color: rgba(124, 58, 237, 0.3);
    }

    .sim-btn.primary:hover {
      background: rgba(124, 58, 237, 0.25);
    }

    .sim-btn.active {
      background: rgba(124, 58, 237, 0.18);
      color: var(--text-primary);
      border-color: rgba(124, 58, 237, 0.4);
      box-shadow: 0 0 10px rgba(124,58,237,0.25);
      transform: scale(1.06);
    }

    .sim-main-row {
      display: flex;
      gap: 1px;
      background: var(--border-subtle);
      border-radius: var(--radius-md) var(--radius-md) 0 0;
      overflow: hidden;
    }

    .canvas-wrap {
      flex: 1;
      overflow: hidden;
      background: var(--bg-secondary);
    }

    .canvas-wrap canvas {
      display: block;
      width: 100%;
    }

    /* Side Data Panel */
    .side-data {
      width: 320px;
      min-width: 280px;
      background: var(--bg-card);
      padding: 14px;
      display: flex;
      flex-direction: column;
    }

    .side-data h3 {
      font-family: var(--font-display);
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }

    .data-grid {
      display: flex;
      flex-direction: column;
    }

    .data-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 0;
      border-bottom: 1px solid var(--border-subtle);
    }

    .data-row:last-child {
      border-bottom: none;
    }

    .data-label {
      font-family: var(--font-body);
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .data-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      color: var(--text-primary);
      font-weight: 600;
      text-align: right;
    }

    .data-value.flux-val { color: #ffcc00; }

    .data-formula {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.72rem;
      color: var(--text-secondary);
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      padding: 6px 8px;
      margin-top: 8px;
      line-height: 1.5;
      word-break: break-all;
    }

    .data-formula .hl {
      color: #ffcc00;
      font-weight: 700;
    }

    /* Controls */
    .controls-bar {
      display: flex;
      align-items: center;
      gap: clamp(10px, 2.5vw, 24px);
      padding: 18px 24px;
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      border-top: none;
      border-radius: 0 0 var(--radius-md) var(--radius-md);
      flex-wrap: wrap;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .control-group label {
      font-family: var(--font-body);
      font-size: clamp(0.8rem, 0.95vw, 0.95rem);
      color: var(--text-muted);
      white-space: nowrap;
    }

    .control-sep {
      width: 1px;
      height: 24px;
      background: var(--border-subtle);
    }

    .slider-val {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.82rem;
      font-weight: 600;
      color: var(--text-primary);
      min-width: 48px;
    }

    .num-input {
      width: 58px;
      padding: 4px 6px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.82rem;
      font-weight: 600;
      color: var(--text-primary);
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      text-align: center;
      outline: none;
      transition: var(--transition-fast);
    }

    .num-input:focus {
      border-color: rgba(124, 58, 237, 0.5);
      box-shadow: 0 0 0 2px rgba(124, 58, 237, 0.15);
    }

    .sign-btn {
      min-width: 32px;
      height: 30px;
      padding: 4px 8px;
      font-size: 0.85rem;
      font-weight: 700;
      font-family: 'JetBrains Mono', monospace;
      border-radius: var(--radius-sm);
      border: 1px solid;
      cursor: pointer;
      transition: var(--transition-fast);
    }

    .sign-btn.pos {
      background: rgba(255,45,117,0.18);
      border-color: rgba(255,45,117,0.4);
      color: #ff5a92;
    }

    .sign-btn.neg {
      background: rgba(0,212,255,0.10);
      border-color: rgba(0,212,255,0.3);
      color: #00d4ff;
    }

    .sign-btn:hover {
      transform: scale(1.08);
    }

    /* Equations */
    .equations-section {
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-md);
      padding: 20px 24px;
      margin-top: 16px;
    }

    .equations-section h3 {
      font-family: var(--font-display);
      font-size: clamp(0.8rem, 1vw, 1rem);
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 14px;
    }

    .equations-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 12px 32px;
    }

    .equation-item {
      font-family: var(--font-body);
      font-size: clamp(1rem, 1.2vw, 1.2rem);
      color: var(--text-primary);
      padding: 8px 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      white-space: nowrap;
    }

    .equation-item .eq-label {
      color: var(--text-muted);
      font-size: clamp(0.8rem, 0.9vw, 0.9rem);
      display: block;
      margin-bottom: 2px;
    }

    /* Q&A */
    .qa-section {
      margin-top: 32px;
    }

    .qa-section h2 {
      font-family: var(--font-display);
      font-size: clamp(0.9rem, 1.1vw, 1.1rem);
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 16px;
    }

    .qa-item {
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-md);
      margin-bottom: 8px;
      overflow: hidden;
      transition: var(--transition-fast);
    }

    .qa-item:hover {
      border-color: rgba(124, 58, 237, 0.2);
    }

    .qa-q {
      padding: 16px 24px;
      font-family: var(--font-body);
      font-size: clamp(0.95rem, 1.1vw, 1.15rem);
      color: var(--text-primary);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: var(--transition-fast);
    }

    .qa-q:hover {
      background: var(--bg-glass-hover);
    }

    .qa-q::after {
      content: '+';
      font-size: 1.4rem;
      color: var(--color-primary);
      transition: transform 0.2s;
      font-weight: 300;
    }

    .qa-item.open .qa-q::after {
      content: '\2212';
    }

    .qa-a {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .qa-item.open .qa-a {
      max-height: 500px;
    }

    .qa-a-inner {
      padding: 0 24px 18px;
      font-family: var(--font-body);
      font-size: clamp(0.92rem, 1vw, 1.08rem);
      color: var(--text-secondary);
      line-height: 1.75;
    }

    /* Fullscreen */
    #simArea {
      background: var(--bg-primary);
      position: relative;
    }

    #simArea:fullscreen,
    #simArea:-webkit-full-screen {
      background: var(--bg-primary);
      padding: 16px 24px;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }

    #simArea:fullscreen .sim-main-row,
    #simArea:-webkit-full-screen .sim-main-row {
      flex: 1;
      min-height: 0;
    }

    #simArea:fullscreen .canvas-wrap,
    #simArea:-webkit-full-screen .canvas-wrap {
      flex: 1;
      min-height: 0;
    }

    #simArea:fullscreen .controls-bar,
    #simArea:-webkit-full-screen .controls-bar {
      border-radius: 0;
    }

    @media (max-width: 900px) {
      .sim-main-row { flex-direction: column; }
      .side-data { width: 100%; min-width: unset; }
    }

    @media (max-width: 768px) {
      .sim-wrapper { padding: 70px 12px 24px; }
      .sim-header { flex-direction: column; gap: 12px; align-items: flex-start; }
      .controls-bar { gap: 8px; padding: 12px; }
    }

    /* === Camera Controls === */
    .cam-controls {
      position: absolute;
      bottom: 12px;
      left: 12px;
      display: grid;
      grid-template-areas: ". up ." "left center right" ". down .";
      grid-template-columns: 28px 28px 28px;
      grid-template-rows: 28px 28px 28px;
      gap: 2px;
      z-index: 10;
    }
    .cam-btn {
      width: 28px; height: 28px;
      border: 1px solid rgba(124,58,237,0.3);
      background: rgba(10,10,30,0.6);
      color: #ccc;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      display: flex; align-items: center; justify-content: center;
      transition: background 0.15s;
      padding: 0;
      line-height: 1;
    }
    .cam-btn:hover { background: rgba(124,58,237,0.3); color: #fff; }
    .cam-btn:active { background: rgba(124,58,237,0.5); }

    /* === Investigate Overlay === */
    .investigate-overlay {
      position: absolute;
      inset: 0;
      z-index: 45;
      background: rgba(10, 10, 30, 0.88);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
      transition: opacity 0.4s ease;
      border-radius: var(--radius-md);
    }
    .investigate-overlay canvas {
      border-radius: var(--radius-sm);
      border: 1px solid rgba(124,58,237,0.2);
      cursor: grab;
      max-width: 90%;
      max-height: 55%;
    }
    .investigate-overlay canvas:active { cursor: grabbing; }
    .investigate-title {
      font-family: var(--font-display);
      font-size: 1.3rem;
      font-weight: 700;
      color: #fff;
      letter-spacing: 0.02em;
    }
    .investigate-label {
      font-size: 0.88rem;
      color: rgba(255,255,255,0.75);
      text-align: center;
      max-width: 420px;
      line-height: 1.5;
    }
    .investigate-close {
      padding: 10px 28px;
      font-size: 0.9rem;
      font-weight: 700;
      color: #1a1a2e;
      background: #fff;
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      box-shadow: 0 4px 16px rgba(124,58,237,0.3);
      transition: background 0.2s, transform 0.15s;
    }
    .investigate-close:hover { background: #e8e0ff; transform: scale(1.04); }

    /* === Tutorial Overlay === */
    .sim-tutorial {
      position: absolute;
      inset: 0;
      z-index: 50;
      background: rgba(255,255,255,0.08);
      backdrop-filter: blur(0.5px);
      -webkit-backdrop-filter: blur(0.5px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 0.4s ease;
      cursor: pointer;
      border-radius: var(--radius-md);
    }

    .tut-hint {
      position: absolute;
      display: flex;
      align-items: center;
      gap: 8px;
      color: #fff;
      font-size: 0.88rem;
      pointer-events: none;
    }

    .tut-arrows-svg {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }

    .tut-label {
      font-family: var(--font-body);
      background: rgba(255,255,255,0.92);
      color: #1a1a2e;
      padding: 6px 14px;
      border-radius: 20px;
      font-weight: 600;
      font-size: 0.82rem;
      white-space: nowrap;
      box-shadow: 0 2px 8px rgba(0,0,0,0.18);
    }

    .tut-dismiss {
      position: absolute;
      bottom: 38%;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 32px;
      font-family: var(--font-body);
      font-size: 0.95rem;
      font-weight: 700;
      color: #1a1a2e;
      background: #fff;
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      pointer-events: auto;
      box-shadow: 0 4px 16px rgba(124,58,237,0.3);
      transition: background 0.2s, transform 0.2s;
    }

    .tut-dismiss:hover {
      background: #e8e0f8;
      transform: translateX(-50%) scale(1.04);
    }

    @media (max-width: 900px) {
      .sim-tutorial { display: none !important; }
      #helpBtn { display: none; }
    }

    .mode-btn-group {
      display: flex;
      gap: 4px;
    }

    .explain-text {
      font-family: var(--font-body);
      font-size: 0.75rem;
      color: var(--text-secondary);
      line-height: 1.5;
      margin-top: 8px;
      padding: 8px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      min-height: 56px;
    }

    /* === Equation active state === */
    .equation-item { transition: border-color 0.3s, background 0.3s, box-shadow 0.3s; }
    .equation-item.active { border-color: rgba(124,58,237,0.6); background: rgba(124,58,237,0.08); box-shadow: 0 0 8px rgba(124,58,237,0.15); }

    /* === Subtitle === */
    .sim-subtitle { font-size: 0.78rem; color: var(--text-muted); margin: 2px 0 0; font-weight: 400; }

    /* === Ghost checkbox disabled === */
    .control-group label:has(input:disabled) { opacity: 0.4; cursor: not-allowed; }

    /* === Investigate overlay light theme === */
    [data-theme="light"] .investigate-overlay { background: rgba(240,240,255,0.92); }
    [data-theme="light"] .investigate-title { color: #333; }
    [data-theme="light"] .investigate-label { color: rgba(0,0,0,0.65); }

    /* === Data panel min-height === */
    .data-value { min-height: 42px; }
  </style>

  <div class="sim-wrapper">
    <div id="simArea">
    <div class="sim-header">
      <div>
        <h1>Gauss's Law</h1>
        <p class="sim-subtitle">Explore how electric flux through a closed surface depends only on the enclosed charge</p>
      </div>
      <div style="display:flex;gap:8px;">
        <button class="sim-btn" id="resetBtn">Reset</button>
        <button class="sim-btn" id="fullscreenBtn">Full Screen</button>
        <button class="sim-btn" id="helpBtn">? Help</button>
      </div>
    </div>

    <div class="sim-main-row">
      <div class="canvas-wrap" style="position:relative;">
        <canvas id="simCanvas"></canvas>
        <div class="cam-controls">
          <button class="cam-btn" style="grid-area:up" id="camUp" title="Rotate up">&#9650;</button>
          <button class="cam-btn" style="grid-area:left" id="camLeft" title="Rotate left">&#9664;</button>
          <button class="cam-btn" style="grid-area:center" id="camStab" title="Stabilize">&#8857;</button>
          <button class="cam-btn" style="grid-area:right" id="camRight" title="Rotate right">&#9654;</button>
          <button class="cam-btn" style="grid-area:down" id="camDown" title="Rotate down">&#9660;</button>
        </div>
      </div>
      <div class="side-data">
        <h3>Data</h3>
        <div class="data-grid">
          <div class="data-row">
            <span class="data-label">&Phi;<sub>total</sub></span>
            <span class="data-value flux-val" id="dataFluxTotal">&mdash;</span>
          </div>
          <div class="data-row">
            <span class="data-label">&Phi;<sub>face</sub></span>
            <span class="data-value" id="dataFluxFace">&mdash;</span>
          </div>
          <div class="data-row">
            <span class="data-label">Q</span>
            <span class="data-value" id="dataCharge">&mdash;</span>
          </div>
          <div class="data-row">
            <span class="data-label">Mode</span>
            <span class="data-value" id="dataMode">&mdash;</span>
          </div>
        </div>
        <div class="data-formula" id="dataSubstitution">&mdash;</div>
        <div class="explain-text" id="explainText"></div>
      </div>
    </div>

    <div class="controls-bar">
      <div class="control-group">
        <div class="mode-btn-group">
          <button class="sim-btn active" id="modeCenterBtn">Center</button>
          <button class="sim-btn" id="modeCornerBtn">Corner</button>
          <button class="sim-btn" id="modeEdgeBtn">Edge</button>
        </div>
      </div>
      <div class="control-sep"></div>
      <div class="control-group" id="chargeCtrl">
        <button class="sign-btn pos" id="signBtn">+</button>
        <label>Q:</label>
        <input type="range" id="chargeSlider" min="1" max="10" step="1" value="5">
        <input type="number" class="num-input" id="chargeInput" min="1" max="10" step="1" value="5">
        <span class="slider-val">&micro;C</span>
      </div>
      <div class="control-sep"></div>
      <div class="control-group">
        <label>
          <input type="checkbox" id="ghostCheck"> Show Ghost Cubes
        </label>
      </div>
      <div class="control-sep"></div>
      <button class="sim-btn" id="investigateBtn" style="display:none;">Why Q/8?</button>
      <div class="control-sep" id="investigateSep" style="display:none;"></div>
      <button class="sim-btn" id="resetArrangement">&#8635; Reset</button>
    </div>

    <!-- Investigate Overlay -->
    <div class="investigate-overlay" id="investigateOverlay" style="display:none;">
      <div class="investigate-title" id="investigateTitle">Why Q/8?</div>
      <canvas id="investigateCanvas" width="500" height="400"></canvas>
      <div class="investigate-label" id="investigateLabel">
        A corner is shared by 8 cubes &mdash; each encloses exactly &frac18; of the charge
      </div>
      <button class="investigate-close" id="investigateClose">Got it</button>
    </div>

    <!-- Tutorial Overlay -->
    <div class="sim-tutorial" id="simTutorial" style="display:none;">
      <svg class="tut-arrows-svg" id="tutArrowsSvg"></svg>
      <div class="tut-hint" id="tutHintMode">
        <div class="tut-label">Switch modes &amp; use 'Why Q/8?' to explore charge fractions</div>
      </div>
      <div class="tut-hint" id="tutHintCanvas">
        <div class="tut-label">Drag to rotate the 3D cube</div>
      </div>
      <div class="tut-hint" id="tutHintData">
        <div class="tut-label">Watch how flux changes with charge position</div>
      </div>
      <div class="tut-hint" id="tutHintGhost">
        <div class="tut-label">Toggle ghost cubes to see the tiling argument</div>
      </div>
      <button class="tut-dismiss">Got it, let's start!</button>
    </div>

    </div><!-- end #simArea -->

    <div class="equations-section">
      <h3>Key Equations</h3>
      <div class="equations-grid">
        <div class="equation-item" id="eqGauss">
          <span class="eq-label">Gauss's Law</span>
          &Phi; = Q<sub>enc</sub> / &epsilon;&#8320;
        </div>
        <div class="equation-item" id="eqCenter">
          <span class="eq-label">Center of Cube</span>
          &Phi;<sub>face</sub> = Q / 6&epsilon;&#8320;
        </div>
        <div class="equation-item" id="eqCorner">
          <span class="eq-label">Corner of Cube</span>
          &Phi;<sub>total</sub> = Q / 8&epsilon;&#8320;
        </div>
        <div class="equation-item" id="eqEdge">
          <span class="eq-label">Edge of Cube</span>
          &Phi;<sub>total</sub> = Q / 4&epsilon;&#8320;
        </div>
        <div class="equation-item" id="eqCoulomb">
          <span class="eq-label">Coulomb Constant</span>
          k = 1/4&pi;&epsilon;&#8320; = 9 &times; 10&sup9; N&middot;m&sup2;/C&sup2;
        </div>
      </div>
    </div>

    <div class="qa-section">
      <h2>Test Your Understanding</h2>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">What is Gauss's Law?</div>
        <div class="qa-a"><div class="qa-a-inner">
          Gauss's Law states that the total electric flux through any closed surface equals the net enclosed charge divided by &epsilon;&#8320;: &Phi; = Q<sub>enc</sub>/&epsilon;&#8320;. It is one of Maxwell's four equations and is especially powerful for calculating electric fields of symmetric charge distributions. The flux depends only on the enclosed charge, not on the shape or size of the surface.
        </div></div>
      </div>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">Why is the flux through each face equal when the charge is at the center?</div>
        <div class="qa-a"><div class="qa-a-inner">
          When the charge is at the exact center of the cube, every face is equidistant from the charge and subtends the same solid angle. By symmetry, the total flux Q/&epsilon;&#8320; divides equally among 6 faces, giving Q/6&epsilon;&#8320; per face. This beautiful symmetry argument requires no integration.
        </div></div>
      </div>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">Why do you need 8 cubes when the charge is at a corner?</div>
        <div class="qa-a"><div class="qa-a-inner">
          A corner of a cube is shared by exactly 8 cubes that can tile together to completely surround the charge. By Gauss's Law, the total flux through all 8 cubes combined is Q/&epsilon;&#8320;. Since each cube is identical by symmetry, each receives Q/8&epsilon;&#8320; of the total flux. The 3 faces adjacent to the corner carry zero flux because the electric field is tangential (parallel) to them. The 3 opposite faces each receive Q/24&epsilon;&#8320;.
        </div></div>
      </div>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">What happens when the charge is at the midpoint of an edge?</div>
        <div class="qa-a"><div class="qa-a-inner">
          An edge of a cube is shared by exactly 4 cubes. By Gauss's Law, each cube encloses Q/4 of the total flux. The 2 faces that share the edge carry zero flux because the electric field is parallel to them at every point. The remaining 4 faces share the flux, but not equally &mdash; the faces closer to the charge subtend a larger solid angle and receive more flux.
        </div></div>
      </div>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">How does Gauss's Law relate to Coulomb's Law?</div>
        <div class="qa-a"><div class="qa-a-inner">
          They are equivalent! Applying Gauss's Law to a spherical Gaussian surface of radius r around a point charge Q gives &Phi; = E&middot;4&pi;r&sup2; = Q/&epsilon;&#8320;, which yields E = Q/(4&pi;&epsilon;&#8320;r&sup2;) = kQ/r&sup2; &mdash; exactly Coulomb's Law. Gauss's Law is the integral form while Coulomb's Law gives the field at a point.
        </div></div>
      </div>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">Does the shape of the Gaussian surface matter?</div>
        <div class="qa-a"><div class="qa-a-inner">
          The total flux through any closed surface depends only on the enclosed charge (&Phi; = Q<sub>enc</sub>/&epsilon;&#8320;), regardless of shape. However, to easily calculate E from flux, you want a surface where E is constant and perpendicular &mdash; that is why we choose spheres for point charges, cylinders for line charges, and boxes for sheet charges. The cube is used here for pedagogical clarity.
        </div></div>
      </div>
    </div>
  </div>

  <script>
    // === THEME COLORS ===
    var tc = {};
    function updateThemeColors() {
      var isLight = document.documentElement.getAttribute('data-theme') === 'light';
      tc = {
        bg: isLight ? '#e8eaf0' : '#080818',
        bgCenter: isLight ? '#f0f2f8' : '#0a0a24',
        grid: isLight ? 'rgba(0,120,200,0.06)' : 'rgba(0,212,255,0.04)',
        text: isLight ? '#333' : '#fff',
        labelBg: isLight ? 'rgba(255,255,255,0.88)' : 'rgba(10,10,30,0.88)',
        labelBorder: isLight ? 'rgba(124,58,237,0.35)' : 'rgba(124,58,237,0.35)',
        labelText: isLight ? '#7c3aed' : '#a78bfa'
      };
    }
    updateThemeColors();
    new MutationObserver(function() { updateThemeColors(); drawFrame(); })
      .observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });

    // === CANVAS SETUP ===
    var canvas = document.getElementById('simCanvas');
    var ctx = canvas.getContext('2d');
    var canvasW, canvasH;

    function resizeCanvas() {
      var wrap = canvas.parentElement;
      var isFS = !!document.fullscreenElement;
      var w = wrap.clientWidth;
      var h = isFS ? wrap.clientHeight : Math.max(350, window.innerHeight - 300);
      var dpr = window.devicePixelRatio || 1;

      canvas.width = w * dpr;
      canvas.height = h * dpr;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      canvasW = w;
      canvasH = h;
    }

    window.addEventListener('resize', function() {
      resizeCanvas();
    });

    // === STATE VARIABLES ===
    var CHARGE_MAG = 5;
    var CHARGE_SIGN = 1;
    var MODE = 'center';
    var CUBE_SIZE = 120;
    var NUM_FIELD_LINES = 32;
    var EPSILON_0 = 8.854e-12;

    var rotX = 0;
    var rotY = 0;
    var dragging = false;
    var lastMouseX = 0, lastMouseY = 0;
    var rotVelX = 0, rotVelY = 0;

    var showGhosts = false;
    var ghostProgress = 0;
    var ghostAnimating = false;
    var chargeAnimT = 1;
    var chargeFrom = [0, 0, 0];
    var chargeTo = [0, 0, 0];

    var glowPhase = 0;
    var flowPhase = 0;

    var _achGaussCenter = false;
    var _achGaussCorner = false;
    var _achGaussEdge = false;
    var modeTimers = { center: 0, corner: 0, edge: 0 };

    // === HELPERS ===
    function roundedRect(ctx, x, y, w, h, r) {
      if (r > w / 2) r = w / 2;
      if (r > h / 2) r = h / 2;
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.arcTo(x + w, y, x + w, y + r, r);
      ctx.lineTo(x + w, y + h - r);
      ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
      ctx.lineTo(x + r, y + h);
      ctx.arcTo(x, y + h, x, y + h - r, r);
      ctx.lineTo(x, y + r);
      ctx.arcTo(x, y, x + r, y, r);
      ctx.closePath();
    }

    function formatSci(val) {
      if (val === 0) return '0';
      var sign = val < 0 ? '-' : '';
      var abs = Math.abs(val);
      var exp = Math.floor(Math.log10(abs));
      var mantissa = abs / Math.pow(10, exp);
      return sign + mantissa.toFixed(2) + '\u00D710' + superscript(exp);
    }

    function superscript(n) {
      var sup = {'0':'\u2070','1':'\u00B9','2':'\u00B2','3':'\u00B3','4':'\u2074',
                 '5':'\u2075','6':'\u2076','7':'\u2077','8':'\u2078','9':'\u2079','-':'\u207B'};
      var s = String(n), result = '';
      for (var i = 0; i < s.length; i++) result += sup[s[i]] || s[i];
      return result;
    }

    function easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    // === 3D ENGINE ===
    function rotatePoint(p, rx, ry) {
      var cosX = Math.cos(rx), sinX = Math.sin(rx);
      var y1 = p[1] * cosX - p[2] * sinX;
      var z1 = p[1] * sinX + p[2] * cosX;
      var cosY = Math.cos(ry), sinY = Math.sin(ry);
      var x2 = p[0] * cosY + z1 * sinY;
      var z2 = -p[0] * sinY + z1 * cosY;
      return [x2, y1, z2];
    }

    var FOV = 500;

    function project(p) {
      var scale = FOV / (FOV + p[2]);
      return {
        x: canvasW / 2 + p[0] * scale,
        y: canvasH / 2 + p[1] * scale,
        scale: scale,
        z: p[2]
      };
    }

    function getCubeVertices(s) {
      return [
        [-s, -s, -s], [s, -s, -s], [s, s, -s], [-s, s, -s],
        [-s, -s,  s], [s, -s,  s], [s, s,  s], [-s, s,  s]
      ];
    }

    var FACES = [
      { verts: [0,1,2,3], color: 'rgba(124,58,237,0.12)', label: 'Back' },
      { verts: [4,5,6,7], color: 'rgba(124,58,237,0.12)', label: 'Front' },
      { verts: [0,1,5,4], color: 'rgba(0,200,150,0.12)',  label: 'Top' },
      { verts: [2,3,7,6], color: 'rgba(0,200,150,0.12)',  label: 'Bottom' },
      { verts: [0,3,7,4], color: 'rgba(50,130,255,0.12)', label: 'Left' },
      { verts: [1,2,6,5], color: 'rgba(50,130,255,0.12)', label: 'Right' }
    ];

    // === CHARGE POSITION ===
    function getChargePos3D(mode) {
      var s = CUBE_SIZE;
      if (mode === 'center') return [0, 0, 0];
      if (mode === 'corner') return [s, s, s];
      if (mode === 'edge')   return [s, 0, s];
      return [0, 0, 0];
    }

    function getCurrentChargePos3D() {
      var t = easeInOutCubic(Math.min(1, chargeAnimT));
      return [
        chargeFrom[0] + (chargeTo[0] - chargeFrom[0]) * t,
        chargeFrom[1] + (chargeTo[1] - chargeFrom[1]) * t,
        chargeFrom[2] + (chargeTo[2] - chargeFrom[2]) * t
      ];
    }

    // === GHOST CUBE OFFSETS ===
    function getGhostOffsets(mode) {
      var d = CUBE_SIZE * 2;
      if (mode === 'corner') {
        return [
          [d,0,0], [0,d,0], [0,0,d],
          [d,d,0], [d,0,d], [0,d,d],
          [d,d,d]
        ];
      }
      if (mode === 'edge') {
        return [
          [d,0,0], [0,0,d], [d,0,d]
        ];
      }
      return [];
    }

    // === SOLID ANGLE (Van Oosterom-Strackee) ===
    function vec3sub(a, b) { return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
    function vec3dot(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
    function vec3cross(a, b) { return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
    function vec3len(a) { return Math.sqrt(a[0]*a[0] + a[1]*a[1] + a[2]*a[2]); }

    function solidAngleTriangle(P, A, B, C) {
      var a = vec3sub(A, P), b = vec3sub(B, P), c = vec3sub(C, P);
      var la = vec3len(a), lb = vec3len(b), lc = vec3len(c);
      if (la < 1e-10 || lb < 1e-10 || lc < 1e-10) return 0;
      var num = vec3dot(a, vec3cross(b, c));
      var den = la * lb * lc + vec3dot(a, b) * lc + vec3dot(b, c) * la + vec3dot(c, a) * lb;
      return 2 * Math.atan2(num, den);
    }

    function solidAngleFace(faceIdx, chargePos) {
      var s = CUBE_SIZE;
      var verts = getCubeVertices(s);
      var fv = FACES[faceIdx].verts;
      var A = verts[fv[0]], B = verts[fv[1]], C = verts[fv[2]], D = verts[fv[3]];
      return solidAngleTriangle(chargePos, A, B, C) + solidAngleTriangle(chargePos, A, C, D);
    }

    // Precomputed per-face solid angles for each mode
    var cachedFaceFluxFractions = {};
    function computeFaceFluxFractions(mode) {
      var key = mode;
      if (cachedFaceFluxFractions[key]) return cachedFaceFluxFractions[key];
      var cp = getChargePos3D(mode);
      var fracs = [];
      var totalOmega = 0;
      for (var fi = 0; fi < 6; fi++) {
        var omega = Math.abs(solidAngleFace(fi, cp));
        fracs.push(omega);
        totalOmega += omega;
      }
      // Normalize to ensure they sum to the correct total solid angle
      var expectedTotal = mode === 'center' ? 4 * Math.PI : (mode === 'corner' ? Math.PI / 2 : Math.PI);
      for (var fi = 0; fi < 6; fi++) {
        fracs[fi] = fracs[fi] / totalOmega * expectedTotal / (4 * Math.PI);
      }
      cachedFaceFluxFractions[key] = fracs;
      return fracs;
    }

    // === FLUX CALCULATIONS ===
    function getTotalFlux() {
      var Q = CHARGE_MAG * 1e-6 * CHARGE_SIGN;
      if (MODE === 'center') return Q / EPSILON_0;
      if (MODE === 'corner') return Q / (8 * EPSILON_0);
      if (MODE === 'edge')   return Q / (4 * EPSILON_0);
      return 0;
    }

    function getFluxForFace(faceIdx) {
      var Q = CHARGE_MAG * 1e-6 * CHARGE_SIGN;
      var fracs = computeFaceFluxFractions(MODE);
      return Q * fracs[faceIdx] / EPSILON_0;
    }

    // Which faces are adjacent to the charge (flux = 0)?
    function isAdjacentFace(faceIdx, mode) {
      if (mode === 'center') return false;
      // Corner at vertex 6 [s,s,s]: faces containing vertex 6
      // Face 1 (Front [4,5,6,7]), Face 3 (Bottom [2,3,7,6]), Face 5 (Right [1,2,6,5])
      if (mode === 'corner') return faceIdx === 1 || faceIdx === 3 || faceIdx === 5;
      // Edge midpoint [s,0,s]: edge from vertex 5 to vertex 6
      // Faces containing both 5 and 6: Face 1 (Front [4,5,6,7]), Face 5 (Right [1,2,6,5])
      if (mode === 'edge') return faceIdx === 1 || faceIdx === 5;
      return false;
    }

    function getExplanation(mode) {
      if (mode === 'center') return 'The entire charge is enclosed: Q_enc = Q. By symmetry, \u03A6 = Q/\u03B5\u2080 divides equally among all 6 faces, giving Q/6\u03B5\u2080 per face.';
      if (mode === 'corner') return 'Only \u215B of the charge is inside this cube (Q_enc = Q/8). 8 identical cubes tile around the corner to enclose the full charge. The 3 adjacent faces carry zero flux (field is tangential). The 3 opposite faces each get Q/24\u03B5\u2080.';
      if (mode === 'edge')   return 'Only \u00BC of the charge is inside this cube (Q_enc = Q/4). 4 identical cubes tile around the edge to enclose the full charge. The 2 faces sharing the edge carry zero flux. The remaining 4 faces share the total flux.';
      return '';
    }

    // === SIGN TOGGLE ===
    function updateSignBtn() {
      var btn = document.getElementById('signBtn');
      if (CHARGE_SIGN > 0) {
        btn.textContent = '+';
        btn.className = 'sign-btn pos';
      } else {
        btn.textContent = '\u2212';
        btn.className = 'sign-btn neg';
      }
    }

    document.getElementById('signBtn').addEventListener('click', function() {
      CHARGE_SIGN *= -1;
      updateSignBtn();
    });

    // === SLIDER + INPUT SYNC ===
    function syncCharge(val) {
      val = Math.max(1, Math.min(10, parseInt(val) || 1));
      CHARGE_MAG = val;
      document.getElementById('chargeSlider').value = val;
      document.getElementById('chargeInput').value = val;
    }
    document.getElementById('chargeSlider').addEventListener('input', function() { syncCharge(this.value); });
    document.getElementById('chargeInput').addEventListener('input', function() { syncCharge(this.value); });

    // === GHOST CHECKBOX ===
    document.getElementById('ghostCheck').addEventListener('change', function() {
      showGhosts = this.checked;
      if (showGhosts) {
        ghostProgress = 0;
        ghostAnimating = true;
      } else {
        ghostProgress = 0;
        ghostAnimating = false;
      }
    });

    // === MODE SWITCHING ===
    function setMode(newMode) {
      if (MODE === newMode) return;
      chargeFrom = getCurrentChargePos3D();
      chargeTo = getChargePos3D(newMode);
      chargeAnimT = 0;
      MODE = newMode;
      ghostProgress = 0;
      ghostAnimating = showGhosts;
      document.getElementById('modeCenterBtn').className = 'sim-btn' + (newMode === 'center' ? ' active' : '');
      document.getElementById('modeCornerBtn').className = 'sim-btn' + (newMode === 'corner' ? ' active' : '');
      document.getElementById('modeEdgeBtn').className = 'sim-btn' + (newMode === 'edge' ? ' active' : '');
      var ghostCheck = document.getElementById('ghostCheck');
      if (newMode === 'center') {
        ghostCheck.disabled = true;
        ghostCheck.checked = false;
        showGhosts = false;
        ghostProgress = 0;
      } else {
        ghostCheck.disabled = false;
      }
      updateInvestigateBtn();
      updateEquationHighlight();
    }

    document.getElementById('modeCenterBtn').addEventListener('click', function() { setMode('center'); });
    document.getElementById('modeCornerBtn').addEventListener('click', function() { setMode('corner'); });
    document.getElementById('modeEdgeBtn').addEventListener('click', function() { setMode('edge'); });

    // === RESET ===
    function resetAll() {
      CHARGE_MAG = 5;
      CHARGE_SIGN = 1;
      MODE = 'center';
      chargeFrom = [0, 0, 0];
      chargeTo = [0, 0, 0];
      chargeAnimT = 1;
      rotX = 0;
      rotY = 0;
      rotVelX = 0;
      rotVelY = 0;
      ghostProgress = 0;
      ghostAnimating = false;
      showGhosts = false;
      document.getElementById('chargeSlider').value = 5;
      document.getElementById('chargeInput').value = 5;
      var ghostCheck = document.getElementById('ghostCheck');
      ghostCheck.checked = false;
      ghostCheck.disabled = true;
      document.getElementById('modeCenterBtn').className = 'sim-btn active';
      document.getElementById('modeCornerBtn').className = 'sim-btn';
      document.getElementById('modeEdgeBtn').className = 'sim-btn';
      updateSignBtn();
      updateInvestigateBtn();
      updateEquationHighlight();
      if (invOpen) closeInvestigate();
    }

    document.getElementById('resetBtn').addEventListener('click', resetAll);
    document.getElementById('resetArrangement').addEventListener('click', resetAll);

    // === DRAWING ===
    function drawBackground() {
      var grad = ctx.createRadialGradient(canvasW / 2, canvasH / 2, 0, canvasW / 2, canvasH / 2, canvasW * 0.7);
      grad.addColorStop(0, tc.bgCenter);
      grad.addColorStop(1, tc.bg);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvasW, canvasH);

      var isLight = document.documentElement.getAttribute('data-theme') === 'light';
      var gridColor = isLight ? 'rgba(0,0,0,0.05)' : 'rgba(255,255,255,0.035)';
      ctx.strokeStyle = gridColor;
      ctx.lineWidth = 1;
      for (var x = 40; x < canvasW; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvasH);
        ctx.stroke();
      }
      for (var y = 40; y < canvasH; y += 40) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvasW, y);
        ctx.stroke();
      }
    }

    function drawCubeAt(offsetX, offsetY, offsetZ, alpha, wireOnly) {
      var s = CUBE_SIZE;
      var verts = getCubeVertices(s);

      // Apply offset to all vertices
      var rotatedVerts = [];
      for (var i = 0; i < verts.length; i++) {
        var v = [verts[i][0] + offsetX, verts[i][1] + offsetY, verts[i][2] + offsetZ];
        rotatedVerts.push(rotatePoint(v, rotX, rotY));
      }
      var projVerts = [];
      for (var i = 0; i < rotatedVerts.length; i++) {
        projVerts.push(project(rotatedVerts[i]));
      }

      // Painter's algorithm: sort faces by average z depth
      var faceOrder = [];
      for (var fi = 0; fi < FACES.length; fi++) {
        var face = FACES[fi];
        var avgZ = 0;
        for (var vi = 0; vi < face.verts.length; vi++) {
          avgZ += rotatedVerts[face.verts[vi]][2];
        }
        avgZ /= face.verts.length;
        faceOrder.push({ idx: fi, z: avgZ });
      }
      faceOrder.sort(function(a, b) { return a.z - b.z; });

      for (var oi = 0; oi < faceOrder.length; oi++) {
        var fi = faceOrder[oi].idx;
        var face = FACES[fi];
        var pts = [];
        for (var vi = 0; vi < face.verts.length; vi++) {
          pts.push(projVerts[face.verts[vi]]);
        }

        ctx.save();
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for (var pi = 1; pi < pts.length; pi++) {
          ctx.lineTo(pts[pi].x, pts[pi].y);
        }
        ctx.closePath();

        if (wireOnly) {
          // Faint fill for ghost cubes
          ctx.fillStyle = 'rgba(124,58,237,' + (0.04 * alpha) + ')';
          ctx.fill();
        } else {
          // Parse face color and apply alpha
          ctx.fillStyle = face.color.replace('0.12)', (0.12 * alpha) + ')');
          ctx.fill();
        }

        // Wireframe
        ctx.strokeStyle = wireOnly
          ? 'rgba(124,58,237,' + (0.5 * alpha) + ')'
          : 'rgba(124,58,237,' + (0.55 * alpha) + ')';
        ctx.lineWidth = wireOnly ? 1.0 : 1.2;
        ctx.stroke();

        // Face flux label (only for main cube, not ghosts)
        if (!wireOnly && alpha > 0.9) {
          // Back-face culling: compute face normal from rotated vertices
          var rv = face.verts;
          var e1 = [rotatedVerts[rv[1]][0]-rotatedVerts[rv[0]][0], rotatedVerts[rv[1]][1]-rotatedVerts[rv[0]][1], rotatedVerts[rv[1]][2]-rotatedVerts[rv[0]][2]];
          var e2 = [rotatedVerts[rv[3]][0]-rotatedVerts[rv[0]][0], rotatedVerts[rv[3]][1]-rotatedVerts[rv[0]][1], rotatedVerts[rv[3]][2]-rotatedVerts[rv[0]][2]];
          var fnormal = vec3cross(e1, e2);
          if (fnormal[2] > 0) { ctx.restore(); continue; } // back-facing, skip label

          var cx2d = 0, cy2d = 0;
          for (var pi = 0; pi < pts.length; pi++) { cx2d += pts[pi].x; cy2d += pts[pi].y; }
          cx2d /= pts.length;
          cy2d /= pts.length;

          var faceFluxVal = getFluxForFace(fi);
          var fluxLabel = '';
          if (isAdjacentFace(fi, MODE)) {
            fluxLabel = '0';
          } else {
            fluxLabel = formatSci(faceFluxVal);
          }

          ctx.font = 'bold 11px "JetBrains Mono", monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = isAdjacentFace(fi, MODE) ? 'rgba(150,150,150,0.6)' : tc.labelText;
          ctx.fillText(fluxLabel, cx2d, cy2d);
        }

        ctx.restore();
      }

      return { projVerts: projVerts, rotatedVerts: rotatedVerts };
    }

    function drawGhostCubes() {
      var ghostData = [];
      if (!showGhosts && ghostProgress <= 0) return ghostData;
      var offsets = getGhostOffsets(MODE);
      if (offsets.length === 0) return ghostData;

      var prog = ghostProgress;
      for (var gi = 0; gi < offsets.length; gi++) {
        var delay = gi * 0.12;
        var localProg = Math.max(0, Math.min(1, (prog - delay) / 0.5));
        if (localProg <= 0) {
          ghostData.push(null);
          continue;
        }
        var alpha = 0.15 + 0.45 * localProg;
        var result = drawCubeAt(offsets[gi][0], offsets[gi][1], offsets[gi][2], alpha, true);
        ghostData.push({ verts: result.projVerts, alpha: localProg });
      }
      return ghostData;
    }

    function drawFieldLines() {
      var chargePos3D = getCurrentChargePos3D();
      var rotatedCharge = rotatePoint(chargePos3D, rotX, rotY);
      var projCharge = project(rotatedCharge);

      var isPos = CHARGE_SIGN > 0;
      var startR = 12;

      // Fibonacci sphere distribution for even coverage
      var phi_golden = Math.PI * (3 - Math.sqrt(5));
      for (var i = 0; i < NUM_FIELD_LINES; i++) {
        var yi = 1 - (i / (NUM_FIELD_LINES - 1)) * 2;
        var radius = Math.sqrt(1 - yi * yi);
        var theta_fib = phi_golden * i;
        var xi = Math.cos(theta_fib) * radius;
        var zi = Math.sin(theta_fib) * radius;

        // 3D start point near charge surface
        var lineStart3D = [
          chargePos3D[0] + xi * startR,
          chargePos3D[1] + yi * startR,
          chargePos3D[2] + zi * startR
        ];
        var lineEnd3D = [
          chargePos3D[0] + xi * (CUBE_SIZE * 2.5),
          chargePos3D[1] + yi * (CUBE_SIZE * 2.5),
          chargePos3D[2] + zi * (CUBE_SIZE * 2.5)
        ];

        var rotStart = rotatePoint(lineStart3D, rotX, rotY);
        var rotEnd = rotatePoint(lineEnd3D, rotX, rotY);
        var ps = project(rotStart);
        var pe = project(rotEnd);

        ctx.save();
        ctx.strokeStyle = 'rgba(150,150,200,0.15)';
        ctx.lineWidth = 0.8;
        ctx.setLineDash([6, 5]);
        ctx.lineDashOffset = isPos ? -flowPhase * 35 : flowPhase * 35;
        ctx.beginPath();
        ctx.moveTo(ps.x, ps.y);
        ctx.lineTo(pe.x, pe.y);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();

        // Arrowhead direction indicator
        var midX = (ps.x + pe.x) * 0.4;
        var midY = (ps.y + pe.y) * 0.4;
        var angle = Math.atan2(pe.y - ps.y, pe.x - ps.x);
        var arrowAngle = isPos ? angle : angle + Math.PI;
        var headLen = 5;
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(midX + Math.cos(arrowAngle) * headLen, midY + Math.sin(arrowAngle) * headLen);
        ctx.lineTo(midX + Math.cos(arrowAngle + 2.6) * headLen * 0.5, midY + Math.sin(arrowAngle + 2.6) * headLen * 0.5);
        ctx.lineTo(midX + Math.cos(arrowAngle - 2.6) * headLen * 0.5, midY + Math.sin(arrowAngle - 2.6) * headLen * 0.5);
        ctx.closePath();
        ctx.fillStyle = 'rgba(150,150,200,0.18)';
        ctx.fill();
        ctx.restore();

      }
    }

    // === CONVEX HULL (for clipping charge to cube outline) ===
    function hullCross(O, A, B) {
      return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);
    }

    function convexHull2D(points) {
      var pts = points.slice().sort(function(a, b) { return a.x - b.x || a.y - b.y; });
      var n = pts.length;
      if (n <= 2) return pts;
      var lower = [];
      for (var i = 0; i < n; i++) {
        while (lower.length >= 2 && hullCross(lower[lower.length-2], lower[lower.length-1], pts[i]) <= 0) lower.pop();
        lower.push(pts[i]);
      }
      var upper = [];
      for (var i = n - 1; i >= 0; i--) {
        while (upper.length >= 2 && hullCross(upper[upper.length-2], upper[upper.length-1], pts[i]) <= 0) upper.pop();
        upper.push(pts[i]);
      }
      lower.pop();
      upper.pop();
      return lower.concat(upper);
    }

    function applyClipHull(projVerts) {
      var hull = convexHull2D(projVerts);
      ctx.beginPath();
      ctx.moveTo(hull[0].x, hull[0].y);
      for (var i = 1; i < hull.length; i++) ctx.lineTo(hull[i].x, hull[i].y);
      ctx.closePath();
      ctx.clip();
    }

    function drawChargeBody(projCharge, alphaScale) {
      var pulse = 0.5 + 0.5 * Math.sin(glowPhase);
      var r = 14 + (CHARGE_MAG - 1) * 1.5;
      var glowRadius = (22 + (CHARGE_MAG - 1) * 3) + 8 * pulse;
      var glowAlpha = (0.2 + 0.15 * pulse) * alphaScale;
      var isPos = CHARGE_SIGN > 0;

      // Glow
      var glowGrad = ctx.createRadialGradient(projCharge.x, projCharge.y, 0, projCharge.x, projCharge.y, glowRadius);
      if (isPos) {
        glowGrad.addColorStop(0, 'rgba(255,45,117,' + glowAlpha + ')');
        glowGrad.addColorStop(0.6, 'rgba(255,45,117,' + (glowAlpha * 0.4) + ')');
        glowGrad.addColorStop(1, 'rgba(255,45,117,0)');
      } else {
        glowGrad.addColorStop(0, 'rgba(0,212,255,' + glowAlpha + ')');
        glowGrad.addColorStop(0.6, 'rgba(0,212,255,' + (glowAlpha * 0.4) + ')');
        glowGrad.addColorStop(1, 'rgba(0,212,255,0)');
      }
      ctx.beginPath();
      ctx.arc(projCharge.x, projCharge.y, glowRadius, 0, Math.PI * 2);
      ctx.fillStyle = glowGrad;
      ctx.fill();

      // Body
      ctx.beginPath();
      ctx.arc(projCharge.x, projCharge.y, r, 0, Math.PI * 2);
      var bodyGrad = ctx.createRadialGradient(projCharge.x - 3, projCharge.y - 3, 0, projCharge.x, projCharge.y, r);
      if (isPos) {
        bodyGrad.addColorStop(0, 'rgba(255,90,146,' + alphaScale + ')');
        bodyGrad.addColorStop(1, 'rgba(255,45,117,' + alphaScale + ')');
      } else {
        bodyGrad.addColorStop(0, 'rgba(51,224,255,' + alphaScale + ')');
        bodyGrad.addColorStop(1, 'rgba(0,212,255,' + alphaScale + ')');
      }
      ctx.fillStyle = bodyGrad;
      ctx.shadowColor = isPos ? '#ff2d75' : '#00d4ff';
      ctx.shadowBlur = (12 + 6 * pulse) * alphaScale;
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function drawCharge(mainCubeProjVerts, ghostCubesProjVerts) {
      var chargePos3D = getCurrentChargePos3D();
      var rotatedCharge = rotatePoint(chargePos3D, rotX, rotY);
      var projCharge = project(rotatedCharge);

      var isPos = CHARGE_SIGN > 0;
      var r = 14 + (CHARGE_MAG - 1) * 1.5;
      var needsClip = MODE !== 'center';

      if (needsClip && mainCubeProjVerts) {
        // Draw charge clipped to the main cube outline
        ctx.save();
        applyClipHull(mainCubeProjVerts);
        drawChargeBody(projCharge, 1);
        ctx.restore();

        // Draw partial charges inside ghost cubes
        if (ghostCubesProjVerts) {
          for (var gi = 0; gi < ghostCubesProjVerts.length; gi++) {
            var gp = ghostCubesProjVerts[gi];
            if (!gp || gp.alpha <= 0) continue;
            ctx.save();
            applyClipHull(gp.verts);
            drawChargeBody(projCharge, gp.alpha);
            ctx.restore();
          }
        }
      } else {
        // Center mode: draw full charge, no clipping
        drawChargeBody(projCharge, 1);
      }

      // Label showing enclosed fraction
      var signChar = isPos ? '+' : '\u2212';
      ctx.fillStyle = '#fff';
      ctx.font = 'bold ' + (11 + CHARGE_MAG) + 'px "JetBrains Mono", monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(signChar + CHARGE_MAG, projCharge.x, projCharge.y);

      ctx.font = 'bold 10px "Inter", sans-serif';
      ctx.fillStyle = tc.labelText;
      ctx.textBaseline = 'top';
      var qLabel = signChar + 'Q';
      if (MODE === 'corner') qLabel = 'Qenc = Q/8';
      else if (MODE === 'edge') qLabel = 'Qenc = Q/4';
      ctx.fillText(qLabel, projCharge.x, projCharge.y + r + 4);
    }

    function drawModeBadge() {
      var modeLabel = MODE.charAt(0).toUpperCase() + MODE.slice(1);
      var cubeInfo = '';
      if (MODE === 'corner') cubeInfo = ' \u2022 1 of 8 cubes \u2022 Qenc = Q/8';
      else if (MODE === 'edge') cubeInfo = ' \u2022 1 of 4 cubes \u2022 Qenc = Q/4';
      else cubeInfo = ' \u2022 Qenc = Q';
      var badgeText = modeLabel + cubeInfo;

      ctx.font = 'bold 11px "Inter", sans-serif';
      var tw = ctx.measureText(badgeText).width;
      var pw = tw + 20;
      var ph = 26;
      var bx = canvasW - pw - 14;
      var by = 14;

      ctx.save();
      roundedRect(ctx, bx, by, pw, ph, 13);
      ctx.fillStyle = tc.labelBg;
      ctx.fill();
      ctx.strokeStyle = 'rgba(124,58,237,0.35)';
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.fillStyle = tc.labelText;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(badgeText, bx + pw / 2, by + ph / 2);
      ctx.restore();
    }

    function updateDataPanel() {
      var Q = CHARGE_MAG * 1e-6 * CHARGE_SIGN;
      var totalFlux = getTotalFlux();
      var signChar = CHARGE_SIGN > 0 ? '+' : '\u2212';

      document.getElementById('dataFluxTotal').textContent = formatSci(totalFlux) + ' N\u00B7m\u00B2/C';

      // Per-face display
      var faceEl = document.getElementById('dataFluxFace');
      if (MODE === 'center') {
        faceEl.textContent = formatSci(getFluxForFace(0)) + ' N\u00B7m\u00B2/C (each)';
      } else if (MODE === 'corner') {
        var oppFlux = getFluxForFace(0); // face 0 is non-adjacent
        faceEl.innerHTML = '0 (3 adjacent)<br>' + formatSci(oppFlux) + ' (3 opposite)';
      } else if (MODE === 'edge') {
        // 2 adjacent (0 flux), 4 non-adjacent with 2 pairs of symmetry
        var f0 = getFluxForFace(0); // Back
        var f2 = getFluxForFace(2); // Top
        faceEl.innerHTML = '0 (2 adjacent)<br>' +
          formatSci(f2) + ' (Top, Bottom)<br>' +
          formatSci(f0) + ' (Back, Left)';
      }

      document.getElementById('dataCharge').textContent = signChar + CHARGE_MAG + ' \u00B5C';
      document.getElementById('dataMode').textContent = MODE.charAt(0).toUpperCase() + MODE.slice(1);

      var sub = document.getElementById('dataSubstitution');
      if (MODE === 'center') {
        sub.innerHTML =
          '\u03A6 = Q<sub>enc</sub> / \u03B5\u2080 = Q / \u03B5\u2080' +
          '<br>= ' + formatSci(Q) + ' / \u03B5\u2080' +
          '<br><span class="hl">= ' + formatSci(totalFlux) + ' N\u00B7m\u00B2/C</span>';
      } else if (MODE === 'corner') {
        sub.innerHTML =
          'Q<sub>enc</sub> = Q/8 (only \u215B of charge inside cube)' +
          '<br>\u03A6 = Q<sub>enc</sub> / \u03B5\u2080 = Q / 8\u03B5\u2080' +
          '<br>= ' + formatSci(Q) + ' / 8\u03B5\u2080' +
          '<br><span class="hl">= ' + formatSci(totalFlux) + ' N\u00B7m\u00B2/C</span>';
      } else {
        sub.innerHTML =
          'Q<sub>enc</sub> = Q/4 (only \u00BC of charge inside cube)' +
          '<br>\u03A6 = Q<sub>enc</sub> / \u03B5\u2080 = Q / 4\u03B5\u2080' +
          '<br>= ' + formatSci(Q) + ' / 4\u03B5\u2080' +
          '<br><span class="hl">= ' + formatSci(totalFlux) + ' N\u00B7m\u00B2/C</span>';
      }

      document.getElementById('explainText').textContent = getExplanation(MODE);
    }

    function drawTangentArrows() {
      if (MODE !== 'corner' && MODE !== 'edge') return;
      var s = CUBE_SIZE;
      var chargePos3D = getCurrentChargePos3D();
      // Face centroids and normals
      var faceCentroids = [
        [0, 0, -s], // Back
        [0, 0,  s], // Front
        [0, -s, 0], // Top
        [0,  s, 0], // Bottom
        [-s, 0, 0], // Left
        [ s, 0, 0]  // Right
      ];
      var faceNormals = [
        [0, 0, -1], // Back
        [0, 0,  1], // Front
        [0, -1, 0], // Top
        [0,  1, 0], // Bottom
        [-1, 0, 0], // Left
        [ 1, 0, 0]  // Right
      ];
      for (var fi = 0; fi < 6; fi++) {
        if (!isAdjacentFace(fi, MODE)) continue;
        var centroid = faceCentroids[fi];
        var normal = faceNormals[fi];
        // E-field direction at centroid
        var diff = vec3sub(centroid, chargePos3D);
        var dlen = vec3len(diff);
        if (dlen < 1e-10) continue;
        var dir = [diff[0]/dlen, diff[1]/dlen, diff[2]/dlen];
        // Project onto face plane: tangent = dir - dot(dir, normal)*normal
        var dn = vec3dot(dir, normal);
        var tangent = [dir[0] - dn*normal[0], dir[1] - dn*normal[1], dir[2] - dn*normal[2]];
        var tlen = vec3len(tangent);
        if (tlen < 1e-10) continue;
        tangent = [tangent[0]/tlen, tangent[1]/tlen, tangent[2]/tlen];
        // Scale to 25px in 3D terms (use canvas units roughly)
        var arrowScale = 30;
        var endPoint3D = [centroid[0] + tangent[0]*arrowScale, centroid[1] + tangent[1]*arrowScale, centroid[2] + tangent[2]*arrowScale];
        // Project both centroid and endpoint
        var rotCentroid = rotatePoint(centroid, rotX, rotY);
        var rotEnd = rotatePoint(endPoint3D, rotX, rotY);
        var pCentroid = project(rotCentroid);
        var pEnd = project(rotEnd);
        // Draw arrow
        var dx = pEnd.x - pCentroid.x;
        var dy = pEnd.y - pCentroid.y;
        var len2d = Math.sqrt(dx*dx + dy*dy);
        if (len2d < 2) continue;
        ctx.save();
        ctx.strokeStyle = 'rgba(180,180,180,0.7)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(pCentroid.x, pCentroid.y);
        ctx.lineTo(pEnd.x, pEnd.y);
        ctx.stroke();
        // Arrowhead
        var aAngle = Math.atan2(dy, dx);
        var hLen = 7;
        ctx.beginPath();
        ctx.moveTo(pEnd.x, pEnd.y);
        ctx.lineTo(pEnd.x - hLen*Math.cos(aAngle-0.4), pEnd.y - hLen*Math.sin(aAngle-0.4));
        ctx.lineTo(pEnd.x - hLen*Math.cos(aAngle+0.4), pEnd.y - hLen*Math.sin(aAngle+0.4));
        ctx.closePath();
        ctx.fillStyle = 'rgba(180,180,180,0.7)';
        ctx.fill();
        // Label "E âˆ¥ face"
        ctx.font = '9px Inter, sans-serif';
        ctx.fillStyle = 'rgba(180,180,180,0.85)';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        var labelX = pEnd.x + Math.cos(aAngle)*12;
        var labelY = pEnd.y + Math.sin(aAngle)*12;
        ctx.fillText('E \u2225 face', labelX, labelY);
        ctx.restore();
      }
    }

    function drawAxisTriad() {
      var originX = canvasW - 50;
      var originY = canvasH - 50;
      var axisLen = 25;
      var axes = [
        { dir: [1,0,0], color: '#ff4444', label: 'X' },
        { dir: [0,1,0], color: '#44ff44', label: 'Y' },
        { dir: [0,0,1], color: '#4488ff', label: 'Z' }
      ];
      for (var i = 0; i < axes.length; i++) {
        var rotated = rotatePoint(axes[i].dir, rotX, rotY);
        var ex = originX + rotated[0] * axisLen;
        var ey = originY + rotated[1] * axisLen;
        ctx.beginPath();
        ctx.moveTo(originX, originY);
        ctx.lineTo(ex, ey);
        ctx.strokeStyle = axes[i].color;
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = axes[i].color;
        ctx.font = 'bold 10px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(axes[i].label, ex + (rotated[0] > 0 ? 8 : -8), ey + (rotated[1] > 0 ? 8 : -8));
      }
    }

    function drawFrame() {
      if (!canvasW || !canvasH) return;
      drawBackground();
      drawFieldLines();
      var ghostData = drawGhostCubes();
      var mainCube = drawCubeAt(0, 0, 0, 1, false);
      drawTangentArrows();
      drawCharge(mainCube.projVerts, ghostData);
      drawModeBadge();
      drawAxisTriad();
      updateDataPanel();
    }

    // === DRAG ROTATION ===
    canvas.addEventListener('mousedown', function(e) {
      dragging = true;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      rotVelX = 0;
      rotVelY = 0;
    });

    window.addEventListener('mousemove', function(e) {
      if (!dragging) return;
      var dx = e.clientX - lastMouseX;
      var dy = e.clientY - lastMouseY;
      rotY += dx * 0.005;
      rotX += dy * 0.005;
      rotVelY = dx * 0.005;
      rotVelX = dy * 0.005;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    });

    window.addEventListener('mouseup', function() {
      dragging = false;
    });

    canvas.addEventListener('touchstart', function(e) {
      if (e.touches.length === 1) {
        dragging = true;
        lastMouseX = e.touches[0].clientX;
        lastMouseY = e.touches[0].clientY;
        rotVelX = 0;
        rotVelY = 0;
      }
    }, { passive: true });

    canvas.addEventListener('touchmove', function(e) {
      if (!dragging || e.touches.length !== 1) return;
      var dx = e.touches[0].clientX - lastMouseX;
      var dy = e.touches[0].clientY - lastMouseY;
      rotY += dx * 0.005;
      rotX += dy * 0.005;
      rotVelY = dx * 0.005;
      rotVelX = dy * 0.005;
      lastMouseX = e.touches[0].clientX;
      lastMouseY = e.touches[0].clientY;
    }, { passive: true });

    canvas.addEventListener('touchend', function() {
      dragging = false;
    });

    // === CAMERA CONTROLS ===
    var CAM_STEP = 0.15;
    document.getElementById('camUp').addEventListener('click', function() { rotX -= CAM_STEP; rotVelX = rotVelY = 0; });
    document.getElementById('camDown').addEventListener('click', function() { rotX += CAM_STEP; rotVelX = rotVelY = 0; });
    document.getElementById('camLeft').addEventListener('click', function() { rotY -= CAM_STEP; rotVelX = rotVelY = 0; });
    document.getElementById('camRight').addEventListener('click', function() { rotY += CAM_STEP; rotVelX = rotVelY = 0; });
    document.getElementById('camStab').addEventListener('click', function() { rotX = 0; rotY = 0; rotVelX = rotVelY = 0; });

    // === KEYBOARD SHORTCUTS ===
    window.addEventListener('keydown', function(e) {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
      if (invOpen) return;
      switch(e.key) {
        case 'ArrowUp': rotX -= CAM_STEP; rotVelX = rotVelY = 0; e.preventDefault(); break;
        case 'ArrowDown': rotX += CAM_STEP; rotVelX = rotVelY = 0; e.preventDefault(); break;
        case 'ArrowLeft': rotY -= CAM_STEP; rotVelX = rotVelY = 0; e.preventDefault(); break;
        case 'ArrowRight': rotY += CAM_STEP; rotVelX = rotVelY = 0; e.preventDefault(); break;
        case 'r': case 'R': rotX = 0; rotY = 0; rotVelX = rotVelY = 0; break;
      }
    });

    // === INVESTIGATE OVERLAY ===
    var invCanvas = document.getElementById('investigateCanvas');
    var invCtx = invCanvas.getContext('2d');
    var invOpen = false;
    var invRotX = -0.5, invRotY = 0.7;
    var invDragging = false;
    var invLastX = 0, invLastY = 0;

    function updateInvestigateBtn() {
      var btn = document.getElementById('investigateBtn');
      var sep = document.getElementById('investigateSep');
      if (MODE === 'corner') {
        btn.style.display = '';
        sep.style.display = '';
        btn.textContent = 'Why Q/8?';
      } else if (MODE === 'edge') {
        btn.style.display = '';
        sep.style.display = '';
        btn.textContent = 'Why Q/4?';
      } else {
        btn.style.display = 'none';
        sep.style.display = 'none';
      }
    }

    function openInvestigate() {
      invOpen = true;
      invRotX = -0.5;
      invRotY = 0.7;
      var el = document.getElementById('investigateOverlay');
      el.style.display = '';
      el.style.opacity = '0';
      el.offsetHeight;
      el.style.opacity = '1';

      // Set title and label based on mode
      if (MODE === 'corner') {
        document.getElementById('investigateTitle').textContent = 'Why Q/8?';
        document.getElementById('investigateLabel').innerHTML =
          'A corner is shared by <strong>8 cubes</strong>. The charge sits at the intersection of 3 planes that divide the sphere into 8 equal octants. Each cube encloses exactly <strong>one octant = \u215B of the charge</strong>.';
      } else {
        document.getElementById('investigateTitle').textContent = 'Why Q/4?';
        document.getElementById('investigateLabel').innerHTML =
          'An edge is shared by <strong>4 cubes</strong>. The charge sits at the intersection of 2 planes that divide the sphere into 4 equal slices. Each cube encloses exactly <strong>one slice = \u00BC of the charge</strong>.';
      }

      resizeInvCanvas();
    }

    function closeInvestigate() {
      var el = document.getElementById('investigateOverlay');
      el.style.opacity = '0';
      setTimeout(function() { el.style.display = 'none'; invOpen = false; }, 400);
    }

    function resizeInvCanvas() {
      var el = document.getElementById('investigateOverlay');
      var w = Math.min(500, el.clientWidth * 0.85);
      var h = Math.min(400, el.clientHeight * 0.5);
      var dpr = window.devicePixelRatio || 1;
      invCanvas.width = w * dpr;
      invCanvas.height = h * dpr;
      invCanvas.style.width = w + 'px';
      invCanvas.style.height = h + 'px';
      invCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    document.getElementById('investigateBtn').addEventListener('click', openInvestigate);
    document.getElementById('investigateClose').addEventListener('click', closeInvestigate);

    // Drag rotation for investigate canvas
    invCanvas.addEventListener('mousedown', function(e) {
      invDragging = true;
      invLastX = e.clientX;
      invLastY = e.clientY;
    });
    window.addEventListener('mousemove', function(e) {
      if (!invDragging) return;
      invRotY += (e.clientX - invLastX) * 0.008;
      invRotX += (e.clientY - invLastY) * 0.008;
      invLastX = e.clientX;
      invLastY = e.clientY;
    });
    window.addEventListener('mouseup', function() { invDragging = false; });
    invCanvas.addEventListener('touchstart', function(e) {
      if (e.touches.length === 1) {
        invDragging = true;
        invLastX = e.touches[0].clientX;
        invLastY = e.touches[0].clientY;
      }
    }, { passive: true });
    invCanvas.addEventListener('touchmove', function(e) {
      if (!invDragging || e.touches.length !== 1) return;
      invRotY += (e.touches[0].clientX - invLastX) * 0.008;
      invRotX += (e.touches[0].clientY - invLastY) * 0.008;
      invLastX = e.touches[0].clientX;
      invLastY = e.touches[0].clientY;
    }, { passive: true });
    invCanvas.addEventListener('touchend', function() { invDragging = false; });

    // === INVESTIGATE 3D SPHERE RENDERING ===
    function invProject(p, cx, cy, fov) {
      var scale = fov / (fov + p[2]);
      return { x: cx + p[0] * scale, y: cy + p[1] * scale, scale: scale, z: p[2] };
    }

    function drawInvestigateFrame() {
      if (!invOpen) return;
      var w = parseInt(invCanvas.style.width);
      var h = parseInt(invCanvas.style.height);
      if (!w || !h) return;

      var cx = w / 2, cy = h / 2;
      var R = Math.min(w, h) * 0.34;
      var fov = 400;
      var isPos = CHARGE_SIGN > 0;
      var isCorner = (MODE === 'corner');
      var divisions = isCorner ? 8 : 4;

      // Background
      invCtx.clearRect(0, 0, w, h);
      var bgGrad = invCtx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(w, h) * 0.7);
      var isLight = document.documentElement.getAttribute('data-theme') === 'light';
      if (isLight) {
        bgGrad.addColorStop(0, 'rgba(235, 230, 250, 1)');
        bgGrad.addColorStop(1, 'rgba(215, 215, 235, 1)');
      } else {
        bgGrad.addColorStop(0, 'rgba(20, 15, 40, 1)');
        bgGrad.addColorStop(1, 'rgba(8, 8, 20, 1)');
      }
      invCtx.fillStyle = bgGrad;
      invCtx.fillRect(0, 0, w, h);

      // Project center
      var center3D = rotatePoint([0, 0, 0], invRotX, invRotY);
      var projCenter = invProject(center3D, cx, cy, fov);
      var projR = R * projCenter.scale;

      // Draw sphere background (faint outline)
      invCtx.beginPath();
      invCtx.arc(projCenter.x, projCenter.y, projR, 0, Math.PI * 2);
      invCtx.fillStyle = isLight ? 'rgba(80, 60, 140, 0.05)' : 'rgba(80, 60, 140, 0.08)';
      invCtx.fill();
      invCtx.strokeStyle = isLight ? 'rgba(124, 58, 237, 0.35)' : 'rgba(124, 58, 237, 0.25)';
      invCtx.lineWidth = 1.5;
      invCtx.stroke();

      // === DRAW OCTANT/QUADRANT PATCHES ===
      var STEPS = 24;
      if (isCorner) {
        // 8 octants: divided by XY, YZ, XZ planes
        // Octant signs: each combination of (+/- x, +/- y, +/- z)
        var octants = [
          [1,1,1],[1,1,-1],[1,-1,1],[1,-1,-1],
          [-1,1,1],[-1,1,-1],[-1,-1,1],[-1,-1,-1]
        ];
        for (var oi = 0; oi < 8; oi++) {
          var sx = octants[oi][0], sy = octants[oi][1], sz = octants[oi][2];
          var isHighlighted = (sx > 0 && sy > 0 && sz > 0); // octant matching corner [+s,+s,+s]
          drawOctantPatch(invCtx, cx, cy, R, fov, sx, sy, sz, isHighlighted, isPos, STEPS);
        }
      } else {
        // 4 quadrants: divided by XZ and YZ planes (edge along Y at x=+s, z=+s)
        // Actually: edge at [s,0,s] means the 2 dividing planes are x=0 and z=0
        var quads = [[1,1],[1,-1],[-1,1],[-1,-1]]; // [sign_x, sign_z]
        for (var qi = 0; qi < 4; qi++) {
          var qsx = quads[qi][0], qsz = quads[qi][1];
          var isHighlighted = (qsx > 0 && qsz > 0); // quadrant matching edge [+s,*,+s]
          drawQuadrantPatch(invCtx, cx, cy, R, fov, qsx, qsz, isHighlighted, isPos, STEPS);
        }
      }

      // === DRAW GREAT CIRCLES ===
      var gcPlanes = isCorner
        ? [[0,1,0],[1,0,0],[0,0,1]] // XZ, YZ, XY normal vectors
        : [[1,0,0],[0,0,1]];        // YZ, XY normals (dividing x and z)

      for (var gi = 0; gi < gcPlanes.length; gi++) {
        drawGreatCircle(invCtx, cx, cy, R, fov, gcPlanes[gi], isLight);
      }

      // === DRAW WIREFRAME CUBE AROUND HIGHLIGHTED OCTANT ===
      drawHighlightCube(invCtx, cx, cy, R, fov, isCorner);

      // === LABEL ON HIGHLIGHTED REGION ===
      var labelPos3D;
      if (isCorner) {
        labelPos3D = [R * 0.45, R * 0.45, R * 0.45];
      } else {
        labelPos3D = [R * 0.5, 0, R * 0.5];
      }
      var rotLabel = rotatePoint(labelPos3D, invRotX, invRotY);
      var projLabel = invProject(rotLabel, cx, cy, fov);
      invCtx.font = 'bold 18px "JetBrains Mono", monospace';
      invCtx.textAlign = 'center';
      invCtx.textBaseline = 'middle';
      invCtx.fillStyle = isLight ? '#333' : '#fff';
      invCtx.shadowColor = isLight ? 'rgba(255,255,255,0.7)' : 'rgba(0,0,0,0.7)';
      invCtx.shadowBlur = 6;
      invCtx.fillText(isCorner ? '1/8' : '1/4', projLabel.x, projLabel.y);
      invCtx.shadowBlur = 0;
    }

    function drawOctantPatch(ctx2, cx, cy, R, fov, sx, sy, sz, highlighted, isPos, steps) {
      // Draw a spherical triangle patch for one octant
      // The octant is bounded by 3 great-circle arcs on the axes planes
      // We fill it by sweeping: for each latitude strip, draw a filled region
      var pts = [];
      var S = steps;

      // Generate boundary points of the octant on the sphere surface
      // Arc 1: from (sx,0,0) to (0,sy,0) on z=0 plane
      // Arc 2: from (0,sy,0) to (0,0,sz) on x=0 plane
      // Arc 3: from (0,0,sz) to (sx,0,0) on y=0 plane
      // Instead, fill using spherical coordinates within the octant
      for (var i = 0; i <= S; i++) {
        var theta = (i / S) * Math.PI / 2; // 0 to pi/2
        for (var j = 0; j <= S; j++) {
          var phi = (j / S) * Math.PI / 2; // 0 to pi/2
          var x = R * Math.sin(theta) * Math.cos(phi) * sx;
          var y = R * Math.sin(theta) * Math.sin(phi) * sy;
          var z = R * Math.cos(theta) * sz;
          var rp = rotatePoint([x, y, z], invRotX, invRotY);
          pts.push(invProject(rp, cx, cy, fov));
        }
      }

      // Draw filled triangles for the patch
      var color = highlighted
        ? (isPos ? 'rgba(255, 45, 117, 0.35)' : 'rgba(0, 212, 255, 0.35)')
        : 'rgba(124, 58, 237, 0.06)';

      for (var i = 0; i < S; i++) {
        for (var j = 0; j < S; j++) {
          var idx00 = i * (S + 1) + j;
          var idx10 = (i + 1) * (S + 1) + j;
          var idx01 = i * (S + 1) + j + 1;
          var idx11 = (i + 1) * (S + 1) + j + 1;

          // Check if front-facing (average z)
          var avgZ = (pts[idx00].z + pts[idx10].z + pts[idx01].z + pts[idx11].z) / 4;

          ctx2.beginPath();
          ctx2.moveTo(pts[idx00].x, pts[idx00].y);
          ctx2.lineTo(pts[idx10].x, pts[idx10].y);
          ctx2.lineTo(pts[idx11].x, pts[idx11].y);
          ctx2.lineTo(pts[idx01].x, pts[idx01].y);
          ctx2.closePath();

          if (avgZ < 0) {
            // Front face
            ctx2.fillStyle = color;
          } else {
            // Back face â€” dimmer
            ctx2.fillStyle = highlighted
              ? (isPos ? 'rgba(255, 45, 117, 0.08)' : 'rgba(0, 212, 255, 0.08)')
              : 'rgba(124, 58, 237, 0.02)';
          }
          ctx2.fill();
        }
      }
    }

    function drawQuadrantPatch(ctx2, cx, cy, R, fov, sx, sz, highlighted, isPos, steps) {
      // A quadrant slice: x has sign sx, z has sign sz, y goes from -R to +R
      var pts = [];
      var S = steps;

      for (var i = 0; i <= S; i++) {
        var phi = (i / S) * Math.PI / 2; // angle in xz plane, 0 to pi/2
        for (var j = 0; j <= S * 2; j++) {
          var theta = (j / (S * 2)) * Math.PI; // 0 to pi (pole to pole)
          var x = R * Math.sin(theta) * Math.cos(phi) * sx;
          var z = R * Math.sin(theta) * Math.sin(phi) * sz;
          var y = R * Math.cos(theta); // -R to +R
          var rp = rotatePoint([x, y, z], invRotX, invRotY);
          pts.push(invProject(rp, cx, cy, fov));
        }
      }

      var color = highlighted
        ? (isPos ? 'rgba(255, 45, 117, 0.35)' : 'rgba(0, 212, 255, 0.35)')
        : 'rgba(124, 58, 237, 0.06)';

      var cols = S * 2 + 1;
      for (var i = 0; i < S; i++) {
        for (var j = 0; j < S * 2; j++) {
          var idx00 = i * cols + j;
          var idx10 = (i + 1) * cols + j;
          var idx01 = i * cols + j + 1;
          var idx11 = (i + 1) * cols + j + 1;

          var avgZ = (pts[idx00].z + pts[idx10].z + pts[idx01].z + pts[idx11].z) / 4;

          ctx2.beginPath();
          ctx2.moveTo(pts[idx00].x, pts[idx00].y);
          ctx2.lineTo(pts[idx10].x, pts[idx10].y);
          ctx2.lineTo(pts[idx11].x, pts[idx11].y);
          ctx2.lineTo(pts[idx01].x, pts[idx01].y);
          ctx2.closePath();

          if (avgZ < 0) {
            ctx2.fillStyle = color;
          } else {
            ctx2.fillStyle = highlighted
              ? (isPos ? 'rgba(255, 45, 117, 0.08)' : 'rgba(0, 212, 255, 0.08)')
              : 'rgba(124, 58, 237, 0.02)';
          }
          ctx2.fill();
        }
      }
    }

    function drawGreatCircle(ctx2, cx, cy, R, fov, normal, isLightTheme) {
      // Draw a great circle with the given normal vector
      // Find two orthogonal vectors in the plane
      var nx = normal[0], ny = normal[1], nz = normal[2];
      var u, v;
      if (Math.abs(nx) < 0.9) {
        u = [0, -nz, ny]; // cross(normal, [1,0,0]) or similar
      } else {
        u = [nz, 0, -nx];
      }
      var uLen = Math.sqrt(u[0]*u[0] + u[1]*u[1] + u[2]*u[2]);
      u = [u[0]/uLen, u[1]/uLen, u[2]/uLen];
      v = vec3cross(normal, u);

      var pts = [];
      var N = 80;
      for (var i = 0; i <= N; i++) {
        var angle = (i / N) * Math.PI * 2;
        var px = R * (Math.cos(angle) * u[0] + Math.sin(angle) * v[0]);
        var py = R * (Math.cos(angle) * u[1] + Math.sin(angle) * v[1]);
        var pz = R * (Math.cos(angle) * u[2] + Math.sin(angle) * v[2]);
        var rp = rotatePoint([px, py, pz], invRotX, invRotY);
        pts.push(invProject(rp, cx, cy, fov));
      }

      // Draw front arcs solid, back arcs dashed
      for (var i = 0; i < N; i++) {
        var isFront = pts[i].z < 0 && pts[i+1].z < 0;
        ctx2.beginPath();
        ctx2.moveTo(pts[i].x, pts[i].y);
        ctx2.lineTo(pts[i+1].x, pts[i+1].y);
        ctx2.strokeStyle = isLightTheme
          ? (isFront ? 'rgba(80, 40, 160, 0.6)' : 'rgba(80, 40, 160, 0.15)')
          : (isFront ? 'rgba(200, 180, 255, 0.6)' : 'rgba(200, 180, 255, 0.15)');
        ctx2.lineWidth = isFront ? 1.5 : 0.8;
        if (!isFront) {
          ctx2.setLineDash([3, 4]);
        }
        ctx2.stroke();
        ctx2.setLineDash([]);
      }
    }

    function drawHighlightCube(ctx2, cx, cy, R, fov, isCorner) {
      // Draw a wireframe cube aligned to the highlighted octant/quadrant
      var s = R * 0.72; // cube half-side, slightly smaller than sphere radius
      var cubeVerts;
      if (isCorner) {
        // Cube corner at origin, extends to [+s, +s, +s]
        cubeVerts = [
          [0,0,0],[s,0,0],[s,s,0],[0,s,0],
          [0,0,s],[s,0,s],[s,s,s],[0,s,s]
        ];
      } else {
        // Cube edge at origin: extends [0, -s, 0] to [s, s, s]
        cubeVerts = [
          [0,-s,0],[s,-s,0],[s,s,0],[0,s,0],
          [0,-s,s],[s,-s,s],[s,s,s],[0,s,s]
        ];
      }

      var edges = [
        [0,1],[1,2],[2,3],[3,0],
        [4,5],[5,6],[6,7],[7,4],
        [0,4],[1,5],[2,6],[3,7]
      ];

      var projVerts = [];
      for (var i = 0; i < cubeVerts.length; i++) {
        var rp = rotatePoint(cubeVerts[i], invRotX, invRotY);
        projVerts.push(invProject(rp, cx, cy, fov));
      }

      ctx2.strokeStyle = 'rgba(255, 255, 255, 0.35)';
      ctx2.lineWidth = 1;
      ctx2.setLineDash([4, 4]);
      for (var ei = 0; ei < edges.length; ei++) {
        var a = projVerts[edges[ei][0]], b = projVerts[edges[ei][1]];
        ctx2.beginPath();
        ctx2.moveTo(a.x, a.y);
        ctx2.lineTo(b.x, b.y);
        ctx2.stroke();
      }
      ctx2.setLineDash([]);
    }

    // === ANIMATION LOOP ===
    var animRunning = false;

    function animLoop() {
      if (!animRunning) return;
      glowPhase += 0.02;
      flowPhase += 0.012;
      if (glowPhase > Math.PI * 2) glowPhase -= Math.PI * 2;

      // Rotation momentum damping
      if (!dragging) {
        rotX += rotVelX;
        rotY += rotVelY;
        rotVelX *= 0.96;
        rotVelY *= 0.96;
        if (Math.abs(rotVelX) < 0.0001) rotVelX = 0;
        if (Math.abs(rotVelY) < 0.0001) rotVelY = 0;
      }

      // Charge position lerp
      if (chargeAnimT < 1) {
        chargeAnimT = Math.min(1, chargeAnimT + 0.03);
      }

      // Ghost cube animation
      if (ghostAnimating && ghostProgress < 1) {
        ghostProgress = Math.min(1, ghostProgress + 0.015);
      }

      // Achievement timers
      modeTimers[MODE] += 1 / 60;
      if (modeTimers.center >= 2) _achGaussCenter = true;
      if (modeTimers.corner >= 2) _achGaussCorner = true;
      if (modeTimers.edge >= 2)   _achGaussEdge = true;

      drawFrame();
      drawInvestigateFrame();

      requestAnimationFrame(animLoop);
    }

    function startAnim() {
      if (!animRunning) {
        animRunning = true;
        requestAnimationFrame(animLoop);
      }
    }

    // === FULLSCREEN ===
    document.getElementById('fullscreenBtn').addEventListener('click', function() {
      var el = document.getElementById('simArea');
      if (!document.fullscreenElement) {
        (el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen).call(el);
      } else {
        (document.exitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen).call(document);
      }
    });

    document.addEventListener('fullscreenchange', function() {
      setTimeout(function() { resizeCanvas(); if (invOpen) resizeInvCanvas(); }, 100);
      setTimeout(function() { resizeCanvas(); if (invOpen) resizeInvCanvas(); }, 300);
    });

    // === TUTORIAL OVERLAY ===
    function drawCurvedArrow(svg, x1, y1, x2, y2) {
      var ns = 'http://www.w3.org/2000/svg';
      var dx = x2 - x1;
      var dy = y2 - y1;
      var cx1 = x1 + dx * 0.2;
      var cy1 = y1 + dy * 0.6;
      var cx2 = x1 + dx * 0.8;
      var cy2 = y1 + dy * 0.4;

      var path = document.createElementNS(ns, 'path');
      path.setAttribute('d',
        'M' + x1 + ',' + y1 +
        ' C' + cx1 + ',' + cy1 +
        ' ' + cx2 + ',' + cy2 +
        ' ' + x2 + ',' + y2
      );
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke', 'rgba(255,255,255,0.85)');
      path.setAttribute('stroke-width', '2');
      path.setAttribute('stroke-linecap', 'round');
      svg.appendChild(path);

      var angle = Math.atan2(y2 - cy2, x2 - cx2);
      var headLen = 10;
      var a1x = x2 - headLen * Math.cos(angle - 0.4);
      var a1y = y2 - headLen * Math.sin(angle - 0.4);
      var a2x = x2 - headLen * Math.cos(angle + 0.4);
      var a2y = y2 - headLen * Math.sin(angle + 0.4);
      var arrow = document.createElementNS(ns, 'polygon');
      arrow.setAttribute('points',
        x2 + ',' + y2 + ' ' +
        a1x + ',' + a1y + ' ' +
        a2x + ',' + a2y
      );
      arrow.setAttribute('fill', 'rgba(255,255,255,0.85)');
      svg.appendChild(arrow);
    }

    function positionTutorialHints() {
      var area = document.getElementById('simArea');
      var areaRect = area.getBoundingClientRect();
      var svg = document.getElementById('tutArrowsSvg');
      svg.innerHTML = '';

      var targets = [
        { hint: 'tutHintMode',   el: document.querySelector('.mode-btn-group'), type: 'bottom' },
        { hint: 'tutHintCanvas', el: document.getElementById('simCanvas'),       type: 'canvas' },
        { hint: 'tutHintData',   el: document.querySelector('.side-data'),        type: 'bottom' },
        { hint: 'tutHintGhost',  el: document.getElementById('ghostCheck'),       type: 'bottom' }
      ];

      var placed = [];

      for (var i = 0; i < targets.length; i++) {
        var t = targets[i];
        var hintEl = document.getElementById(t.hint);
        if (!t.el) continue;
        var elRect = t.el.getBoundingClientRect();
        var cx = elRect.left + elRect.width / 2 - areaRect.left;
        var cy = elRect.top - areaRect.top;

        if (t.type === 'canvas') {
          var midX = elRect.left + elRect.width / 2 - areaRect.left;
          var midY = elRect.top + elRect.height * 0.35 - areaRect.top;
          hintEl.style.left = midX + 'px';
          hintEl.style.top = midY + 'px';
          hintEl.style.transform = 'translateX(-50%)';
          hintEl.style.right = '';
          continue;
        }

        hintEl.style.left = cx + 'px';
        hintEl.style.transform = 'translateX(-50%)';
        hintEl.style.top = '0px';

        var hintRect = hintEl.getBoundingClientRect();
        var hintW = hintRect.width;
        var hintH = hintRect.height;

        var desiredTop = cy - 50;
        var hintLeft = cx - hintW / 2;
        var hintRight = hintLeft + hintW;

        var finalTop = desiredTop;
        for (var j = 0; j < placed.length; j++) {
          var p = placed[j];
          if (hintRight > p.left && hintLeft < p.right) {
            if (finalTop + hintH > p.top && finalTop < p.bottom) {
              finalTop = p.top - hintH - 8;
            }
          }
        }

        hintEl.style.top = finalTop + 'px';
        placed.push({
          left: hintLeft,
          right: hintRight,
          top: finalTop,
          bottom: finalTop + hintH
        });

        var arrowStartX = cx;
        var arrowStartY = finalTop + hintH + 2;
        var arrowEndX = cx;
        var arrowEndY = cy + 2;
        drawCurvedArrow(svg, arrowStartX, arrowStartY, arrowEndX, arrowEndY);
      }
    }

    function showTutorial() {
      var el = document.getElementById('simTutorial');
      el.style.display = '';
      el.offsetHeight;
      el.style.opacity = '1';
      positionTutorialHints();
    }

    window.addEventListener('resize', function() {
      if (document.getElementById('simTutorial').style.display !== 'none') {
        positionTutorialHints();
      }
    });

    function dismissTutorial() {
      var el = document.getElementById('simTutorial');
      el.style.opacity = '0';
      setTimeout(function() { el.style.display = 'none'; }, 400);
      localStorage.setItem('tut-gauss-law', '1');
    }

    if (!localStorage.getItem('tut-gauss-law')) {
      showTutorial();
    }

    document.getElementById('simTutorial').addEventListener('click', dismissTutorial);
    document.getElementById('helpBtn').addEventListener('click', showTutorial);

    // === EQUATION HIGHLIGHTING ===
    function updateEquationHighlight() {
      var ids = ['eqGauss','eqCenter','eqCorner','eqEdge','eqCoulomb'];
      for (var i = 0; i < ids.length; i++) {
        document.getElementById(ids[i]).classList.remove('active');
      }
      document.getElementById('eqGauss').classList.add('active');
      if (MODE === 'center') document.getElementById('eqCenter').classList.add('active');
      else if (MODE === 'corner') document.getElementById('eqCorner').classList.add('active');
      else if (MODE === 'edge') document.getElementById('eqEdge').classList.add('active');
    }

    // === INIT ===
    chargeFrom = getChargePos3D('center');
    chargeTo = getChargePos3D('center');
    // Disable ghost checkbox in initial center mode
    document.getElementById('ghostCheck').disabled = true;
    resizeCanvas();
    updateEquationHighlight();
    startAnim();
  </script>
  <script src="../js/main.js"></script>
  <script src="../js/auth-gate.js"></script>
<script src="../js/pwa-install.js"></script>
<script>if("serviceWorker" in navigator){navigator.serviceWorker.register("/sw.js");}</script>
</body>
</html>
