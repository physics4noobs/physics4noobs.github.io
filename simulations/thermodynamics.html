<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Thermodynamics Simulation | Axomiya Engineer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;500;600;700&family=Delius&family=Nova+Square&family=Orbitron:wght@400;500;600;700;800;900&family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/style.css">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ”¬</text></svg>">
  <script src="../js/theme.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
  <script defer src="../js/firebase-config.js"></script>
  <script defer src="../js/auth.js"></script>
  <script defer src="../js/sim-tracker.js"></script>
</head>
<body>
  <!-- Splash Screen -->
  <div class="splash-screen" id="splash"><div class="splash-logo">Axomiya Engineer</div><div class="splash-tagline">Lets Make Physics Fun</div><div class="splash-bar"><div class="splash-bar-fill"></div></div></div>
<div class="bg-grid"></div>
  <nav class="navbar scrolled">
    <div class="nav-container">
      <a href="../index.html" class="nav-logo" id="nav-logo"><div class="logo-icon"><div class="logo-pendulum"><div class="pendulum-mount"></div><div class="pendulum-pivot"></div><div class="pendulum-arm"><div class="pendulum-rod"></div><div class="pendulum-bob"><div class="bob-glow"></div></div></div></div></div><div class="logo-text"><span class="brand-name">Axomiya Engineer</span><span class="brand-tag">LETS MAKE PHYSICS FUN</span></div></a>
      <div class="nav-links"><div class="nav-item"><a href="../index.html" class="nav-link">Home</a></div><div class="nav-item"><a href="../simulations.html" class="nav-link active">Simulations</a></div><div class="nav-item"><a href="../chapters.html" class="nav-link">Chapters</a></div><button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme"></button><button class="auth-btn" id="auth-login-btn"><svg class="google-icon" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92a5.06 5.06 0 0 1-2.2 3.32v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.1z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>Sign in</button><div class="user-menu nav-item" id="auth-user-menu" style="display:none;"><img class="user-avatar" id="auth-user-avatar" src="" alt="User"><span class="user-name" id="auth-user-name"></span><div class="dropdown"><a href="../progress.html"><div class="dd-icon">&#128200;</div> My Progress</a><div class="dropdown-divider"></div><a href="#" id="auth-logout-btn"><div class="dd-icon">&#128682;</div> Sign Out</a></div></div><a href="../index.html#contact" class="nav-cta">Contact Me</a></div>
      <button class="nav-toggle" aria-label="Menu"><span></span><span></span><span></span></button>
    </div>
  </nav>
  <script>
    (function(){
      var s=document.getElementById('splash');
      if(sessionStorage.getItem('ae-splash')){s.style.display='none';}
      else{
        sessionStorage.setItem('ae-splash','1');setTimeout(function(){s.classList.add('fade-out');},2200);setTimeout(function(){s.style.display='none';},2700);
      }
    })();
  </script>

  <div class="sim-page-container">
    <h1 style="font-family: var(--font-display); font-size: 1.8rem; margin: 16px 0 8px; letter-spacing: 1px;">&#127777; Gas Laws - PV Diagram</h1>
    <p style="color: var(--text-secondary); margin-bottom: 24px;">Grade XI &bull; Heat &amp; Thermodynamics</p>

    <div class="sim-canvas-wrapper">
      <canvas id="simCanvas" width="850" height="450"></canvas>
      <div class="sim-controls">
        <button id="btnIsothermal" onclick="selectProcess('isothermal')" style="background: rgba(0,212,255,0.2); border-color: #00d4ff;">Isothermal</button>
        <button id="btnIsobaric" onclick="selectProcess('isobaric')">Isobaric</button>
        <button id="btnIsochoric" onclick="selectProcess('isochoric')">Isochoric</button>
        <button id="btnAdiabatic" onclick="selectProcess('adiabatic')">Adiabatic</button>
        <label>Temperature: <input type="range" id="temperature" min="200" max="800" value="300" step="10"> <span id="tempVal">300</span> K</label>
        <button onclick="runProcess()">&#9654; Animate</button>
        <button onclick="resetSim()">&#8635; Reset</button>
      </div>
    </div>

    <div class="sim-info">
      <h2>About This Simulation</h2>
      <p>Explore thermodynamic processes on a PV (Pressure-Volume) diagram. Select a process type to see how the gas state changes. The piston-cylinder on the right visualizes the physical change. Isothermal processes keep temperature constant, isobaric keeps pressure constant, isochoric keeps volume constant, and adiabatic has no heat exchange.</p>
      <div class="formula-box" style="margin-top: 16px;">
        PV = nRT &nbsp;&nbsp;|&nbsp;&nbsp; Isothermal: PV = const &nbsp;&nbsp;|&nbsp;&nbsp; Isobaric: V/T = const &nbsp;&nbsp;|&nbsp;&nbsp; Adiabatic: PV&#x1D6FE; = const
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    const tempSlider = document.getElementById('temperature');
    tempSlider.oninput = () => {
      document.getElementById('tempVal').textContent = tempSlider.value;
      if (!animating) draw();
    };

    // Gas constants
    const n = 1;  // moles
    const R = 8.314;
    const gamma = 1.4; // diatomic

    // State variables
    let P = 200000;    // Pa
    let V = 0.012;     // m^3
    let T = 300;       // K  (PV = nRT => T = PV/nR)

    // Process state
    let process = 'isothermal';
    let animating = false;
    let animId = null;
    let animProgress = 0;
    let pathPoints = [];
    let stateHistory = [];

    // PV diagram area
    const pvX = 40, pvY = 30, pvW = 400, pvH = 350;
    // PV ranges
    const P_MIN = 50000, P_MAX = 500000;
    const V_MIN = 0.004, V_MAX = 0.025;

    // Piston-cylinder area
    const cylX = 560, cylY = 80, cylW = 140, cylH = 280;

    function initState() {
      T = parseFloat(tempSlider.value);
      V = n * R * T / P;
      if (V < V_MIN) { V = V_MIN; P = n * R * T / V; }
      if (V > V_MAX) { V = V_MAX; P = n * R * T / V; }
    }

    function pvToScreen(pv) {
      const sx = pvX + ((pv.V - V_MIN) / (V_MAX - V_MIN)) * pvW;
      const sy = pvY + pvH - ((pv.P - P_MIN) / (P_MAX - P_MIN)) * pvH;
      return { x: sx, y: sy };
    }

    function selectProcess(p) {
      process = p;
      ['isothermal', 'isobaric', 'isochoric', 'adiabatic'].forEach(name => {
        const btn = document.getElementById('btn' + name.charAt(0).toUpperCase() + name.slice(1));
        if (name === p) {
          btn.style.background = 'rgba(0,212,255,0.2)';
          btn.style.borderColor = '#00d4ff';
        } else {
          btn.style.background = '';
          btn.style.borderColor = '';
        }
      });
      if (!animating) draw();
    }

    function drawBackground() {
      ctx.fillStyle = '#080818';
      ctx.fillRect(0, 0, W, H);
      ctx.strokeStyle = 'rgba(0,212,255,0.04)';
      ctx.lineWidth = 1;
      for (let x = 0; x < W; x += 40) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }
      for (let y = 0; y < H; y += 40) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke(); }
    }

    function drawPVAxes() {
      // Background panel
      ctx.fillStyle = 'rgba(10,10,30,0.5)';
      ctx.beginPath();
      ctx.roundRect(pvX - 20, pvY - 15, pvW + 50, pvH + 55, 10);
      ctx.fill();

      // Grid lines
      ctx.strokeStyle = 'rgba(0,212,255,0.06)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 5; i++) {
        const y = pvY + (i / 5) * pvH;
        ctx.beginPath(); ctx.moveTo(pvX, y); ctx.lineTo(pvX + pvW, y); ctx.stroke();
        const x = pvX + (i / 5) * pvW;
        ctx.beginPath(); ctx.moveTo(x, pvY); ctx.lineTo(x, pvY + pvH); ctx.stroke();
      }

      // Axes
      ctx.strokeStyle = 'rgba(0,212,255,0.4)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(pvX, pvY);
      ctx.lineTo(pvX, pvY + pvH);
      ctx.lineTo(pvX + pvW, pvY + pvH);
      ctx.stroke();

      // Labels
      ctx.font = '12px "Inter", sans-serif';
      ctx.fillStyle = '#00d4ff';
      ctx.textAlign = 'center';
      ctx.fillText('Volume (V) \u2192', pvX + pvW / 2, pvY + pvH + 35);

      ctx.save();
      ctx.translate(pvX - 14, pvY + pvH / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('Pressure (P) \u2192', 0, 0);
      ctx.restore();

      // Tick labels
      ctx.font = '9px "JetBrains Mono", monospace';
      ctx.fillStyle = 'rgba(0,212,255,0.4)';
      ctx.textAlign = 'right';
      for (let i = 0; i <= 5; i++) {
        const pVal = P_MIN + (1 - i / 5) * (P_MAX - P_MIN);
        ctx.fillText((pVal / 1000).toFixed(0) + 'k', pvX - 4, pvY + (i / 5) * pvH + 4);
      }
      ctx.textAlign = 'center';
      for (let i = 0; i <= 5; i++) {
        const vVal = V_MIN + (i / 5) * (V_MAX - V_MIN);
        ctx.fillText((vVal * 1000).toFixed(1), pvX + (i / 5) * pvW, pvY + pvH + 16);
      }

      // Title
      ctx.font = '11px "Inter", sans-serif';
      ctx.fillStyle = 'rgba(0,212,255,0.5)';
      ctx.textAlign = 'left';
      ctx.fillText('PV DIAGRAM', pvX, pvY - 4);
    }

    function drawStatePoint(pv, color, size, label) {
      const s = pvToScreen(pv);
      if (s.x < pvX || s.x > pvX + pvW || s.y < pvY || s.y > pvY + pvH) return;

      ctx.beginPath();
      ctx.arc(s.x, s.y, size || 6, 0, Math.PI * 2);
      ctx.fillStyle = color || '#00ffaa';
      ctx.shadowColor = color || '#00ffaa';
      ctx.shadowBlur = 12;
      ctx.fill();
      ctx.shadowBlur = 0;

      if (label) {
        ctx.font = '10px "JetBrains Mono", monospace';
        ctx.fillStyle = color || '#00ffaa';
        ctx.textAlign = 'left';
        ctx.fillText(label, s.x + 10, s.y - 6);
      }
    }

    function drawProcessCurve() {
      if (stateHistory.length < 2) return;

      ctx.beginPath();
      const s0 = pvToScreen(stateHistory[0]);
      ctx.moveTo(s0.x, s0.y);

      for (let i = 1; i < stateHistory.length; i++) {
        const s = pvToScreen(stateHistory[i]);
        ctx.lineTo(s.x, s.y);
      }

      const colors = {
        isothermal: '#00d4ff',
        isobaric: '#00ffaa',
        isochoric: '#7c3aed',
        adiabatic: '#ff2d75'
      };
      ctx.strokeStyle = colors[process];
      ctx.lineWidth = 3;
      ctx.shadowColor = colors[process];
      ctx.shadowBlur = 10;
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Arrowhead on last segment if enough points
      if (stateHistory.length >= 3) {
        const last = pvToScreen(stateHistory[stateHistory.length - 1]);
        const prev = pvToScreen(stateHistory[stateHistory.length - 3]);
        const angle = Math.atan2(last.y - prev.y, last.x - prev.x);
        ctx.beginPath();
        ctx.moveTo(last.x, last.y);
        ctx.lineTo(last.x - 10 * Math.cos(angle - 0.3), last.y - 10 * Math.sin(angle - 0.3));
        ctx.lineTo(last.x - 10 * Math.cos(angle + 0.3), last.y - 10 * Math.sin(angle + 0.3));
        ctx.closePath();
        ctx.fillStyle = colors[process];
        ctx.fill();
      }
    }

    function drawIsothermalCurveReference() {
      // Draw faint reference isothermal for current temperature
      const Tcur = parseFloat(tempSlider.value);
      ctx.beginPath();
      let first = true;
      for (let v = V_MIN; v <= V_MAX; v += 0.0002) {
        const p = n * R * Tcur / v;
        if (p < P_MIN || p > P_MAX) continue;
        const s = pvToScreen({ P: p, V: v });
        if (first) { ctx.moveTo(s.x, s.y); first = false; }
        else ctx.lineTo(s.x, s.y);
      }
      ctx.strokeStyle = 'rgba(0,212,255,0.12)';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      ctx.stroke();
      ctx.setLineDash([]);

      // Label
      if (!first) {
        const midV = (V_MIN + V_MAX) / 2;
        const midP = n * R * Tcur / midV;
        if (midP >= P_MIN && midP <= P_MAX) {
          const s = pvToScreen({ P: midP, V: midV });
          ctx.font = '9px "JetBrains Mono", monospace';
          ctx.fillStyle = 'rgba(0,212,255,0.3)';
          ctx.textAlign = 'left';
          ctx.fillText('T=' + Tcur + 'K', s.x + 5, s.y - 5);
        }
      }
    }

    function drawCylinder() {
      // Panel
      ctx.fillStyle = 'rgba(10,10,30,0.6)';
      ctx.beginPath();
      ctx.roundRect(cylX - 30, cylY - 30, cylW + 60, cylH + 120, 10);
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,212,255,0.1)';
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.font = '11px "Inter", sans-serif';
      ctx.fillStyle = 'rgba(0,212,255,0.5)';
      ctx.textAlign = 'center';
      ctx.fillText('PISTON-CYLINDER', cylX + cylW / 2, cylY - 14);

      // Cylinder walls
      ctx.strokeStyle = '#00d4ff';
      ctx.lineWidth = 3;
      ctx.shadowColor = '#00d4ff';
      ctx.shadowBlur = 8;

      // Left wall
      ctx.beginPath();
      ctx.moveTo(cylX, cylY);
      ctx.lineTo(cylX, cylY + cylH);
      ctx.stroke();

      // Right wall
      ctx.beginPath();
      ctx.moveTo(cylX + cylW, cylY);
      ctx.lineTo(cylX + cylW, cylY + cylH);
      ctx.stroke();

      // Bottom wall
      ctx.beginPath();
      ctx.moveTo(cylX, cylY + cylH);
      ctx.lineTo(cylX + cylW, cylY + cylH);
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Piston position based on volume
      const vFrac = (V - V_MIN) / (V_MAX - V_MIN);
      const pistonY = cylY + cylH - vFrac * (cylH - 20) - 15;

      // Gas fill
      const gasGrad = ctx.createLinearGradient(cylX, pistonY, cylX, cylY + cylH);
      // Color based on temperature
      const tFrac = (T - 200) / 600;
      if (tFrac > 0.5) {
        gasGrad.addColorStop(0, `rgba(255,${Math.round(100 - tFrac * 60)},${Math.round(50)},0.15)`);
        gasGrad.addColorStop(1, `rgba(255,${Math.round(100 - tFrac * 60)},${Math.round(50)},0.05)`);
      } else {
        gasGrad.addColorStop(0, `rgba(0,212,255,0.12)`);
        gasGrad.addColorStop(1, `rgba(0,212,255,0.04)`);
      }
      ctx.fillStyle = gasGrad;
      ctx.fillRect(cylX + 3, pistonY + 12, cylW - 6, cylY + cylH - pistonY - 15);

      // Gas particles (dots)
      const gasH = cylY + cylH - pistonY - 15;
      const numDots = Math.max(5, Math.floor(vFrac * 30));
      ctx.save();
      for (let i = 0; i < numDots; i++) {
        const seed = i * 137.5 + (animating ? animProgress * 50 : 0);
        const dx = (Math.sin(seed) * 0.5 + 0.5) * (cylW - 16) + cylX + 8;
        const dy = pistonY + 15 + (Math.cos(seed * 0.7 + i) * 0.5 + 0.5) * (gasH - 10);
        const speed = T / 300;
        const jitterX = Math.sin(Date.now() / 200 + i * 2.1) * speed * 3;
        const jitterY = Math.cos(Date.now() / 180 + i * 1.7) * speed * 3;
        ctx.beginPath();
        ctx.arc(dx + jitterX, dy + jitterY, 2, 0, Math.PI * 2);
        ctx.fillStyle = tFrac > 0.5 ? `rgba(255,100,50,${0.4 + tFrac * 0.3})` : `rgba(0,212,255,${0.3 + tFrac * 0.3})`;
        ctx.fill();
      }
      ctx.restore();

      // Piston block
      const pistonGrad = ctx.createLinearGradient(cylX, pistonY, cylX, pistonY + 12);
      pistonGrad.addColorStop(0, 'rgba(0,255,170,0.5)');
      pistonGrad.addColorStop(1, 'rgba(0,212,255,0.3)');
      ctx.fillStyle = pistonGrad;
      ctx.fillRect(cylX + 2, pistonY, cylW - 4, 12);

      ctx.strokeStyle = '#00ffaa';
      ctx.lineWidth = 2;
      ctx.shadowColor = '#00ffaa';
      ctx.shadowBlur = 8;
      ctx.strokeRect(cylX + 2, pistonY, cylW - 4, 12);
      ctx.shadowBlur = 0;

      // Piston rod
      ctx.strokeStyle = 'rgba(0,255,170,0.4)';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(cylX + cylW / 2, pistonY);
      ctx.lineTo(cylX + cylW / 2, cylY - 10);
      ctx.stroke();

      // Handle
      ctx.strokeStyle = 'rgba(0,255,170,0.3)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(cylX + cylW / 2 - 15, cylY - 10);
      ctx.lineTo(cylX + cylW / 2 + 15, cylY - 10);
      ctx.stroke();

      // Arrow showing force direction
      if (animating) {
        const direction = (process === 'isothermal' || process === 'adiabatic') ? 1 :
                          (process === 'isobaric' ? 1 : 0);
        if (direction !== 0) {
          ctx.fillStyle = '#ff2d75';
          ctx.strokeStyle = '#ff2d75';
          ctx.lineWidth = 2;
          ctx.shadowColor = '#ff2d75';
          ctx.shadowBlur = 6;
          const arrowX = cylX + cylW / 2;
          const arrowY = cylY - 20;
          ctx.beginPath();
          ctx.moveTo(arrowX, arrowY);
          ctx.lineTo(arrowX, arrowY - 20 * direction);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(arrowX, arrowY - 20 * direction);
          ctx.lineTo(arrowX - 5, arrowY - 20 * direction + 6 * direction);
          ctx.lineTo(arrowX + 5, arrowY - 20 * direction + 6 * direction);
          ctx.closePath();
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }
    }

    function drawStateInfo() {
      const panelX = 510, panelY = cylY + cylH + 30, panelW = 200, panelH = 100;

      ctx.fillStyle = 'rgba(10,10,30,0.85)';
      ctx.strokeStyle = 'rgba(0,212,255,0.2)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.roundRect(panelX, panelY, panelW, panelH, 8);
      ctx.fill();
      ctx.stroke();

      ctx.font = '11px "Inter", sans-serif';
      ctx.fillStyle = 'rgba(0,212,255,0.5)';
      ctx.textAlign = 'left';
      ctx.fillText('STATE VARIABLES', panelX + 12, panelY + 18);

      ctx.font = '12px "JetBrains Mono", monospace';
      let y = panelY + 38;

      ctx.fillStyle = '#00d4ff';
      ctx.fillText('P = ' + (P / 1000).toFixed(1) + ' kPa', panelX + 12, y);
      y += 20;
      ctx.fillStyle = '#00ffaa';
      ctx.fillText('V = ' + (V * 1000).toFixed(2) + ' L', panelX + 12, y);
      y += 20;
      ctx.fillStyle = '#ff2d75';
      ctx.fillText('T = ' + T.toFixed(0) + ' K', panelX + 12, y);
    }

    function drawProcessLabel() {
      const labels = {
        isothermal: 'ISOTHERMAL (T = const)',
        isobaric: 'ISOBARIC (P = const)',
        isochoric: 'ISOCHORIC (V = const)',
        adiabatic: 'ADIABATIC (Q = 0)'
      };
      const colors = {
        isothermal: '#00d4ff',
        isobaric: '#00ffaa',
        isochoric: '#7c3aed',
        adiabatic: '#ff2d75'
      };

      ctx.font = '12px "JetBrains Mono", monospace';
      ctx.fillStyle = colors[process];
      ctx.textAlign = 'right';
      ctx.fillText(labels[process], pvX + pvW, pvY - 4);
    }

    function runProcess() {
      if (animating) return;

      // Initialize from current slider temperature
      initState();
      stateHistory = [{ P: P, V: V, T: T }];
      animProgress = 0;
      animating = true;

      const startP = P, startV = V, startT = T;
      const steps = 120;

      // Target: expand/compress
      let targetV, targetP, targetT;

      if (process === 'isothermal') {
        // Expand: V doubles, T constant
        targetV = Math.min(startV * 2, V_MAX);
        targetT = startT;
        targetP = n * R * targetT / targetV;
      } else if (process === 'isobaric') {
        // Expand at constant pressure, T increases
        targetP = startP;
        targetV = Math.min(startV * 1.8, V_MAX);
        targetT = targetP * targetV / (n * R);
      } else if (process === 'isochoric') {
        // Heat at constant volume, P increases
        targetV = startV;
        targetT = startT * 1.8;
        targetP = n * R * targetT / targetV;
        if (targetP > P_MAX) { targetP = P_MAX; targetT = targetP * targetV / (n * R); }
      } else if (process === 'adiabatic') {
        // Expand adiabatically: PV^gamma = const
        targetV = Math.min(startV * 2, V_MAX);
        targetP = startP * Math.pow(startV / targetV, gamma);
        targetT = targetP * targetV / (n * R);
      }

      let step = 0;

      function stepAnim() {
        step++;
        animProgress = step / steps;

        if (step > steps) {
          animating = false;
          animId = null;
          P = targetP; V = targetV; T = targetT;
          stateHistory.push({ P, V, T });
          draw();
          return;
        }

        const t = step / steps;

        if (process === 'isothermal') {
          V = startV + (targetV - startV) * t;
          T = startT;
          P = n * R * T / V;
        } else if (process === 'isobaric') {
          V = startV + (targetV - startV) * t;
          P = startP;
          T = P * V / (n * R);
        } else if (process === 'isochoric') {
          V = startV;
          T = startT + (targetT - startT) * t;
          P = n * R * T / V;
        } else if (process === 'adiabatic') {
          V = startV + (targetV - startV) * t;
          P = startP * Math.pow(startV / V, gamma);
          T = P * V / (n * R);
        }

        stateHistory.push({ P, V, T });
        draw();
        animId = requestAnimationFrame(stepAnim);
      }

      stepAnim();
    }

    function resetSim() {
      if (animId) cancelAnimationFrame(animId);
      animating = false;
      animId = null;
      animProgress = 0;
      stateHistory = [];
      P = 200000;
      T = parseFloat(tempSlider.value);
      V = n * R * T / P;
      if (V < V_MIN) { V = V_MIN; P = n * R * T / V; }
      if (V > V_MAX) { V = V_MAX; P = n * R * T / V; }
      draw();
    }

    function draw() {
      drawBackground();
      drawPVAxes();
      drawIsothermalCurveReference();
      drawProcessCurve();
      drawStatePoint({ P, V }, '#00ffaa', 7, 'State');
      if (stateHistory.length > 0) {
        drawStatePoint(stateHistory[0], '#7c3aed', 5, 'Start');
      }
      drawProcessLabel();
      drawCylinder();
      drawStateInfo();
    }

    // Init
    initState();
    draw();
  </script>
  <script src="../js/main.js"></script>
</body>
</html>
