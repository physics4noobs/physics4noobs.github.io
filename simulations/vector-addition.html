<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vector Addition | Physics for Noobs</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;500;600;700&family=Jost:wght@300;400;500;600;700&family=Delius&family=Nova+Square&family=Yatra+One&family=Quintessential&family=Cabin+Sketch:wght@400;700&family=Orbitron:wght@400;500;600;700;800;900&family=Inter:wght@300;400;500;600;700&family=Andika:wght@400;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/style.css">
  <link rel="manifest" href="../manifest.json">
  <meta name="theme-color" content="#050510">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="../images/icon-192.svg">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ”¬</text></svg>">
  <script src="../js/theme.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
  <script defer src="../js/firebase-config.js"></script>
  <script defer src="../js/auth.js?v=53"></script>
  <script defer src="../js/ranking.js"></script>
  <script defer src="../js/sim-tracker.js"></script>
  <link rel="stylesheet" href="../css/achievements.css">
  <script defer src="../js/achievements-config.js"></script>
  <script defer src="../js/achievements.js"></script>
</head>
<body data-auth-redirect="../simulations.html">
  <!-- Splash Screen -->
  <div class="splash-screen" id="splash"><div class="splash-rocket"><div class="sp-nose"></div><div class="sp-body"></div><div class="sp-window"></div><div class="sp-fin-l"></div><div class="sp-fin-r"></div><div class="sp-flame"></div><div class="sp-glow"></div></div><div class="splash-logo"><span class="brand-initial">P</span>hysics <span class="brand-accent">for Noobs</span></div><div class="splash-tagline">Free Therapy For Physics Trauma</div></div>
<div class="bg-grid"></div>
  <nav class="navbar scrolled">
    <div class="nav-container">
      <a href="../index.html" class="nav-logo" id="nav-logo">
        <div class="logo-icon"><div class="logo-pendulum"><div class="pendulum-pivot"></div><div class="pendulum-arm"><div class="pendulum-string"></div><div class="pendulum-bob"></div></div></div></div>
        <div class="logo-text"><span class="brand-name"><span class="brand-initial">P</span>hysics <span class="brand-accent">for Noobs</span></span><span class="brand-tag">FREE THERAPY FOR PHYSICS TRAUMA</span></div>
      </a>
      <div class="nav-links">
        <div class="nav-item">
          <a href="../index.html" class="nav-link">Home</a>
        </div>
        <div class="nav-item">
          <a href="../about.html" class="nav-link">About Me</a>
        </div>
        <div class="nav-item"><a href="#" class="nav-link">Chapters</a><div class="dropdown"><a href="../chapters.html"><div class="dd-icon">&#128214;</div> Theory</a><a href="../slides.html"><div class="dd-icon">&#127916;</div> Slides</a></div></div>        <div class="nav-item">
          <a href="../simulations.html" class="nav-link active">Simulations</a>
        </div>
        <div class="nav-item">
          <a href="../tests.html" class="nav-link">Tests</a>
        </div>
        <div class="nav-item">
          <a href="../flashcards.html" class="nav-link">Flashcards</a>
        </div>
        <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme"></button>
        <button class="auth-btn" id="auth-login-btn"><svg class="google-icon" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92a5.06 5.06 0 0 1-2.2 3.32v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.1z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>Sign in</button>
        <a href="progress.html" class="mobile-auth-action" id="mobile-progress-btn" style="display:none;">Progress</a>
        <button class="mobile-auth-action mobile-signout-btn" id="mobile-signout-btn" style="display:none;">Sign Out</button>

        <div class="user-menu nav-item" id="auth-user-menu" style="display:none;"><img class="user-avatar" id="auth-user-avatar" src="" alt="User"><span class="user-rank-badge rank-bronze" id="auth-rank-badge"><span class="rank-icon" id="auth-rank-icon"></span><span id="auth-rank-label"></span></span><div class="dropdown"><div class="dropdown-rank" id="dropdown-rank-display"><span class="rank-tier" id="dropdown-rank-tier"></span><div class="rank-progress-bar"><div class="rank-progress-fill" id="dropdown-rank-fill"></div></div></div><a href="../progress.html"><div class="dd-icon">&#128200;</div> My Progress</a><div class="dropdown-divider"></div><a href="#" id="auth-logout-btn"><div class="dd-icon">&#128682;</div> Sign Out</a></div></div>
      </div>
      <button class="nav-toggle" aria-label="Menu"><span></span><span></span><span></span></button>
    </div>
  </nav>
  <script>
    (function(){
      var s=document.getElementById('splash');
      if(sessionStorage.getItem('ae-splash')){s.style.display='none';}
      else{
        sessionStorage.setItem('ae-splash','1');setTimeout(function(){s.classList.add('fade-out');},2200);setTimeout(function(){s.style.display='none';},2700);
      }
    })();
  </script>

  <style>
    .bg-grid { display: none !important; }

    .sim-wrapper {
      max-width: 1400px;
      margin: 0 auto;
      padding: 80px 24px 40px;
    }

    .sim-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }

    .sim-header h1 {
      font-family: var(--font-display);
      font-size: clamp(1.4rem, 2vw, 1.8rem);
      font-weight: 700;
      color: var(--text-primary);
      letter-spacing: 0.5px;
    }

    .sim-btn {
      padding: 8px 20px;
      font-size: 0.85rem;
      font-weight: 600;
      font-family: var(--font-body);
      color: var(--text-secondary);
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: var(--transition-fast);
    }

    .sim-btn:hover {
      color: var(--text-primary);
      border-color: rgba(124, 58, 237, 0.3);
      background: rgba(124, 58, 237, 0.08);
    }

    .sim-btn.primary {
      background: rgba(124, 58, 237, 0.15);
      color: var(--text-primary);
      border-color: rgba(124, 58, 237, 0.3);
    }

    .sim-btn.primary:hover {
      background: rgba(124, 58, 237, 0.25);
    }

    .sim-main-row {
      display: flex;
      gap: 1px;
      background: var(--border-subtle);
      border-radius: var(--radius-md) var(--radius-md) 0 0;
      overflow: hidden;
    }

    .canvas-wrap {
      flex: 1;
      overflow: hidden;
      background: var(--bg-secondary);
    }

    .side-data {
      width: 200px;
      min-width: 180px;
      background: var(--bg-card);
      padding: 16px;
      display: flex;
      flex-direction: column;
    }

    .side-data h3 {
      font-family: var(--font-display);
      font-size: 0.9rem;
      font-weight: 600;
      color: #00ffaa;
      margin-bottom: 12px;
    }

    .canvas-wrap canvas {
      display: block;
      width: 100%;
    }



    /* Legend */
    .legend-bar {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      padding: 10px 20px;
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      border-top: none;
      min-height: 18px;
    }

    .legend-chip {
      display: flex;
      align-items: center;
      gap: 6px;
      font-family: var(--font-body);
      font-size: clamp(0.72rem, 0.9vw, 0.82rem);
      color: var(--text-muted);
    }

    .legend-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    /* Controls */
    .controls-bar {
      display: flex;
      align-items: center;
      gap: clamp(16px, 2vw, 32px);
      padding: 18px 24px;
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      border-top: none;
      border-radius: 0 0 var(--radius-md) var(--radius-md);
      flex-wrap: wrap;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .control-group label {
      font-family: var(--font-body);
      font-size: clamp(0.85rem, 1vw, 1.05rem);
      color: var(--text-muted);
      white-space: nowrap;
    }

    .control-group input[type="range"] {
      width: clamp(100px, 10vw, 160px);
      -webkit-appearance: none;
      background: var(--border-subtle);
      height: 4px;
      border-radius: 2px;
      outline: none;
    }

    .control-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: var(--color-primary);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 6px rgba(124, 58, 237, 0.3);
      transition: box-shadow 0.2s;
    }

    .control-group input[type="range"]::-webkit-slider-thumb:hover {
      box-shadow: 0 0 10px rgba(124, 58, 237, 0.5);
    }

    .control-group input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: var(--color-primary);
      border-radius: 50%;
      cursor: pointer;
      border: none;
      box-shadow: 0 0 6px rgba(124, 58, 237, 0.3);
    }

    .control-group .val {
      font-family: var(--font-body);
      font-size: clamp(0.88rem, 1vw, 1.05rem);
      color: var(--text-primary);
      min-width: 36px;
      text-align: right;
    }

    .control-group input[type="number"] {
      width: 58px;
      padding: 4px 6px;
      font-family: var(--font-mono);
      font-size: 0.88rem;
      color: var(--text-primary);
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      text-align: center;
      -moz-appearance: textfield;
      outline: none;
      transition: border-color 0.2s;
    }

    .control-group input[type="number"]:focus {
      border-color: var(--color-primary);
    }

    .control-group input[type="number"]::-webkit-inner-spin-button,
    .control-group input[type="number"]::-webkit-outer-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    .data-grid {
      display: flex;
      flex-direction: column;
    }

    .data-row {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      border-bottom: 1px solid var(--border-subtle);
    }

    .data-row:last-child {
      border-bottom: none;
    }

    .data-label {
      font-family: var(--font-body);
      font-size: clamp(0.82rem, 0.95vw, 0.95rem);
      color: var(--text-muted);
    }

    .data-value {
      font-family: var(--font-body);
      font-size: clamp(0.85rem, 1vw, 1rem);
      color: var(--text-primary);
      font-weight: 600;
    }

    /* Equations */
    .equations-section {
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-md);
      padding: 20px 24px;
      margin-top: 16px;
    }

    .equations-section h3 {
      font-family: var(--font-display);
      font-size: clamp(0.8rem, 1vw, 1rem);
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 14px;
    }

    .equations-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 12px 32px;
    }

    .equation-item {
      font-family: var(--font-body);
      font-size: clamp(1rem, 1.2vw, 1.2rem);
      color: var(--text-primary);
      padding: 8px 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      white-space: nowrap;
    }

    .equation-item .eq-label {
      color: var(--text-muted);
      font-size: clamp(0.8rem, 0.9vw, 0.9rem);
      display: block;
      margin-bottom: 2px;
    }

    /* Q&A */
    .qa-section {
      margin-top: 32px;
    }

    .qa-section h2 {
      font-family: var(--font-display);
      font-size: clamp(0.9rem, 1.1vw, 1.1rem);
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 16px;
    }

    .qa-item {
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-md);
      margin-bottom: 8px;
      overflow: hidden;
      transition: var(--transition-fast);
    }

    .qa-item:hover {
      border-color: rgba(124, 58, 237, 0.2);
    }

    .qa-q {
      padding: 16px 24px;
      font-family: var(--font-body);
      font-size: clamp(0.95rem, 1.1vw, 1.15rem);
      color: var(--text-primary);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: var(--transition-fast);
    }

    .qa-q:hover {
      background: var(--bg-glass-hover);
    }

    .qa-q::after {
      content: '+';
      font-size: 1.4rem;
      color: var(--color-primary);
      transition: transform 0.2s;
      font-weight: 300;
    }

    .qa-item.open .qa-q::after {
      content: '\2212';
    }

    .qa-a {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .qa-item.open .qa-a {
      max-height: 300px;
    }

    .qa-a-inner {
      padding: 0 24px 18px;
      font-family: var(--font-body);
      font-size: clamp(0.92rem, 1vw, 1.08rem);
      color: var(--text-secondary);
      line-height: 1.75;
    }

    /* Fullscreen */
    #simArea {
      background: var(--bg-primary);
      position: relative;
    }

    #simArea:fullscreen,
    #simArea:-webkit-full-screen {
      background: var(--bg-primary);
      padding: 16px 24px;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }

    #simArea:fullscreen .sim-main-row,
    #simArea:-webkit-full-screen .sim-main-row {
      flex: 1;
      min-height: 0;
    }

    #simArea:fullscreen .canvas-wrap,
    #simArea:-webkit-full-screen .canvas-wrap {
      flex: 1;
      min-height: 0;
    }

    #simArea:fullscreen .controls-bar,
    #simArea:-webkit-full-screen .controls-bar {
      border-radius: 0;
    }

    @media (max-width: 900px) {
      .sim-main-row { flex-direction: column; }
      .side-data { width: 100%; min-width: unset; }
      .canvas-wrap { border-radius: var(--radius-md) var(--radius-md) 0 0; }
    }
    @media (max-width: 768px) {
      .sim-wrapper { padding: 70px 12px 24px; }
      .sim-header { flex-direction: column; gap: 12px; align-items: flex-start; }
      .controls-bar { gap: 12px; padding: 12px; }
      .control-group input[type="range"] { width: 80px; }
    }

    /* === Tutorial Overlay === */
    .sim-tutorial {
      position: absolute;
      inset: 0;
      z-index: 50;
      background: rgba(255,255,255,0.08);
      backdrop-filter: blur(0.5px);
      -webkit-backdrop-filter: blur(0.5px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 0.4s ease;
      cursor: pointer;
      border-radius: var(--radius-md);
    }

    .tut-hint {
      position: absolute;
      display: flex;
      align-items: center;
      gap: 8px;
      color: #fff;
      font-size: 0.88rem;
      pointer-events: none;
    }

    .tut-arrows-svg {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }

    .tut-label {
      font-family: var(--font-body);
      background: rgba(255,255,255,0.92);
      color: #1a1a2e;
      padding: 6px 14px;
      border-radius: 20px;
      font-weight: 600;
      font-size: 0.82rem;
      white-space: nowrap;
      box-shadow: 0 2px 8px rgba(0,0,0,0.18);
    }

    .tut-dismiss {
      position: absolute;
      bottom: 38%;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 32px;
      font-family: var(--font-body);
      font-size: 0.95rem;
      font-weight: 700;
      color: #1a1a2e;
      background: #fff;
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      pointer-events: auto;
      box-shadow: 0 4px 16px rgba(124,58,237,0.3);
      transition: background 0.2s, transform 0.2s;
    }

    .tut-dismiss:hover {
      background: #e8e0f8;
      transform: translateX(-50%) scale(1.04);
    }

    @media (max-width: 900px) {
      .sim-tutorial { display: none !important; }
      #helpBtn { display: none; }
    }
  </style>

  <div class="sim-wrapper">
    <div id="simArea">
    <div class="sim-header">
      <h1>Vector Addition</h1>
      <div style="display:flex;gap:8px;">
        <button class="sim-btn primary" id="animateBtn">Animate Derivation</button>
        <button class="sim-btn" id="resetBtn">Reset</button>
        <button class="sim-btn" id="fullscreenBtn">Full Screen</button>
        <button class="sim-btn" id="helpBtn">? Help</button>
      </div>
    </div>

    <div class="sim-main-row">
      <div class="canvas-wrap">
        <canvas id="simCanvas"></canvas>
      </div>
      <div class="side-data">
        <h3>Resultant</h3>
        <div class="data-grid">
          <div class="data-row"><span class="data-label">|R|</span><span class="data-value" id="d-magR">&mdash;</span></div>
          <div class="data-row"><span class="data-label">&theta;<sub>R</sub></span><span class="data-value" id="d-angleR">&mdash;</span></div>
          <div class="data-row"><span class="data-label">R<sub>x</sub></span><span class="data-value" id="d-Rx">&mdash;</span></div>
          <div class="data-row"><span class="data-label">R<sub>y</sub></span><span class="data-value" id="d-Ry">&mdash;</span></div>
          <div class="data-row"><span class="data-label">&theta;<sub>AB</sub></span><span class="data-value" id="d-angleBetween">&mdash;</span></div>
        </div>
      </div>
    </div>


    <div class="controls-bar">
      <div class="control-group">
        <label>|A|</label>
        <input type="range" id="magA" min="1" max="10" value="5" step="0.5">
        <input type="number" id="magAInput" min="1" max="10" value="5" step="0.5">
      </div>
      <div class="control-group">
        <label>&theta;<sub>A</sub></label>
        <input type="range" id="angleA" min="0" max="360" value="30">
        <input type="number" id="angleAInput" min="0" max="360" value="30" step="1">
        <label>&deg;</label>
      </div>
      <div class="control-group">
        <label>|B|</label>
        <input type="range" id="magB" min="1" max="10" value="4" step="0.5">
        <input type="number" id="magBInput" min="1" max="10" value="4" step="0.5">
      </div>
      <div class="control-group">
        <label>&theta;<sub>B</sub></label>
        <input type="range" id="angleB" min="0" max="360" value="120">
        <input type="number" id="angleBInput" min="0" max="360" value="120" step="1">
        <label>&deg;</label>
      </div>
    </div>

    <!-- Tutorial Overlay -->
    <div class="sim-tutorial" id="simTutorial" style="display:none;">
      <svg class="tut-arrows-svg" id="tutArrowsSvg"></svg>

      <div class="tut-hint" id="tutDrag">
        <div class="tut-label">Drag the arrowheads to move vectors</div>
      </div>
      <div class="tut-hint" id="tutMagA">
        <div class="tut-label">Set magnitude of vector A</div>
      </div>
      <div class="tut-hint" id="tutAngleA">
        <div class="tut-label">Set direction of vector A</div>
      </div>
      <div class="tut-hint" id="tutAnimate">
        <div class="tut-label">Play the derivation step-by-step</div>
      </div>
      <div class="tut-hint" id="tutData">
        <div class="tut-label">Live resultant data updates here</div>
      </div>

      <button class="tut-dismiss">Got it, let's start!</button>
    </div>

    </div><!-- end #simArea -->

    <div class="equations-section">
      <h3>Key Equations</h3>
      <div class="equations-grid">
        <div class="equation-item">
          <span class="eq-label">Magnitude</span>
          R = &radic;(A&sup2; + B&sup2; + 2AB cos&theta;)
        </div>
        <div class="equation-item">
          <span class="eq-label">Direction</span>
          tan &alpha; = B sin&theta; / (A + B cos&theta;)
        </div>
        <div class="equation-item">
          <span class="eq-label">Component Form</span>
          R<sub>x</sub> = A<sub>x</sub> + B<sub>x</sub> , R<sub>y</sub> = A<sub>y</sub> + B<sub>y</sub>
        </div>
        <div class="equation-item">
          <span class="eq-label">Components</span>
          A<sub>x</sub> = |A| cos&theta;<sub>A</sub> , A<sub>y</sub> = |A| sin&theta;<sub>A</sub>
        </div>
      </div>
    </div>

    <div class="qa-section">
      <h2>Test Your Understanding</h2>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">What is the parallelogram law of vector addition?</div>
        <div class="qa-a"><div class="qa-a-inner">
          If two vectors are represented in magnitude and direction by two adjacent sides of a parallelogram, then their <strong>resultant</strong> is represented by the diagonal of the parallelogram passing through their common point. Place both vectors tail-to-tail, complete the parallelogram, and the diagonal from the origin gives the resultant vector.
        </div></div>
      </div>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">When is the resultant of two vectors maximum or minimum?</div>
        <div class="qa-a"><div class="qa-a-inner">
          The resultant is <strong>maximum</strong> when the angle between the vectors is <strong>0&deg;</strong> (same direction): R<sub>max</sub> = A + B. The resultant is <strong>minimum</strong> when the angle is <strong>180&deg;</strong> (opposite directions): R<sub>min</sub> = |A &minus; B|. Try setting both angles equal in the simulation to see maximum resultant!
        </div></div>
      </div>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">Can two vectors of different magnitudes give a zero resultant?</div>
        <div class="qa-a"><div class="qa-a-inner">
          <strong>No.</strong> Two vectors can only cancel each other (give zero resultant) if they have <strong>equal magnitudes</strong> and are in <strong>opposite directions</strong> (180&deg; apart). For three or more vectors, different magnitudes can produce a zero resultant if they form a closed polygon.
        </div></div>
      </div>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">How do you find the direction of the resultant?</div>
        <div class="qa-a"><div class="qa-a-inner">
          The direction is found using <strong>tan &alpha; = B sin&theta; / (A + B cos&theta;)</strong>, where &theta; is the angle between the two vectors and &alpha; is the angle the resultant makes with vector A. Alternatively, compute R<sub>x</sub> and R<sub>y</sub> and use <strong>&theta;<sub>R</sub> = arctan(R<sub>y</sub> / R<sub>x</sub>)</strong>.
        </div></div>
      </div>

      <div class="qa-item">
        <div class="qa-q" onclick="this.parentElement.classList.toggle('open')">What happens when two vectors are perpendicular?</div>
        <div class="qa-a"><div class="qa-a-inner">
          When &theta; = 90&deg;, the formula simplifies to <strong>R = &radic;(A&sup2; + B&sup2;)</strong> since cos 90&deg; = 0. This is just the Pythagorean theorem! The resultant forms the hypotenuse of a right triangle with A and B as the two sides. Try setting the angle difference to 90&deg; in the simulation.
        </div></div>
      </div>
    </div>
  </div>

  <script>
    // === THEME COLORS ===
    var tc = {};
    function updateThemeColors() {
      var isLight = document.documentElement.getAttribute('data-theme') === 'light';
      tc = {
        canvasBg: isLight ? '#e8eaf0' : '#08081a',
        canvasBgCenter: isLight ? '#f0f2f8' : '#10102a',
        grid: isLight ? 'rgba(0,120,200,0.06)' : 'rgba(0,212,255,0.035)',
        axis: isLight ? 'rgba(0,0,0,0.15)' : 'rgba(255,255,255,0.15)',
        tickText: isLight ? 'rgba(0,0,0,0.3)' : 'rgba(255,255,255,0.25)',
        parallelogram: isLight ? 'rgba(0,0,0,0.12)' : 'rgba(255,255,255,0.15)',
        arcFill: isLight ? 'rgba(124,58,237,0.08)' : 'rgba(124,58,237,0.12)',
        arcStroke: isLight ? 'rgba(124,58,237,0.3)' : 'rgba(124,58,237,0.4)',
        labelA: '#00d4ff',
        labelB: '#7c3aed',
        labelR: '#00ffaa',
        paraFill: isLight ? 'rgba(124,58,237,0.06)' : 'rgba(124,58,237,0.08)',
        projLine: isLight ? 'rgba(0,255,170,0.25)' : 'rgba(0,255,170,0.2)',
        axisArrow: isLight ? 'rgba(0,0,0,0.25)' : 'rgba(255,255,255,0.3)',
        axisLabel: isLight ? 'rgba(0,0,0,0.35)' : 'rgba(255,255,255,0.35)',
      };
    }
    updateThemeColors();
    new MutationObserver(function() { updateThemeColors(); draw(); })
      .observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });

    // === STATE ===
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');

    const magASlider = document.getElementById('magA');
    const angleASlider = document.getElementById('angleA');
    const magBSlider = document.getElementById('magB');
    const angleBSlider = document.getElementById('angleB');
    const magAInput = document.getElementById('magAInput');
    const angleAInput = document.getElementById('angleAInput');
    const magBInput = document.getElementById('magBInput');
    const angleBInput = document.getElementById('angleBInput');

    function syncMagA(val) {
      val = Math.max(1, Math.min(10, Math.round(parseFloat(val) * 2) / 2 || 1));
      magASlider.value = val; magAInput.value = val; draw();
    }
    function syncAngleA(val) {
      val = Math.max(0, Math.min(360, Math.round(parseFloat(val) || 0)));
      angleASlider.value = val; angleAInput.value = val; draw();
    }
    function syncMagB(val) {
      val = Math.max(1, Math.min(10, Math.round(parseFloat(val) * 2) / 2 || 1));
      magBSlider.value = val; magBInput.value = val; draw();
    }
    function syncAngleB(val) {
      val = Math.max(0, Math.min(360, Math.round(parseFloat(val) || 0)));
      angleBSlider.value = val; angleBInput.value = val; draw();
    }

    magASlider.oninput = function() { syncMagA(this.value); };
    magAInput.onchange = function() { syncMagA(this.value); };
    angleASlider.oninput = function() { syncAngleA(this.value); };
    angleAInput.onchange = function() { syncAngleA(this.value); };
    magBSlider.oninput = function() { syncMagB(this.value); };
    magBInput.onchange = function() { syncMagB(this.value); };
    angleBSlider.oninput = function() { syncAngleB(this.value); };
    angleBInput.onchange = function() { syncAngleB(this.value); };

    // Interactive drag state
    let dragging = null; // 'A' or 'B'
    const DRAG_RADIUS = 18; // px grab radius around arrowhead

    // === CANVAS SIZING ===
    const PADDING = 50;
    let originX, originY, scaleX, scaleY, canvasW, canvasH;

    function resizeCanvas() {
      const wrap = canvas.parentElement;
      const isFS = !!document.fullscreenElement;
      const w = wrap.clientWidth;
      var h;
      if (isFS) {
        h = wrap.clientHeight;
      } else {
        // Navbar ~64px, sim-header ~52px, legend ~38px, controls ~70px, wrapper padding ~80+40
        // Total non-canvas overhead â‰ˆ 300px
        h = window.innerHeight - 300;
        h = Math.max(350, h);
      }
      const dpr = window.devicePixelRatio || 1;
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      canvasW = w;
      canvasH = h;

      // Origin at center of canvas
      originX = canvasW / 2;
      originY = canvasH / 2;

      // Separate scales for X and Y so axes fill the canvas proportionally
      const maxMag = 10;
      scaleX = ((canvasW / 2) - PADDING) / maxMag;
      scaleY = ((canvasH / 2) - PADDING) / maxMag;

      draw();
    }

    window.addEventListener('resize', resizeCanvas);

    // === DRAWING ===
    const fs = () => Math.max(1, canvasW / 700);
    // World-to-screen helpers
    function wx(x) { return originX + x * scaleX; }
    function wy(y) { return originY - y * scaleY; }

    function drawBg() {
      // Radial gradient background
      const grad = ctx.createRadialGradient(canvasW / 2, canvasH / 2, 0, canvasW / 2, canvasH / 2, canvasW * 0.7);
      grad.addColorStop(0, tc.canvasBgCenter);
      grad.addColorStop(1, tc.canvasBg);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvasW, canvasH);

      // Dotted grid
      ctx.fillStyle = tc.grid;
      for (let x = PADDING; x < canvasW - PADDING; x += 50) {
        for (let y = PADDING / 2; y < canvasH - PADDING / 2; y += 50) {
          ctx.beginPath();
          ctx.arc(x, y, 1, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Axes â€” span Â±10 units from origin
      const AXIS_MAX = 10;
      var axisLenX = AXIS_MAX * scaleX;
      var axisLenY = AXIS_MAX * scaleY;
      ctx.strokeStyle = tc.axis;
      ctx.lineWidth = 1;
      // X-axis
      ctx.beginPath();
      ctx.moveTo(originX - axisLenX - 10, originY);
      ctx.lineTo(originX + axisLenX + 10, originY);
      ctx.stroke();
      // Y-axis
      ctx.beginPath();
      ctx.moveTo(originX, originY + axisLenY + 10);
      ctx.lineTo(originX, originY - axisLenY - 10);
      ctx.stroke();

      // Tick marks â€” Â±10 from origin
      ctx.fillStyle = tc.tickText;
      ctx.font = (9 * fs()) + 'px Andika, sans-serif';
      const tickStep = getTickStep();

      // X-axis ticks
      ctx.textAlign = 'center';
      for (let i = tickStep; i <= AXIS_MAX; i += tickStep) {
        const px = originX + i * scaleX;
        ctx.strokeStyle = tc.axis;
        ctx.beginPath(); ctx.moveTo(px, originY - 4); ctx.lineTo(px, originY + 4); ctx.stroke();
        ctx.fillText(i, px, originY + 14 * fs());
      }
      for (let i = -tickStep; i >= -AXIS_MAX; i -= tickStep) {
        const px = originX + i * scaleX;
        ctx.strokeStyle = tc.axis;
        ctx.beginPath(); ctx.moveTo(px, originY - 4); ctx.lineTo(px, originY + 4); ctx.stroke();
        ctx.fillText(i, px, originY + 14 * fs());
      }

      // Y-axis ticks
      ctx.textAlign = 'right';
      for (let i = tickStep; i <= AXIS_MAX; i += tickStep) {
        const py = originY - i * scaleY;
        ctx.strokeStyle = tc.axis;
        ctx.beginPath(); ctx.moveTo(originX - 4, py); ctx.lineTo(originX + 4, py); ctx.stroke();
        ctx.fillText(i, originX - 6, py + 3);
      }
      for (let i = -tickStep; i >= -AXIS_MAX; i -= tickStep) {
        const py = originY - i * scaleY;
        ctx.strokeStyle = tc.axis;
        ctx.beginPath(); ctx.moveTo(originX - 4, py); ctx.lineTo(originX + 4, py); ctx.stroke();
        ctx.fillText(i, originX - 6, py + 3);
      }

      // Origin label
      ctx.fillStyle = tc.tickText;
      ctx.textAlign = 'right';
      ctx.fillText('O', originX - 8, originY + 14 * fs());

      // Axis arrow tips at Â±10 boundary
      var arrSize = 8;
      var xEnd = originX + axisLenX + 10;
      var yEnd = originY - axisLenY - 10;
      ctx.fillStyle = tc.axisArrow;
      // X-axis arrow (positive end)
      ctx.beginPath();
      ctx.moveTo(xEnd, originY);
      ctx.lineTo(xEnd - arrSize, originY - arrSize / 2);
      ctx.lineTo(xEnd - arrSize, originY + arrSize / 2);
      ctx.closePath();
      ctx.fill();
      // Y-axis arrow (positive end, top)
      ctx.beginPath();
      ctx.moveTo(originX, yEnd);
      ctx.lineTo(originX - arrSize / 2, yEnd + arrSize);
      ctx.lineTo(originX + arrSize / 2, yEnd + arrSize);
      ctx.closePath();
      ctx.fill();

      // Axis labels
      ctx.fillStyle = tc.axisLabel;
      ctx.font = 'bold ' + (12 * fs()) + 'px Andika, sans-serif';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText('x', xEnd + 6, originY);
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText('y', originX, yEnd - 4);
      ctx.textBaseline = 'alphabetic';
    }

    function getTickStep() {
      // Axes always span 10 units â€” use step 2 for clean labels
      return 2;
    }

    function drawArrow(x1, y1, x2, y2, color, width) {
      const headlen = 12;
      const angle = Math.atan2(y2 - y1, x2 - x1);

      ctx.save();
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = width;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6), y2 - headlen * Math.sin(angle - Math.PI / 6));
      ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI / 6), y2 - headlen * Math.sin(angle + Math.PI / 6));
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawAngleArc(angle1Rad, angle2Rad, radius) {
      // Compute screen-space angles of the two vectors
      // Vector on screen: (cos(a)*scaleX, -sin(a)*scaleY)
      var screenA1 = Math.atan2(-Math.sin(angle1Rad) * scaleY, Math.cos(angle1Rad) * scaleX);
      var screenA2 = Math.atan2(-Math.sin(angle2Rad) * scaleY, Math.cos(angle2Rad) * scaleX);

      // Determine sweep direction â€” take the shorter arc
      var diff = screenA2 - screenA1;
      while (diff > Math.PI) diff -= 2 * Math.PI;
      while (diff < -Math.PI) diff += 2 * Math.PI;
      var counterClockwise = diff < 0;

      ctx.save();
      ctx.beginPath();
      ctx.moveTo(originX, originY);
      ctx.arc(originX, originY, radius, screenA1, screenA2, counterClockwise);
      ctx.closePath();
      ctx.fillStyle = tc.arcFill;
      ctx.fill();
      ctx.strokeStyle = tc.arcStroke;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(originX, originY, radius, screenA1, screenA2, counterClockwise);
      ctx.stroke();

      // Angle label â€” show the true world-space angle between vectors
      var midScreen = screenA1 + diff / 2;
      var labelR = radius + 14;
      ctx.fillStyle = tc.arcStroke;
      ctx.font = (10 * fs()) + 'px Andika, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      var angleDiff = Math.abs(angle2Rad - angle1Rad) * 180 / Math.PI;
      if (angleDiff > 180) angleDiff = 360 - angleDiff;
      ctx.fillText(angleDiff.toFixed(0) + '\u00B0', originX + Math.cos(midScreen) * labelR, originY + Math.sin(midScreen) * labelR);
      ctx.restore();
    }

    function draw() {
      drawBg();

      const magA = parseFloat(magASlider.value);
      const angleA = parseFloat(angleASlider.value);
      const magB = parseFloat(magBSlider.value);
      const angleB = parseFloat(angleBSlider.value);

      const radA = angleA * Math.PI / 180;
      const radB = angleB * Math.PI / 180;

      // Vector A components
      const Ax = magA * Math.cos(radA);
      const Ay = magA * Math.sin(radA);

      // Vector B components
      const Bx = magB * Math.cos(radB);
      const By = magB * Math.sin(radB);

      // Resultant components
      const Rx = Ax + Bx;
      const Ry = Ay + By;
      const magR = Math.sqrt(Rx * Rx + Ry * Ry);
      const angleR = Math.atan2(Ry, Rx) * 180 / Math.PI;

      // Screen coordinates
      const endAx = wx(Ax);
      const endAy = wy(Ay);
      const endBx = wx(Bx);
      const endBy = wy(By);
      const endRx = wx(Rx);
      const endRy = wy(Ry);

      // === PARALLELOGRAM FILL & PROJECTIONS (only when R > 0) ===
      if (magR > 0.05) {
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(originX, originY);
        ctx.lineTo(endAx, endAy);
        ctx.lineTo(endRx, endRy);
        ctx.lineTo(endBx, endBy);
        ctx.closePath();
        ctx.fillStyle = tc.paraFill;
        ctx.fill();
        ctx.restore();

        // Parallelogram dashed lines
        ctx.save();
        ctx.setLineDash([5, 5]);
        ctx.strokeStyle = tc.parallelogram;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(endAx, endAy);
        ctx.lineTo(endRx, endRy);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(endBx, endBy);
        ctx.lineTo(endRx, endRy);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();

        // Component projection lines
        ctx.save();
        ctx.setLineDash([4, 4]);
        ctx.lineWidth = 1;
        ctx.strokeStyle = tc.projLine;
        ctx.beginPath();
        ctx.moveTo(endRx, endRy);
        ctx.lineTo(endRx, originY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(endRx, endRy);
        ctx.lineTo(originX, endRy);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = tc.labelR;
        ctx.font = (9 * fs()) + 'px Andika, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Rx', endRx, originY + 16 * fs());
        ctx.textAlign = 'right';
        ctx.fillText('Ry', originX - 6, endRy + 3);
        ctx.restore();
      }

      // Angle arc between A and B
      var arcRadius = Math.min(40, Math.min(scaleX, scaleY) * Math.min(magA, magB) * 0.6);
      if (arcRadius > 15) {
        drawAngleArc(radA, radB, arcRadius);
      }

      // Draw vectors with glow
      ctx.save();
      ctx.shadowColor = tc.labelA;
      ctx.shadowBlur = 8;
      drawArrow(originX, originY, endAx, endAy, tc.labelA, 3);
      ctx.restore();

      ctx.save();
      ctx.shadowColor = tc.labelB;
      ctx.shadowBlur = 8;
      drawArrow(originX, originY, endBx, endBy, tc.labelB, 3);
      ctx.restore();

      // Only draw R arrow and label if magnitude is non-negligible
      var showR = magR > 0.05;
      if (showR) {
        ctx.save();
        ctx.shadowColor = tc.labelR;
        ctx.shadowBlur = 10;
        drawArrow(originX, originY, endRx, endRy, tc.labelR, 4);
        ctx.restore();
      }

      // Labels at arrow tips
      var labelFs = (12 * fs()) + 'px Andika, sans-serif';
      ctx.font = labelFs;
      ctx.textBaseline = 'middle';

      ctx.fillStyle = tc.labelA;
      ctx.textAlign = 'left';
      ctx.fillText('A', endAx + 10, endAy - 10);

      ctx.fillStyle = tc.labelB;
      ctx.fillText('B', endBx + 10, endBy - 10);

      if (showR) {
        ctx.fillStyle = tc.labelR;
        ctx.font = 'bold ' + labelFs;
        ctx.fillText('R', endRx + 10, endRy - 10);
      }


      // === DRAG HANDLES (subtle circles at arrowheads) ===
      ctx.save();
      ctx.globalAlpha = dragging ? 0.5 : 0.2;
      ctx.strokeStyle = tc.labelA;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(endAx, endAy, DRAG_RADIUS, 0, Math.PI * 2);
      ctx.stroke();
      ctx.strokeStyle = tc.labelB;
      ctx.beginPath();
      ctx.arc(endBx, endBy, DRAG_RADIUS, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();

      // Derivation animation overlay
      drawDerivation(magA, angleA, magB, angleB, radA, radB, Ax, Ay, Bx, By, Rx, Ry, endAx, endAy, endBx, endBy, endRx, endRy);

      // Update data panel
      var angleBetween = angleB - angleA;
      if (angleBetween < 0) angleBetween += 360;
      if (angleBetween > 180) angleBetween = 360 - angleBetween;

      document.getElementById('d-magR').textContent = magR.toFixed(2);
      var displayAngleR = angleR >= 0 ? angleR : 360 + angleR;
      document.getElementById('d-angleR').innerHTML = displayAngleR.toFixed(1) + '&deg;';
      document.getElementById('d-Rx').textContent = Rx.toFixed(2);
      document.getElementById('d-Ry').textContent = Ry.toFixed(2);
      document.getElementById('d-angleBetween').innerHTML = angleBetween.toFixed(0) + '&deg;';
    }

    // === DERIVATION ANIMATION ===
    let animating = false;
    let animProgress = 0;
    let animId = null;
    const ANIM_DURATION = 3000; // ms total
    let animStartTime = 0;

    function startAnimation() {
      if (animating) return;
      animating = true;
      window._achDerivationPlayed = true;
      animProgress = 0;
      animStartTime = performance.now();
      animateFrame();
    }

    function animateFrame() {
      var now = performance.now();
      animProgress = Math.min(1, (now - animStartTime) / ANIM_DURATION);
      draw();
      if (animProgress < 1) {
        animId = requestAnimationFrame(animateFrame);
      } else {
        animId = null;
        // Keep animating = true so the derivation stays visible
      }
    }

    function drawDerivation(magA, angleA, magB, angleB, radA, radB, Ax, Ay, Bx, By, Rx, Ry, endAx, endAy, endBx, endBy, endRx, endRy) {
      if (!animating) return;

      var isLight = document.documentElement.getAttribute('data-theme') === 'light';
      var t = animProgress;

      // Phase 1 (0-0.3): Draw vector B translated to tip of A (triangle law)
      // Phase 2 (0.3-0.6): Drop perpendicular from R tip to the line extending A
      // Phase 3 (0.6-1.0): Label the right triangle sides and show the formula

      var phase1 = Math.min(1, t / 0.3);
      var phase2 = Math.min(1, Math.max(0, (t - 0.3) / 0.3));
      var phase3 = Math.min(1, Math.max(0, (t - 0.6) / 0.4));

      // Easing
      phase1 = easeInOut(phase1);
      phase2 = easeInOut(phase2);
      phase3 = easeInOut(phase3);

      ctx.save();

      // Phase 1: Translated B vector from tip of A to tip of R
      if (phase1 > 0) {
        var bStartX = originX + phase1 * Ax * scaleX;
        var bStartY = originY - phase1 * Ay * scaleY;
        var bEndX = bStartX + phase1 * Bx * scaleX;
        var bEndY = bStartY - phase1 * By * scaleY;

        ctx.globalAlpha = phase1 * 0.8;
        ctx.setLineDash([6, 4]);
        drawArrow(bStartX, bStartY, bEndX, bEndY, '#7c3aed', 2);
        ctx.setLineDash([]);

        // Label "B" on the translated vector
        if (phase1 > 0.5) {
          ctx.globalAlpha = (phase1 - 0.5) * 2;
          ctx.fillStyle = '#7c3aed';
          ctx.font = (11 * fs()) + 'px Andika, sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('B', (bStartX + bEndX) / 2 + 12, (bStartY + bEndY) / 2 - 8);
        }
      }

      // Phase 2: Drop perpendicular from R-tip to extended A-line
      if (phase2 > 0) {
        ctx.globalAlpha = phase2 * 0.9;

        // The angle between A and B
        var thetaBetween = radB - radA;

        // Foot of perpendicular from R tip onto line through A direction
        // Project R onto A direction: foot = A + B*cos(theta_between) along A direction
        var projLen = magA + magB * Math.cos(thetaBetween); // length along A direction
        var footX = wx(projLen * Math.cos(radA));
        var footY = wy(projLen * Math.sin(radA));

        // Extend the A-direction line to the foot
        var extColor = isLight ? 'rgba(0,212,255,0.3)' : 'rgba(0,212,255,0.25)';
        ctx.strokeStyle = extColor;
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(endAx, endAy);
        ctx.lineTo(footX, footY);
        ctx.stroke();
        ctx.setLineDash([]);

        // Perpendicular line from foot to R tip (animated)
        var perpEndX = footX + phase2 * (endRx - footX);
        var perpEndY = footY + phase2 * (endRy - footY);

        ctx.strokeStyle = '#ff6b6b';
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 3]);
        ctx.beginPath();
        ctx.moveTo(footX, footY);
        ctx.lineTo(perpEndX, perpEndY);
        ctx.stroke();
        ctx.setLineDash([]);

        // Right angle marker at foot
        if (phase2 > 0.5) {
          var markerSize = 8;
          // Direction along A
          var dAx = Math.cos(radA);
          var dAy = -Math.sin(radA);
          // Direction perpendicular (toward R tip)
          var pDx = endRx - footX;
          var pDy = endRy - footY;
          var pLen = Math.sqrt(pDx * pDx + pDy * pDy);
          if (pLen > 0) {
            pDx /= pLen; pDy /= pLen;
          }

          ctx.strokeStyle = isLight ? 'rgba(0,0,0,0.4)' : 'rgba(255,255,255,0.4)';
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          // Determine direction of A extension relative to foot
          var signA = projLen >= magA ? -1 : 1;
          ctx.moveTo(footX + signA * dAx * markerSize, footY + signA * dAy * markerSize);
          ctx.lineTo(footX + signA * dAx * markerSize + pDx * markerSize, footY + signA * dAy * markerSize + pDy * markerSize);
          ctx.lineTo(footX + pDx * markerSize, footY + pDy * markerSize);
          ctx.stroke();
        }
      }

      // Phase 3: Labels on triangle sides
      if (phase3 > 0) {
        ctx.globalAlpha = phase3;

        var thetaBetween2 = radB - radA;
        var projLen2 = magA + magB * Math.cos(thetaBetween2);
        var footX2 = wx(projLen2 * Math.cos(radA));
        var footY2 = wy(projLen2 * Math.sin(radA));

        var perpHeight = Math.abs(magB * Math.sin(thetaBetween2));
        var baseLen = projLen2;

        ctx.font = 'bold ' + (10 * fs()) + 'px Andika, sans-serif';

        // Label base: "A + B cos\u03B8"
        var baseMidX = (originX + footX2) / 2;
        var baseMidY = (originY + footY2) / 2;
        ctx.fillStyle = tc.labelA;
        ctx.textAlign = 'center';
        var offsetX = Math.sin(radA) * 18;
        var offsetY = Math.cos(radA) * 18;
        ctx.fillText('A + Bcos\u03B8', baseMidX + offsetX, baseMidY + offsetY);

        // Label perpendicular: "B sin\u03B8"
        var perpMidX = (footX2 + endRx) / 2;
        var perpMidY = (footY2 + endRy) / 2;
        ctx.fillStyle = '#ff6b6b';
        ctx.textAlign = 'left';
        ctx.fillText('Bsin\u03B8', perpMidX + 10, perpMidY);

        // Label hypotenuse: "R"
        var hypMidX = (originX + endRx) / 2;
        var hypMidY = (originY + endRy) / 2;
        ctx.fillStyle = tc.labelR;
        ctx.font = 'bold ' + (12 * fs()) + 'px Andika, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('R', hypMidX - 14, hypMidY - 10);

        // Formula box at top-left
        if (phase3 > 0.3) {
          var boxAlpha = (phase3 - 0.3) / 0.7;
          ctx.globalAlpha = boxAlpha;
          var pad = 14;
          var titleFont = Math.round(10 * fs());
          var formulaFont = Math.round(11 * fs());

          // Measure text to size box dynamically
          ctx.font = titleFont + 'px Andika, sans-serif';
          var titleText = 'By Pythagoras on the right triangle:';
          var titleW = ctx.measureText(titleText).width;
          ctx.font = 'bold ' + formulaFont + 'px Andika, sans-serif';
          var formulaText = 'R\u00B2 = (A + Bcos\u03B8)\u00B2 + (Bsin\u03B8)\u00B2';
          var formulaW = ctx.measureText(formulaText).width;

          var boxW = Math.max(titleW, formulaW) + pad * 2;
          var boxH = 52;
          var boxX = 20;
          var boxY = 20;

          ctx.fillStyle = isLight ? 'rgba(255,255,255,0.92)' : 'rgba(10,10,30,0.92)';
          ctx.beginPath();
          ctx.roundRect(boxX, boxY, boxW, boxH, 8);
          ctx.fill();
          ctx.strokeStyle = 'rgba(124,58,237,0.3)';
          ctx.lineWidth = 1;
          ctx.stroke();

          ctx.fillStyle = isLight ? '#333' : '#eee';
          ctx.font = titleFont + 'px Andika, sans-serif';
          ctx.textAlign = 'left';
          ctx.fillText(titleText, boxX + pad, boxY + 18);
          ctx.font = 'bold ' + formulaFont + 'px Andika, sans-serif';
          ctx.fillStyle = tc.labelR;
          ctx.fillText(formulaText, boxX + pad, boxY + 38);
        }
      }

      ctx.restore();
    }

    function easeInOut(t) {
      return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    }


    // === INTERACTIVE DRAG-TO-SET VECTORS ===
    canvas.addEventListener('mousedown', function(e) {
      var rect = canvas.getBoundingClientRect();
      var mx = e.clientX - rect.left;
      var my = e.clientY - rect.top;

      var magA = parseFloat(magASlider.value);
      var radA = parseFloat(angleASlider.value) * Math.PI / 180;
      var eAx = wx(magA * Math.cos(radA));
      var eAy = wy(magA * Math.sin(radA));

      var magB = parseFloat(magBSlider.value);
      var radB = parseFloat(angleBSlider.value) * Math.PI / 180;
      var eBx = wx(magB * Math.cos(radB));
      var eBy = wy(magB * Math.sin(radB));

      var distA = Math.hypot(mx - eAx, my - eAy);
      var distB = Math.hypot(mx - eBx, my - eBy);

      if (distA < DRAG_RADIUS) { dragging = 'A'; canvas.style.cursor = 'grabbing'; }
      else if (distB < DRAG_RADIUS) { dragging = 'B'; canvas.style.cursor = 'grabbing'; }
    });

    canvas.addEventListener('mousemove', function(e) {
      if (!dragging) {
        // Show grab cursor when hovering over arrowheads
        var rect = canvas.getBoundingClientRect();
        var mx = e.clientX - rect.left;
        var my = e.clientY - rect.top;
        var magA = parseFloat(magASlider.value);
        var radA = parseFloat(angleASlider.value) * Math.PI / 180;
        var eAx = wx(magA * Math.cos(radA));
        var eAy = wy(magA * Math.sin(radA));
        var magB = parseFloat(magBSlider.value);
        var radB = parseFloat(angleBSlider.value) * Math.PI / 180;
        var eBx = wx(magB * Math.cos(radB));
        var eBy = wy(magB * Math.sin(radB));
        if (Math.hypot(mx - eAx, my - eAy) < DRAG_RADIUS || Math.hypot(mx - eBx, my - eBy) < DRAG_RADIUS) {
          canvas.style.cursor = 'grab';
        } else {
          canvas.style.cursor = 'default';
        }
        return;
      }

      var rect = canvas.getBoundingClientRect();
      var mx = e.clientX - rect.left;
      var my = e.clientY - rect.top;

      var worldX = (mx - originX) / scaleX;
      var worldY = -(my - originY) / scaleY;
      var mag = Math.sqrt(worldX * worldX + worldY * worldY);
      var angle = Math.atan2(worldY, worldX) * 180 / Math.PI;
      if (angle < 0) angle += 360;

      // Clamp magnitude to slider range
      mag = Math.max(1, Math.min(10, Math.round(mag * 2) / 2)); // snap to 0.5 steps

      // Sticky angles: snap near axis values
      var snapAngles = [0, 90, 180, 270, 360];
      var SNAP_RANGE = 5; // degrees
      var roundedAngle = Math.round(angle);
      for (var s = 0; s < snapAngles.length; s++) {
        if (Math.abs(roundedAngle - snapAngles[s]) <= SNAP_RANGE) {
          roundedAngle = snapAngles[s];
          break;
        }
      }
      if (roundedAngle === 360) roundedAngle = 0;

      if (dragging === 'A') {
        syncMagA(mag);
        syncAngleA(roundedAngle);
      } else {
        syncMagB(mag);
        syncAngleB(roundedAngle);
      }
    });

    function stopDrag() {
      if (dragging) {
        dragging = null;
        canvas.style.cursor = 'default';
      }
    }
    canvas.addEventListener('mouseup', stopDrag);
    canvas.addEventListener('mouseleave', stopDrag);

    // Touch support for drag
    canvas.addEventListener('touchstart', function(e) {
      var touch = e.touches[0];
      var rect = canvas.getBoundingClientRect();
      var mx = touch.clientX - rect.left;
      var my = touch.clientY - rect.top;

      var magA = parseFloat(magASlider.value);
      var radA = parseFloat(angleASlider.value) * Math.PI / 180;
      var eAx = wx(magA * Math.cos(radA));
      var eAy = wy(magA * Math.sin(radA));
      var magB = parseFloat(magBSlider.value);
      var radB = parseFloat(angleBSlider.value) * Math.PI / 180;
      var eBx = wx(magB * Math.cos(radB));
      var eBy = wy(magB * Math.sin(radB));

      var distA = Math.hypot(mx - eAx, my - eAy);
      var distB = Math.hypot(mx - eBx, my - eBy);
      var touchR = DRAG_RADIUS * 1.5; // larger touch target

      if (distA < touchR) { dragging = 'A'; e.preventDefault(); }
      else if (distB < touchR) { dragging = 'B'; e.preventDefault(); }
    }, { passive: false });

    canvas.addEventListener('touchmove', function(e) {
      if (!dragging) return;
      e.preventDefault();
      var touch = e.touches[0];
      var rect = canvas.getBoundingClientRect();
      var mx = touch.clientX - rect.left;
      var my = touch.clientY - rect.top;

      var worldX = (mx - originX) / scaleX;
      var worldY = -(my - originY) / scaleY;
      var mag = Math.sqrt(worldX * worldX + worldY * worldY);
      var angle = Math.atan2(worldY, worldX) * 180 / Math.PI;
      if (angle < 0) angle += 360;
      mag = Math.max(1, Math.min(10, Math.round(mag * 2) / 2));

      // Sticky angles: snap near axis values
      var snapAngles = [0, 90, 180, 270, 360];
      var SNAP_RANGE = 5;
      var roundedAngle = Math.round(angle);
      for (var s = 0; s < snapAngles.length; s++) {
        if (Math.abs(roundedAngle - snapAngles[s]) <= SNAP_RANGE) {
          roundedAngle = snapAngles[s];
          break;
        }
      }
      if (roundedAngle === 360) roundedAngle = 0;

      if (dragging === 'A') {
        syncMagA(mag);
        syncAngleA(roundedAngle);
      } else {
        syncMagB(mag);
        syncAngleB(roundedAngle);
      }
    }, { passive: false });

    canvas.addEventListener('touchend', stopDrag);

    function resetSim() {
      if (animId) { cancelAnimationFrame(animId); animId = null; }
      animating = false;
      animProgress = 0;
      syncMagA(5);
      syncAngleA(30);
      syncMagB(4);
      syncAngleB(120);
    }

    // === FULLSCREEN ===
    document.getElementById('fullscreenBtn').addEventListener('click', function() {
      var el = document.getElementById('simArea');
      if (!document.fullscreenElement) {
        (el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen).call(el);
      } else {
        (document.exitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen).call(document);
      }
    });

    document.addEventListener('fullscreenchange', function() {
      setTimeout(resizeCanvas, 100);
      setTimeout(resizeCanvas, 300);
    });

    // === EVENT LISTENERS ===
    document.getElementById('resetBtn').addEventListener('click', resetSim);
    document.getElementById('animateBtn').addEventListener('click', startAnimation);

    // === TUTORIAL OVERLAY ===
    function showTutorial() {
      var el = document.getElementById('simTutorial');
      el.style.display = '';
      el.offsetHeight; // force reflow for transition
      el.style.opacity = '1';
      positionTutorialHints();
    }

    window.addEventListener('resize', function() {
      if (document.getElementById('simTutorial').style.display !== 'none') {
        positionTutorialHints();
      }
    });

    function dismissTutorial() {
      var el = document.getElementById('simTutorial');
      el.style.opacity = '0';
      setTimeout(function() { el.style.display = 'none'; }, 400);
      localStorage.setItem('tut-vector-addition', '1');
    }

    function drawCurvedArrow(svg, x1, y1, x2, y2) {
      var ns = 'http://www.w3.org/2000/svg';
      var dx = x2 - x1;
      var dy = y2 - y1;
      var cx1 = x1 + dx * 0.2;
      var cy1 = y1 + dy * 0.6;
      var cx2 = x1 + dx * 0.8;
      var cy2 = y1 + dy * 0.4;

      var path = document.createElementNS(ns, 'path');
      path.setAttribute('d',
        'M' + x1 + ',' + y1 +
        ' C' + cx1 + ',' + cy1 +
        ' ' + cx2 + ',' + cy2 +
        ' ' + x2 + ',' + y2
      );
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke', 'rgba(255,255,255,0.85)');
      path.setAttribute('stroke-width', '2');
      path.setAttribute('stroke-linecap', 'round');
      svg.appendChild(path);

      var angle = Math.atan2(y2 - cy2, x2 - cx2);
      var headLen = 10;
      var a1x = x2 - headLen * Math.cos(angle - 0.4);
      var a1y = y2 - headLen * Math.sin(angle - 0.4);
      var a2x = x2 - headLen * Math.cos(angle + 0.4);
      var a2y = y2 - headLen * Math.sin(angle + 0.4);
      var arrow = document.createElementNS(ns, 'polygon');
      arrow.setAttribute('points',
        x2 + ',' + y2 + ' ' +
        a1x + ',' + a1y + ' ' +
        a2x + ',' + a2y
      );
      arrow.setAttribute('fill', 'rgba(255,255,255,0.85)');
      svg.appendChild(arrow);
    }

    function positionTutorialHints() {
      var area = document.getElementById('simArea');
      var areaRect = area.getBoundingClientRect();
      var svg = document.getElementById('tutArrowsSvg');
      svg.innerHTML = '';

      var targets = [
        { hint: 'tutDrag',    el: document.getElementById('simCanvas'),  type: 'canvas' },
        { hint: 'tutMagA',    el: document.getElementById('magA'),       type: 'bottom' },
        { hint: 'tutAngleA',  el: document.getElementById('angleA'),     type: 'bottom' },
        { hint: 'tutAnimate', el: document.getElementById('animateBtn'), type: 'below' },
        { hint: 'tutData',    el: document.querySelector('.side-data'),   type: 'side'   }
      ];

      var placed = [];

      for (var i = 0; i < targets.length; i++) {
        var t = targets[i];
        var hintEl = document.getElementById(t.hint);
        var elRect = t.el.getBoundingClientRect();
        var cx = elRect.left + elRect.width / 2 - areaRect.left;
        var cy = elRect.top - areaRect.top;

        if (t.type === 'canvas') {
          // Position in center of canvas
          var midX = elRect.left + elRect.width / 2 - areaRect.left;
          var midY = elRect.top + elRect.height * 0.35 - areaRect.top;
          hintEl.style.left = midX + 'px';
          hintEl.style.top = midY + 'px';
          hintEl.style.transform = 'translateX(-50%)';
          hintEl.style.right = '';
          continue;
        }

        if (t.type === 'below') {
          // Position hint below the target element with arrow pointing up
          hintEl.style.left = cx + 'px';
          hintEl.style.transform = 'translateX(-50%)';
          var belowTop = elRect.bottom - areaRect.top + 12;
          hintEl.style.top = belowTop + 'px';
          hintEl.style.right = '';

          var hRect = hintEl.getBoundingClientRect();
          var arrowStartX = cx;
          var arrowStartY = belowTop - 2;
          var arrowEndX = cx;
          var arrowEndY = elRect.bottom - areaRect.top + 2;
          drawCurvedArrow(svg, arrowStartX, arrowStartY, arrowEndX, arrowEndY);
          continue;
        }

        if (t.type === 'side') {
          var midY = elRect.top + elRect.height / 2 - areaRect.top;
          hintEl.style.top = midY + 'px';
          hintEl.style.right = (areaRect.right - elRect.left + 8) + 'px';
          hintEl.style.left = '';
          hintEl.style.transform = '';

          var hRect = hintEl.getBoundingClientRect();
          var arrowStartX = hRect.right - areaRect.left + 4;
          var arrowStartY = hRect.top + hRect.height / 2 - areaRect.top;
          var arrowEndX = elRect.left - areaRect.left - 2;
          var arrowEndY = midY;
          drawCurvedArrow(svg, arrowStartX, arrowStartY, arrowEndX, arrowEndY);
          continue;
        }

        hintEl.style.left = cx + 'px';
        hintEl.style.transform = 'translateX(-50%)';
        hintEl.style.top = '0px';

        var hintRect = hintEl.getBoundingClientRect();
        var hintW = hintRect.width;
        var hintH = hintRect.height;

        var desiredTop = cy - 50;
        var hintLeft = cx - hintW / 2;
        var hintRight = hintLeft + hintW;

        var finalTop = desiredTop;
        for (var j = 0; j < placed.length; j++) {
          var p = placed[j];
          if (hintRight > p.left && hintLeft < p.right) {
            if (finalTop + hintH > p.top && finalTop < p.bottom) {
              finalTop = p.top - hintH - 8;
            }
          }
        }

        hintEl.style.top = finalTop + 'px';
        placed.push({
          left: hintLeft,
          right: hintRight,
          top: finalTop,
          bottom: finalTop + hintH
        });

        var arrowStartX = cx;
        var arrowStartY = finalTop + hintH + 2;
        var arrowEndX = cx;
        var arrowEndY = cy + 2;
        drawCurvedArrow(svg, arrowStartX, arrowStartY, arrowEndX, arrowEndY);
      }
    }

    // Auto-show on first visit
    if (!localStorage.getItem('tut-vector-addition')) {
      showTutorial();
    }

    // Dismiss on click anywhere on overlay
    document.getElementById('simTutorial').addEventListener('click', dismissTutorial);

    // Help button re-shows overlay
    document.getElementById('helpBtn').addEventListener('click', showTutorial);

    // Init
    resizeCanvas();
  </script>
  <script src="../js/main.js"></script>
  <script src="../js/auth-gate.js"></script>
<script>if("serviceWorker" in navigator){navigator.serviceWorker.register("/sw.js");}</script>
</body>
</html>
